<chapter id="logback_logback_configuration">
	<title>Configuration</title>
	<para> Logback은 구성요소 측면에서 Log4j와 유사한 구조를 가지고 있다.
	Logback을 이용하여 로깅을 수행하기 위해서 필요한  주요 설정요소로는  Logger, Appender, Encoder의 3가지가 있으며 각각은 다음과 같은 역할을 수행한다.</para>
	
	<itemizedlist>
		<listitem><para>Logger : 실제 로깅을 수행하는 구성요소로 Level 속성을 통해서 출력할 로그의 레벨을 조절할 수 있다.</para></listitem>
		<listitem><para>Appender : 로그 메시지가 출력될 대상을 결정하는 요소  </para></listitem>
		<listitem><para>Encoder : Appender에 포함되어 사용자가 지정한 형식으로 표현 될 로그메시지를 변환하는 역할을 담당하는 요소 </para></listitem>
	</itemizedlist>
	
	<para></para>
	
	<para>Logback에서 설정파일을 작성하는 방법은 크게 두 가지가 있다. </para>
	<itemizedlist>
		<listitem><para>XML을 이용한 설정방법 : logback.xml로 설정 파일 작성 후 해당 파일을 클래스패스에 위치시킨다.</para></listitem>
		<listitem><para>Groovy 언어를 이용한 설정방법 : logback.groovy로 설정 파일 작성 후 해당 파일을 클래스패스에 위치시킨다. </para></listitem>
	</itemizedlist>
	<para>이 매뉴얼에서는 위에서 언급한 Logback 설정요소들과 xml을 이용한 설정 방법 에 대해서 설명하고자 한다. Groovy언어를 이용한 설정방법에 대해서는  <ulink url="http://logback.qos.ch/manual/groovy.html">여기</ulink>를 참조하도록 한다.</para>
	
	<section id="logback_logback_configuration_appender">
		<title>Appender</title>
		<para>Appender는 로그를 수행할때 로그 정보를 어디에 기록할지를 결정한다. 로그정보를 기록할 수 있는 곳으로는 콘솔, 파일, DB, 메일, JMS등이 있다. 
		다음은 logback에서 제공하는 Appender와 설정 방법을 기술하였다. </para>
		
		<section id="logback_logback_configuration_appender_console">
			<title>ConsoleAppender</title>
			<para>ConsoleAppender는 로그정보를 콘솔로 출력하는 기능을 수행한다.
			다음은 ConsoleAppender를 설정하는 예제이다. </para> 
			<para> Pattern 속성을 지정하여 어플리케이션이 시작한 이후로 부터  로그이벤트가 생성된 상대적 시간(ms), 쓰레드명, 로그레벨, 로거명, 로그 메시지를 출력하도록 설정한 예제이다.
			encoder에 대한 좀 더 자세한 설명은 <link linkend="logback_logback_configuration_encoder">encoder</link>를 참조한다.  
			</para>
			<programlisting language="xml"><![CDATA[    <appender name="console" class="ch.qos.logback.ConsoleAppender">
        <encoder>
            <pattern>%-4relative [%thread] %-5level %logger{35} - %msg %n</pattern>
        </encoder>
    </appender>]]></programlisting>
	    
	    <para>다음은 위에서 정의한 ConsoleAppender를 활용하여 출력한 로그메시지의 일부이다.  </para>
	    <programlisting language="java"><![CDATA[    215  [main] INFO  consoleLogger - console Appender Test 
    220  [main] DEBUG consoleLogger - this is a debug log message]]></programlisting> 
		</section>
		
		<section id="logback_logback_configuration_appender_file">
			<title>FileAppender</title>
			<para>FileAppender는 로그정보를 특정 파일로 출력하는 기능을 수행한다. </para> 
			<para>FileAppender의 주요속성들은 다음과 같다.</para>
			
			<informaltable>
				<caption>FileAppender의 주요속성</caption>
				<tgroup cols="4">
					<colspec colnum="1" colname="col1" colwidth="1*" />
					<colspec colnum="2" colname="col2" colwidth="6*" />
					<colspec colnum="3" colname="col3" colwidth="1*" />
					<colspec colnum="4" colname="col4" colwidth="1*" />
					<thead>
						<row>
							<entry align="center">속성명</entry>
							<entry align="center">기능</entry>
							<entry align="center">타입</entry>
							<entry align="center">기본값</entry>				
						</row>
					</thead>
					<tbody>
						<row>
							<entry>append</entry>	
							<entry>기존에 존재하는 파일에 로그를 남길때 해당 파일에 추가하여 로그를 남길지 여부를 설정하는 속성</entry>
							<entry>boolean</entry>
							<entry>true</entry>
						</row>
						<row>
							<entry>file</entry>	
							<entry>로그를 출력할 파일명을 설정할 수 있는 속성. 해당 경로에 파일이 존재하지 않을 경우 해당 파일 생성</entry>
							<entry>String</entry>
							<entry>N/A</entry>
						</row>
						<row>
							<entry>prudent</entry>	
							<entry>다수의 JVM에 하나의 파일에 로그를 안전하게 남길수 있도록 동기화를 할지 여부를 결정하는 속성</entry>
							<entry>boolean</entry>
							<entry>false</entry>
						</row>
					</tbody>			
				</tgroup>
			</informaltable>
			
			<para> 다음은 FileAppender를 설정하는 예제이다. </para>
			<programlisting language="xml"><![CDATA[    <appender name="file" class="ch.qos.logback.core.FileAppender">
        <file>testFile.log</file>
        <encoder>
            <pattern>%-4relative [%thread] %-5level %logger{35} - %msg %n</pattern>
        </encoder>
    </appender>]]></programlisting>
		</section>
		
		<section id="logback_logback_configuration_appender_rollingfile">
			<title>RollingFileAppender</title>
			<para> 하나의 파일에 모든 로그를 남기는 방법은 로그의 검색, 관리적인 면에서 효율적이지 못하다. RollingFileAppender는  사용자가 설정한 조건 (파일크기, 시간 등)에 따라서 로그파일을 변경하여 로그정보를 출력하는 기능을 수행한다. </para>
			<para> RollingFileAppender은 기본적으로 FileAppender의 모든 속성들을 가지고 있고 RollingAppender의 추가적인 속성들은 다음과 같다.  </para>
			
			<informaltable>
				<caption>RollingAppender의 추가적인 속성</caption>
				<tgroup cols="4">
					<colspec colnum="1" colname="col1" colwidth="2*" />
					<colspec colnum="2" colname="col2" colwidth="4*" />
					<colspec colnum="3" colname="col3" colwidth="1*" />
					<colspec colnum="4" colname="col4" colwidth="1*" />
					<thead>
						<row>
							<entry align="center">속성명</entry>
							<entry align="center">기능</entry>
							<entry align="center">타입</entry>
							<entry align="center">기본값</entry>				
						</row>
					</thead>
					<tbody>
						<row>
							<entry>triggeringPolicy</entry>	
							<entry>어떤 조건에서 rolling 이벤트가  발생할 지 조건을 결정하는 속성</entry>
							<entry>ch.qos.logback.core.rolling.TriggeringPolicy</entry>
							<entry>N/A</entry>
						</row>
						<row>
							<entry>rollingPolicy</entry>	
							<entry>rolling이 발생할 때 어떤 작업을 수행할지 결정하는 속성</entry>
							<entry>ch.qos.logback.core.rolling.RollingPolicy</entry>
							<entry>N/A</entry>
						</row>
					</tbody>			
				</tgroup>
			</informaltable>
			
			<para> Logback에서는 다양한 TriggerPolicy와 RollingPolicy 구현체를 제공하고 있다. 다음은 Logback에서 제공하는 주요 Policy에 대한 설명과 그 설정 방법을 기술하였다.</para>
			
			<para>다음은 TimeBasedRollingPolicy를 이용하여 날짜별 로깅을 수행하는 예제이다.
			&lt;file&gt; 태그를 통해 현재 로깅이 수행되는 파일명을 지정할 수 있고, 로깅이 완료된 파일은 fileNamePattern에 패턴에 맞춰서 파일명이 변경된다.
			TimeBasedRollingPolicy의  fileNamePattern에 속성에 설정된 날짜패턴인 %d{yyyy-MM-dd}에 따라 일별로 로그를 남기게 하였고, maxHistory 속성을 설정하여 최근 30개의 로그정보만 남기고 그 이후의 파일은 자동으로 삭제하도록 설정한 예제이다. 
			fileNamePattern속성에 설정 가능한 날짜패턴에 대한 상세한 설명은  <ulink url="http://logback.qos.ch/manual/appenders.html#TimeBasedRollingPolicy">여기</ulink>를  참조한다. </para>
			
			<programlisting language="xml"><![CDATA[    <appender name="dailyRolling" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>currentLog.log</file>]]>
        
        <emphasis role="bold"> &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
             &lt;fileNamePattern&gt;logFile.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;
             &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt; </emphasis>
    	<![CDATA[
        <encoder>
            <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern>
        </encoder>
    </appender>]]></programlisting>
			
			<para>다음은 SizeBasedTriggeringPolicy를 이용하여 5MB 파일크기로 Rolling을 수행하고 FixedWindowRollingPolicy를 이용하여  최근 3개의 로그 파일만 유지하도록 설정한 예제이다. </para>
			
			<programlisting language="xml"><![CDATA[    <appender name="fileSizeRolling" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>currentLog.log</file>]]>
		<emphasis role="bold">
        &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt;
            &lt;fileNamePattern&gt;tests.%i.log.zip&lt;/fileNamePattern&gt;
            &lt;minIndex&gt;1&lt;/minIndex&gt;
            &lt;maxIndex&gt;3&lt;/maxIndex&gt;
        &lt;/rollingPolicy&gt;

        &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt;
            &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt;
        &lt;/triggeringPolicy&gt;</emphasis>
		<![CDATA[    
        <encoder>
            <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern>
        </encoder>
    </appender>]]></programlisting>
		</section>
		
		<section id="logback_logback_configuration_appender_async">
			<title>AsyncAppender</title>
			<para>AsyncAppender는 logback 1.0.4 버전에 새롭게 추가된 appender로 기존의 appender가 로그를 출력할 때 비동기적으로 처리할 수 있는 기능을 추가한다. </para>
			
			<para>AsyncAppender의 주요 속성은 다음과 같다.</para>
			
			<informaltable>
				<caption>AsyncAppender의 주요 속성</caption>
				<tgroup cols="4">
					<colspec colnum="1" colname="col1" colwidth="2*" />
					<colspec colnum="2" colname="col2" colwidth="4*" />
					<colspec colnum="3" colname="col3" colwidth="1*" />
					<colspec colnum="4" colname="col4" colwidth="1*" />
					<thead>
						<row>
							<entry align="center">속성명</entry>
							<entry align="center">기능</entry>
							<entry align="center">타입</entry>
							<entry align="center">기본값</entry>				
						</row>
					</thead>
					<tbody>
						<row>
							<entry>queueSize</entry>	
							<entry>AsyncAppender 로그이벤트를 저장하는 용도로 사용하는 Queue의 크기를 설정하는 속성</entry>
							<entry>int</entry>
							<entry>256</entry>
						</row>
						<row>
							<entry>discardingThreshold</entry>	
							<entry>Queue의 크기중에 비어있는 부분이 discardingThreshold 비율 이하인 경우 INFO 레벨 이하의 로그는 저장하지 않는다. 해당 경계비율을 설정하는 속성 
							       따라서 모든 로그 이벤트를 처리하기 위해서는 해당 속성값을 0으로 설정해야 한다. </entry>
							<entry>int</entry>
							<entry>20</entry>
						</row>
						<row>
							<entry>includeCallerData</entry>	
							<entry>해당 로그 이벤트 정보를 Queue에 추가하는 시점에 로그를 호출한 정보 (callerData)를 추출할지 여부를 결정하는 속성 </entry>
							<entry>boolean</entry>
							<entry>false</entry>
						</row>
					</tbody>			
				</tgroup>
			</informaltable>
			
			<para>다음은 AsyncAppender의 설정 예제이다. AsyncAppender에 실제 로그를 수행할 appender를 appender-ref 속성으로 설정하고, 해당 기능을 사용하기 위한 Logger 에서 AsyncAppender를 참조하도록 설정해야한다.</para>
			<programlisting language="xml"><![CDATA[    <appender name="file" class="ch.qos.logback.core.FileAppender">
        <file>testFile.log</file>
        <encoder>
            <pattern>%-4relative [%thread] %-5level %logger{35} - %msg %n</pattern>
        </encoder>
    </appender>]]>
	<emphasis role="bold">    
    &lt;appender name="asyncFile" class="ch.qos.logback.classic.AsyncAppender"&gt;
        &lt;appender-ref ref="file"/&gt;
    &lt;/appender&gt;</emphasis>
	<![CDATA[	
    <logger name="asyncFileLogger" level="INFO" additivity="false">
        <appender-ref ref="asyncFile" />
    </logger>]]></programlisting>
		</section>
		
		<section id="logback_logback_configuration_appender_db">
			<!-- DBAppender basic -->
			<title>DBAppender</title>
			<para>DBAppender는 로그정보를 DB에 insert하는 역할을 한다. Log4j의 JDBCAppender와는 달리 Logback의 DBAppender는 디폴트로 LOGGING_EVENT, LOGGING_EVENT_PROPERTY, LOGGING_EVENT_EXCEPTION의 3가지 테이블을 기본적으로 필요로 한다. 다음은 각 테이블과 컬럼에 대한 설명이다. 타입은 실제 사용하는 DBMS 환경에 따라 변경될 수 있다.</para>
			
			
			<section id="logback_logback_configuration_appender_db_loggingevent">
				<title>LOGGING_EVENT 테이블</title>
				<para>LOGGING_EVENT 테이블은 로그메시지, timestamp 등 일반적인 로그 이벤트 정보를 저장하는 역할을 하는 테이블이다. 테이블의 각 컬럼은 다음과 같다.</para>
				<informaltable>
				<caption>LOGGING_EVENT 테이블 컬럼</caption>
				<tgroup cols="3">
					<colspec colnum="1" colname="col1" colwidth="2*" />
					<colspec colnum="2" colname="col2" colwidth="1*" />
					<colspec colnum="3" colname="col3" colwidth="5*" />
					<thead>
						<row>
							<entry align="center">컬럼명</entry>
							<entry align="center">타입</entry>
							<entry align="center">기능</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>timestmp</entry>	
							<entry>big int</entry>
							<entry>로그 이벤트 발생시점에 대한 타임스탬프 값</entry>
						</row>
						<row>
							<entry>formatted_message</entry>	
							<entry>text</entry>
							<entry>로깅시점에 전달된 메시지와 파라미터를 이용하여 변환된 메시지</entry>
						</row>
						<row>
							<entry>logger_name</entry>	
							<entry>varchar</entry>
							<entry>로그를 출력할 당시 사용된 Logger의 name</entry>
						</row>
						<row>
							<entry>level_string</entry>	
							<entry>varchar</entry>
							<entry>로그를 출력할 당시 level</entry>
						</row>
						<row>
							<entry>reference_flag</entry>	
							<entry>smallint</entry>
							<entry>reference_flag는 로그 이벤트발생 당시 MDC 혹은 Context 에 저장된 속성이 있어서 LOGGING_EVENT_PROPERTY에 데이터가 저장되는 경우 1의 값을 가지고 
							로그 이벤트에 Exception 객체에 대한 정보가 있어 LOGGING_EXCEPTION에 저정되어야 할 데이터가 있는 경우 2의 값을 가진다. 두가지 데이터가 모두 있는 경우 3의 값을 가진다.  </entry>
						</row>
						<row>
							<entry>caller_filename</entry>	
							<entry>varchar</entry>
							<entry>로그를 호출한 파일명</entry>
						</row>
						<row>
							<entry>caller_class</entry>	
							<entry>varchar</entry>
							<entry>로그를 호출한 클래스명</entry>
						</row>
						<row>
							<entry>caller_method</entry>	
							<entry>varchar</entry>
							<entry>로그를 호출한 메소드명</entry>
						</row>
						<row>
							<entry>caller_line</entry>	
							<entry>char</entry>
							<entry>로그를 호출한 라인번호</entry>
						</row>
						<row>
							<entry>event_id</entry>	
							<entry>int</entry>
							<entry>로그 이벤트에 따른 DB의 고유한 키 값</entry>
						</row>
					</tbody>			
				</tgroup>
			</informaltable>
			</section>
			
			
			<section id="logback_logback_configuration_appender_db_loggingproperty">
				<title>LOGGING_EVENT_PROPERTY 테이블</title>
				<para>LOGGING_EVENT_PROPERTY 테이블은 로깅 이벤트가 발생했을 때 컨텍스트에 저장된 프로퍼티 정보와 MDC에 저장된 정보를 저장하는 용도로 사용되는 테이블이다. 테이블의 각 컬럼은 다음과 같다. </para>
				<informaltable>
					<caption>LOGGING_EVENT_PROPERTY 테이블 컬럼</caption>
					<tgroup cols="3">
					<colspec colnum="1" colname="col1" colwidth="2*" />
					<colspec colnum="2" colname="col2" colwidth="1*" />
					<colspec colnum="3" colname="col3" colwidth="5*" />
					<thead>
						<row>
							<entry align="center">컬럼명</entry>
							<entry align="center">타입</entry>
							<entry align="center">기능</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>event_id</entry>	
							<entry>int</entry>
							<entry>로그 이벤트에 따른 DB의 고유한 키 값</entry>
						</row>
						<row>
							<entry>mapped_key</entry>	
							<entry>varchar</entry>
							<entry>MDC 혹은 context에 저장된 키 값</entry>
						</row>
						<row>
							<entry>mapped_value</entry>	
							<entry>text</entry>
							<entry>MDC 혹은 context에 저장된 키에 해당하는 value</entry>
						</row>
					</tbody>			
					</tgroup>
				</informaltable> 
			</section>
			
			
			<section id="logback_logback_configuration_appender_db_loggingexception">
				<title>LOGGING_EXCEPTION 테이블</title>
				<para>LOGGING_EXCEPTION 테이블은 로깅이벤트가 발생했을 때, 로그메시지와 함께 파라미터로 Exception 객체를 넘겨주는 경우 Exception 정보를 이용하여 stackTrace 정보를 저장하는 테이블이다. 테이블의 각 컬럼은 다음과 같다.</para> 
			
				<informaltable>
					<caption>LOGGING_EXCEPTION 테이블 컬럼</caption>
					<tgroup cols="3">
						<colspec colnum="1" colname="col1" colwidth="2*" />
						<colspec colnum="2" colname="col2" colwidth="1*" />
						<colspec colnum="3" colname="col3" colwidth="4*" />
						<thead>
							<row>
								<entry align="center">컬럼명</entry>
								<entry align="center">타입</entry>
								<entry align="center">기능</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>event_id</entry>	
								<entry>int</entry>
								<entry>로그 이벤트에 따른 DB의 고유한 키 값</entry>
							</row>
							<row>
								<entry>i</entry>	
								<entry>smallint</entry>
								<entry>stack trace에 대한 인덱스 정보</entry>
							</row>
							<row>
								<entry>trace_line</entry>	
								<entry>varchar</entry>
								<entry>해당 stack trace에 대한 메시지</entry>
							</row>
						</tbody>			
					</tgroup>
				</informaltable>
			</section>
				 
			<para>DBAppender의 주요 속성은 다음과 같다.</para>
			<informaltable>
				<caption>DBAppender의 주요 속성</caption>
				<tgroup cols="4">
					<colspec colnum="1" colname="col1" colwidth="2*" />
					<colspec colnum="2" colname="col2" colwidth="4*" />
					<colspec colnum="3" colname="col3" colwidth="1*" />
					<colspec colnum="4" colname="col4" colwidth="1*" />
					<thead>
						<row>
							<entry align="center">속성명</entry>
							<entry align="center">기능</entry>
							<entry align="center">타입</entry>
							<entry align="center">기본값</entry>				
						</row>
					</thead>
					<tbody>
						<row>
							<entry>connectionSource</entry>	
							<entry>DBAppender에서 connection 정보를 얻기 위해서 사용하는 클래스를 지정하는 속성으로 Logback에서는  DriverManagerConnectionSource, connection pool 기능을 이용할 수 있는  DataSourceConnectionSource, JNDI로 부터 DataSource를 이용할 수 있는 JNDIConnectionSource를 지원한다. </entry>
							<entry>ch.qos.logback.core.db.ConnectionSource</entry>
							<entry>N/A</entry>
						</row>
					</tbody>			
				</tgroup>
			</informaltable>
			
			<para> 다음은 Apache Commons DBCP를 이용하여 DBAppender를 설정한 예제이다. db접속정보는 logback-db.properties 파일에 두고, 해당 프로퍼티 파일에 설정된 값을 불러와서 사용하도록 하였다. 
			프로퍼티 파일을 사용하기 위해서는 &lt;property&gt;태그의 file 속성에 프로퍼티 파일의 경로를 명시해 주면된다. 프로퍼티 파일의 경로를 상대경로를 사용한 경우 프로젝트 루트를 기준으로 한 경로를 명시해주면 된다.</para>
			<programlisting language="xml"><emphasis role="bold">    &lt;property file="src/test/resources/logback-db.properties" /&gt; </emphasis>    
    <![CDATA[
    <appender name="dataSourceDB" class="ch.qos.logback.classic.db.DBAppender">]]>
    	
<emphasis role="bold">         &lt;connectionSource class="ch.qos.logback.core.db.DataSourceConnectionSource"&gt;
            &lt;dataSource class="org.apache.commons.dbcp.BasicDataSource"&gt; </emphasis>
<![CDATA[                <driverClassName>${driver}</driverClassName>
                <url>${url}</url>
                <username>${username}</username>
                <password>${password}</password>
            </dataSource>
        </connectionSource>
    </appender>]]></programlisting>
			
			<!-- DBAppender with AsyncAppender -->
			<para>DBAppender는 기본으로 동기적으로 로그를 수행한다. DBAppender와 AsyncAppender를 함께 사용하면 비동기적으로 DB에 로그를 남길 수 있다. 
			</para>
			<programlisting language="xml"><![CDATA[    <appender name="db" class="ch.qos.logback.classic.db.DBAppender">
         ....	
    </appender>
				
    <appender name="asyncDB" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="db"/>]]>
        <emphasis role="bold">&lt;includeCallerData&gt;true&lt;/includeCallerData&gt;</emphasis>
<![CDATA[    </appender>
			
    <logger name="asyncDBLogger" level="DEBUG" additivity="false">
        <appender-ref ref="asyncDB"/>
    </logger>]]></programlisting>
	    
	    <warning>
			<title>주의 사항</title>
			<para>DBAppender와 AsyncAppender를 활용하여 비동기 로깅을 할때 AsyncAppender의 includeCallerData속성을 반드시 true로 설정해야 한다. </para>
		</warning>
	    
	    
	    <para></para>
	    
	    <!-- customizing -->
	    <section>
	    	<title>사용자 정의 컬럼명 사용</title>
	    	<para> Logback에서 제공하는 DBAppender의 경우 미리 정의된 테이블과 컬럼구조를 사용하고 있기 때문에, 사용자 정의 테이블 혹은 sql을 사용하기 위해서는 관련 클래스의 확장이 필요하다.
	    DBAppender에서 사용하는 테이블의 개수와 구조를 동일하게 유지하면서 단순히 컬럼이나 테이블명만을 변경하려고 하는 경우는 DBAppender에서 내부적으로 사용하는 클래스인 DBNameResolver를 새로 구현하는 방법을 고려해 볼 수 있다.
	    Logback에서 제공하는 DBNameResolver 인터페이스를 구현하는 클래스를 개발하고 DB Appender에서 해당 DBNameResolver를 사용하도록 설정할 수 있다. </para>
	    	<para>다음은 MyDBNameResolver라는 사용자 정의 DBNameResolver를 구현하고 설정하는 예제이다.</para>
	     <programlisting language="java"><![CDATA[    public class MyDBNameResolver ]]> <emphasis role="bold">implements DBNameResolver</emphasis><![CDATA[{
	
        private static Map<String, String> columnNameMap = new HashMap<String, String>();
        private static Map<String, String> tableNameMap = new HashMap<String, String>();
	
        static{
             tableNameMap.put("LOGGING_EVENT", "MY_LOGGING_EVENT");
             tableNameMap.put("LOGGING_EVENT_PROPERTY", "MY_LOGGING_EVENT_PROPERTY");
             tableNameMap.put("LOGGING_EVENT_EXCEPTION", "MY_LOGGING_EVENT_EXCEPTION");
        }
	
        public <N extends Enum<?>> String getColumnName(N columnName) {
            return columnNameMap.get(columnName.toString());
        }

        public <N extends Enum<?>> String getTableName(N tableName) {
            return tableNameMap.get(tableName.toString());
        }
	    ......]]></programlisting>
	    
	    <warning>
			<title>주의 사항</title>
			<para>logback 1.0.7 버전까지 사용자 정의 DBNameResolver를 추가하여 컬럼명을  변경할 경우에도 EVENT_ID 라는 컬럼을 변경하면 제대로 동작하지 않을 수 있으므로 주의해야 한다. </para>
		</warning>
	     
	     <para>다음은 사용자 정의 DBNameResolver를 DBAppender에 설정하는 예제이다.</para>
	     <programlisting language="xml"><![CDATA[    <appender name="customDB" class="ch.qos.logback.classic.db.DBAppender">
        <connectionSource class="ch.qos.logback.core.db.DataSourceConnectionSource">
            <dataSource class="org.apache.commons.dbcp.BasicDataSource">
                <driverClass>${driver}</driverClass>
                <url>${url}</url>
                <user>${username}</user>
                <password>${password}</password>
            </dataSource>
        </connectionSource>]]>
		<emphasis role="bold">
        &lt;dbNameResolver class="org.anyframe.logback.appender.db.MyDBNameResolver"/&gt;
        </emphasis>
    <![CDATA[</appender>]]></programlisting>
	    </section> 
		</section>
		
		<section id="logback_logback_configuration_appender_socket">
			<title>SocketAppender</title>
			<para>SocketAppender는 로컬에서 발생한 로그정보를 TCP Socket을 이용하여 remote에 있는 서버로 전송하는 역할을 한다. 
			remoteHost, port 속성을 이용하여 서버의 IP, port를 설정할 수 있다. 
			SocketAppender의 includeCallerData 속성을 true로 하면  클라이언트의 callerData 정보를 포함하여 서버로 전송한다.
			다음은 SocketAppender를 설정하는 예제이다. </para>
			<programlisting language="xml"><![CDATA[    <appender name="socket" class="ch.qos.logback.classic.net.SocketAppender">
        <includeCallerData>true</includeCallerData>
        <port>${serverPort}</port>
        <remoteHost>${remoteHost}</remoteHost>
    </appender>]]></programlisting>
	    	<para>SocketAppender를 사용하는 경우 주의할 점은 SocketAppener의 경우 단순히 LoggingEvent 정보를 직렬화 하여 서버로 전송하는 역할만 수행하므로 layout 혹은 encoder를 설정하지 않아야 한다는 점이다.  </para>	
		
	    	<para>SocketAppender를 테스트 하기 위해서는 서버가 필요하다. 
	    	다음은 SocketAppender를 이용하여 logging 테스트를 수행하기 위한  샘플 서버인 SimpleSocketServer클래스와 SocketNode 클래스의 일부분이다. 
	    	SimpleSocketServer 클래스는 전체 클라이언트와 연결과 SocketNode들을 관리하는 역할을 하고 SocketNode 클래스에서는 하나의 클라이언트가 로그 요청을 전송할때 마다 해당정보를 읽어서 로그를 출력하는 역할을 담당한다.
	    	전체 샘플 서버 코드를 확인하기 위해서는  여기를 참조한다.</para>
	    	
	    	<programlisting language="java"><![CDATA[    public class SimpleSocketServer extends Thread {
        private ServerSocket serverSocket;
        private List<SocketNode> socketNodeList = new ArrayList<SocketNode>();
        private boolean closed = false;
        
        public void run() {
            try {
            serverSocket = new ServerSocket(port);]]>
<emphasis role="bold">            while (!closed) {
                ...
                Socket socket = serverSocket.accept();
                SocketNode newSocketNode = new SocketNode(this, socket, lc); 
                synchronized (socketNodeList) {
                    socketNodeList.add(newSocketNode);
                }
                new Thread(newSocketNode).start();
            }</emphasis>
<![CDATA[        } catch (Exception e) {
            if (closed) {
                logger.info("Exception in run method for a closed server. This is normal.");
            } else {
                logger.error("Unexpected failure in run method", e);
            }
        }
		...
    }]]></programlisting>
	    
	    	<programlisting language="java"><![CDATA[    public class SocketNode implements Runnable {    	
        
        public void run() {
            ILoggingEvent event;
            Logger remoteLogger;

            try {
                while (!closed) {
                	]]>
                   <emphasis role="bold">event = (ILoggingEvent) ois.readObject();
                remoteLogger = context.getLogger(event.getLoggerName());
                if (remoteLogger.isEnabledFor(event.getLevel())) {
                    remoteLogger.callAppenders(event);
                }</emphasis> 
<![CDATA[                   ......
                }    
         }]]></programlisting>	
	    </section>
		
		<section id="logback_logback_configuration_appender_smtp">
			<title>SMTPAppender</title>
			<para>SMTPAppender는 로그요청을 버퍼에 저장하고 특정 이벤트가 발생하면 저장된 로그를 메일로 전송하는 역할을 한다. 메일 전송 시 기본적으로 비동기 방식으로 전송하게 된다. 
			이때 Logback의 SMTPAppender는 버퍼에 저장된 만큼 메일을 전송하는 것이 아니고, 버퍼에 저장된 로그내용을 하나의 본문으로 합쳐서 한건의 메일로 발송하는 특징을 가지고 있다.
			SMTPAppender는 Java Mail 라이브러리를 이용하여 메일을 전송하므로 SMTPAppender를 사용하기 위해서는 java mail 라이브러리(mail-x.x.jar)와  activation(activation-x.x.jar) 라이브러리가 필요하다. </para>
			
			<para>SMTPAppender의 주요속성은 다음과 같다. </para>
			
			<informaltable>
				<caption>SMTPAppender의 주요 속성</caption>
				<tgroup cols="4">
					<colspec colnum="1" colname="col1" colwidth="2*" />
					<colspec colnum="2" colname="col2" colwidth="4*" />
					<colspec colnum="3" colname="col3" colwidth="1*" />
					<colspec colnum="4" colname="col4" colwidth="1*" />
					<thead>
						<row>
							<entry align="center">속성명</entry>
							<entry align="center">기능</entry>
							<entry align="center">타입</entry>
							<entry align="center">기본값</entry>				
						</row>
					</thead>
					<tbody>
						<row>
							<entry>smtpHost</entry>	
							<entry>SMTP 서버의 호스트 명</entry>
							<entry>String</entry>
							<entry>N/A</entry>
						</row>
						<row>
							<entry>smtpPort</entry>	
							<entry>SMTP 서버의 포트</entry>
							<entry>int</entry>
							<entry>25</entry>
						</row>
						<row>
							<entry>to</entry>	
							<entry>메일 수신자 패턴. 한번에 여러명의 수신자를 지정하기 위해서는 콤마로 분리하거나 혹은 to태그를 여러번 반복사용하여 지정가능하다.</entry>
							<entry>String</entry>
							<entry></entry>
						</row>
						<row>
							<entry>from</entry>	
							<entry>메일 송신자</entry>
							<entry>String</entry>
							<entry>N/A</entry>
						</row>
						<row>
							<entry>subject</entry>	
							<entry>메일 전송시 지정할 메일의 제목 패턴. PatternLayout의 형식을 사용할 수 있다.</entry>
							<entry>String</entry>
							<entry>%logger{20} - %m</entry>
						</row>
						<row>
							<entry>discriminator</entry>	
							<entry>로그정보를 어떤 버퍼에 저장할지 결정하는 속성. SMTPAppender에서는 discriminator가 반환하는 키 값에 따라서 로그이벤트 정보를 서로 다른 버퍼에 저장한다.
							기본적으로 DefaultDiscriminator가 설정되어 있고 이 객체는 항상 같은 키 값을 반환하므로 하나의 버퍼에 로그이벤트 정보를 저장한다. </entry>
							<entry>ch.qos.logback.core.sift.Discriminator</entry>
							<entry>ch.qos.logback.core.sift.DefaultDiscriminator</entry>
						</row>
						
						<row>
							<entry>evaluator</entry>	
							<entry>버퍼에 저장된 로그정보를 이용하여 어느 시점 메일을 발송할지 여부를 결정하는 속성. SMTPAppender 에서는 evaluator가 true를 리턴하는 경우 해당 버퍼에 저장된 정보를 이용하여 메일을 발송한다. 
							기본적으로 OnErrorEvaluator가 설정되어 있고 이 객체는 에러로그 발생시 true를 리턴하므로 에러로그 발생시 메일이 발송이 된다.</entry>
							<entry>ch.qos.logback.core.boolex.EventEvaluator</entry>
							<entry>ch.qos.logback.classic.boolex.OnErrorEvaluator</entry>
						</row>
						
						<row>
							<entry>username</entry>	
							<entry>메일서버 인증을 위한 사용자명</entry>
							<entry>String</entry>
							<entry>null</entry>
						</row>
						
						<row>
							<entry>password</entry>	
							<entry>메일서버 인증을 위한 비밀번호</entry>
							<entry>String</entry>
							<entry>null</entry>
						</row>
						
						<row>
							<entry>STARTTLS</entry>	
							<entry>인증시에 STARTTLS 프로토콜을 사용할지를 설정하는 여부</entry>
							<entry>boolean</entry>
							<entry>false</entry>
						</row>
						
						<row>
							<entry>SSL</entry>	
							<entry>인증시에 SSL 프로토콜을 사용할지를 설정하는 여부</entry>
							<entry>boolean</entry>
							<entry>false</entry>
						</row>
						
						<row>
							<entry>asynchronousSending</entry>	
							<entry>비동기 메일전송 여부</entry>
							<entry>boolean</entry>
							<entry>true</entry>
						</row>
						
						<row>
							<entry>charsetEncoding</entry>	
							<entry>메일 전송시 인코딩</entry>
							<entry>String</entry>
							<entry>UTF-8</entry>
						</row>
						
						<row>
							<entry>sessionViaJNDI</entry>	
							<entry>메일 사용할 Session객체를 JNDI로부터 얻어오게 할지 여부</entry>
							<entry>boolean</entry>
							<entry>false</entry>
						</row>
						
						<row>
							<entry>jndiLocation</entry>	
							<entry>JNDI로 객체를 Session을 얻어올때 사용할 location명</entry>
							<entry>String</entry>
							<entry><![CDATA[java:comp/env/mail/Session]]></entry>
						</row>						
					</tbody>			
				</tgroup>
			</informaltable>
			
			<para>다음은 SMTPAppender를 사용한 기본적인 예제이다. SSL속성을 true로 하여 인증시 SSL 프로토콜이 적용되게 설정한 예제이다. </para>
			
			<programlisting language="xml"><![CDATA[    <appender name="email" class="ch.qos.logback.classic.net.SMTPAppender">
        <smtpHost>${smtpHost}</smtpHost>
        <smtpPort>${smtpPort}</smtpPort>
        <SSL>true</SSL>
        <username>${userName}</username>
        <password>${password}</password>
        <to>${to}</to> <!-- additional destinations are possible -->
        <from>${from}</from>

        <subject>TESTING-Email: %logger{20} - %m</subject>
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%date %-5level %logger{35} - %message%n</pattern>
        </layout>
    </appender>]]></programlisting>
	    
	    <para>
			SMTPAppender는 로그 요청이 올때마다 매번 메일을 전송하는 것에 대한 부하가 크기 때문에 기본적으로 버퍼에 저장을 하고 특정 조건이 되면 버퍼에 저장된 내용을 발송한다.
			이렇게 로그 요청을 이용하여 단순히 버퍼에 저장할지 메일을 발송할지 여부를 결정하는 속성이 EventEvaluator이다. 
			기본적으로는 OnErrorEvaluator가 설정되어 있고, OnErrorEvaluator는 에러 이상의 레벨의 로그요청이 오는 경우 메일을 보낸다.
			이 Evaluator 속성을 변경하면 필요한 조건에 메일이 발송되도록 설정할 수 있다.
		</para>
		
		<para>다음은 Logback에서 제공하는 OnMarkerEvaluator를 이용하여 로그 요청에 특정 Marker의 값이 들어오는 경우에 메일을 전송하도록 설정한 예제이다.</para>
		
		<programlisting language="xml"><![CDATA[    <appender name="EMAIL_MARKER_EVALUATOR" class="ch.qos.logback.classic.net.SMTPAppender">
        <smtpHost>${smtpHost}</smtpHost>
        <smtpPort>${smtpPort}</smtpPort>
        <SSL>true</SSL>
        <username>${userName}</username>
        <password>${password}</password>
        <to>${to}</to> <!-- additional destinations are possible -->

        <from>${from}</from>

        <subject>TESTING-ASYNC: %logger{20} - %m</subject>
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%date %-5level %logger{35} - %message%n</pattern>
        </layout>]]>
        <emphasis role="bold">
        &lt;evaluator class="ch.qos.logback.classic.boolex.OnMarkerEvaluator"&gt;
            &lt;marker&gt;NOTIFY_ADMIN&lt;/marker&gt;
            &lt;marker&gt;TRANSACTION_FAILURE&lt;/marker&gt;
        &lt;/evaluator&gt;
        </emphasis>
<![CDATA[    </appender>]]></programlisting>

		<para>해당 설정파일을 이용하여 Marker를 이용한 로그를 남기는 예제는 다음과 같다.</para>
		<programlisting language="java"><![CDATA[    logger.warn("the first buffered message");
    // even the error message will be buffered
    logger.error("the buffered error log message");	
    Marker notifyAdmin = MarkerFactory.getMarker("NOTIFY_ADMIN");
    logger.error(notifyAdmin, "NOTIFY_ADMIN");]]></programlisting>
		
	    <para>
	   	SMTPAppender는 기본적으로 하나의 버퍼를 사용하여 로그이벤트를 처리한다. Discriminator를 이용하면 특정조건에 따라 로그이벤트를 여러개의 버퍼에 저장하게 되고, 따라서 
	   	기준에 따라 분류된 로그내용을 단위로 메일로 전송하는 것이 가능하다. Logback에서는 MDCBasedDiscriminator를 제공하고 이 클래스는 로그이벤트 처리 시 MDC에 저장된 값에 따라서 서로 다른 버퍼를 사용하게 된다. 
	   	</para>
	    
	    <para>다음은 MDCDiscriminator를 이용한  설정 예제이다. MDC에 있는 req.remoteHost 키 값을 이용하여 IP별로 로그 이벤트가 서로 다른 버퍼에 저장되도록 설정하였고, 메일 제목에 MDC에 저장된 값을 출력해주도록 하였다.  </para>
	    
	    <programlisting language="xml"><![CDATA[    <appender name="EMAIL_MDC_DISCRIMINATOR" class="ch.qos.logback.classic.net.SMTPAppender">
        <smtpHost>${smtpHost}</smtpHost>
        <smtpPort>${smtpPort}</smtpPort>
        <SSL>true</SSL>
        <username>${userName}</username>
        <password>${password}</password>
        <to>${to}</to> 
        <from>${from}</from>]]>
		<emphasis role="bold">
        &lt;discriminator class="ch.qos.logback.classic.sift.MDCBasedDiscriminator"&gt;
            &lt;key&gt;req.remoteHost&lt;/key&gt;
            &lt;defaultValue&gt;default&lt;/defaultValue&gt;
        &lt;/discriminator&gt;
        &lt;subject&gt;SMTP-WITH: %X{req.remoteHost} %logger{20} - %m&lt;/subject&gt;
        </emphasis><![CDATA[
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%date %-5level %logger{35} - %message%n</pattern>
        </layout>
    </appender>]]></programlisting>    
		<para> 다음은 MDCDiscriminator를 활용하는 샘플코드이다. 코드에서 직접 MDC에 동일한 키에 대해서 서로 다른값을 세팅하고 Error 로그 요청시 발송되게 처리하였다. 일반적인 웹환경에서는 사용자 요청 정보를 바탕으로 Servlet Filter를 사용하여 해당 Filter에서 필요한 키와 해당되는 값을 MDC에 값을 넣어서 로그를 분리하는 방법을 사용할 수 있다. </para>
		
		<programlisting language="java"><![CDATA[    String ip1 = "127.0.0.1";
    String ip2 = "255.255.255.255";
		
    MDC.put("req.remoteHost", ip1);
    logger.warn("the first message : " + ip1);
		
    //MDC에 저장된 값을 변경 다른 버퍼에 저장될수 있도록 함
    MDC.put("req.remoteHost", ip2);
		
    logger.warn("the first message : " + ip2);
    // 두번째 버퍼에 저장된 로그를 출력
    logger.error("the second message : " + ip2);
    // MDC에 저장된 값을 변경하여 최초에 저장된 버퍼에 로그가 저장되도록 함	
    MDC.put("req.remoteHost", ip1);
		
    // 첫번째 버퍼에 저장된 로그를 출력	
    logger.error("the second message : " + ip1);]]></programlisting>
    
    <para>해당 샘플코드를 실행하여 메일이 정상적으로 전송되면 두 건의 메일이 전송되고, 두 건의 메일내용이 각각  다른 MDC의 값에 분류된 내용이 전송이 된다. 다음은 해당 예제를 이용하여 전송된 메일 중 두번째 버퍼의 내용에 의해 전송된 메일 본문이다.  </para>
	    <programlisting language="java"><![CDATA[    2012-10-04 15:13:03,971 WARN  discriminatorSMTP - the first message : 255.255.255.255
    2012-10-04 15:13:03,971 ERROR discriminatorSMTP - the second message : 255.255.255.255]]></programlisting> 
    <para>다음은 해당 예제를 이용하여 전송된 메일 중 첫번째 버퍼의 내용에 의해 전송된 메일 본문이다.  </para>
	    <programlisting language="java"><![CDATA[    2012-10-04 15:13:03,970 WARN  discriminatorSMTP - the first message : 127.0.0.1
    2012-10-04 15:13:03,971 ERROR discriminatorSMTP - the second message : 127.0.0.1]]></programlisting> 
	</section>
		
		<section id="logback_logback_configuration_appender_syslog">
			<title>SyslogAppender</title>
			<para>SyslogAppender의 경우 logging request를 Unix/Linux의 Syslog demon으로 전송하는 역할을 담당한다. 
			SyslogAppender는 Syslog 프로토콜로 로그정보를 전송하는 역할을 하므로 SocketAppender 와 유사하게 별도의 Layout은 설정하지 않고 메시지는 포맷을 처리하기 위해서 suffixPattern을 사용한다. </para>
			<para>SyslogAppender의 주요 속성은 다음과 같다.</para>
			<informaltable>
				<caption>SyslogAppender의 주요 속성</caption>
				<tgroup cols="4">
					<colspec colnum="1" colname="col1" colwidth="2*" />
					<colspec colnum="2" colname="col2" colwidth="4*" />
					<colspec colnum="3" colname="col3" colwidth="1*" />
					<colspec colnum="4" colname="col4" colwidth="1*" />
					<thead>
						<row>
							<entry align="center">속성명</entry>
							<entry align="center">기능</entry>
							<entry align="center">타입</entry>
							<entry align="center">기본값</entry>				
						</row>
					</thead>
					<tbody>
						<row>
							<entry>syslogHost</entry>	
							<entry>syslog 서버 호스트</entry>
							<entry>String</entry>
							<entry>N/A</entry>
						</row>
						<row>
							<entry>port</entry>	
							<entry>syslog 서버 포트</entry>
							<entry>int</entry>
							<entry>514</entry>
						</row>
						<row>
							<entry>facility</entry>	
							<entry>메시지 소스를 식별하기 위한 식별자 KERN, USER, MAIL, DAEMON, AUTH, SYSLOG, LPR, NEWS, UUCP, CRON, AUTHPRIV, FTP, NTP, AUDIT, ALERT, CLOCK, LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7 중의 하나로 설정해야 한다.</entry>
							<entry>String</entry>
							<entry></entry>
						</row>
						<row>
							<entry>suffixPattern</entry>	
							<entry>syslog 서버로 전송될 메시지 포맷</entry>
							<entry>String</entry>
							<entry>[%thread] %logger %msg</entry>
						</row>
						<row>
							<entry>throwableExcluded</entry>	
							<entry>Syslog 서버로 데이터 전송시 stack trace 데이터를 제외할지 여부 </entry>
							<entry>boolean</entry>
							<entry>false</entry>
						</row>
					</tbody>			
				</tgroup>
			</informaltable>
			
			<para>다음은 SyslogAppender를 설정하는 예제이다.</para>
			<programlisting language="xml"><![CDATA[    <appender name="syslog" class="ch.qos.logback.classic.net.SyslogAppender">
        <syslogHost>${syslogHost}</syslogHost>
        <port>${port}</port>
        <facility>KERN</facility>
        <suffixPattern>[%thread] %logger %msg</suffixPattern>
    </appender>]]></programlisting>
			<para> 
			SyslogAppender를 사용할 때 일반적으로 서버의 Syslog 데몬 설정은 디폴트로 remote의 log request를 처리하지  않도록 설정되어 있기 때문에 해당 설정을 변경해주어야 한다.
			</para>
		</section>
		
		<section id="logback_logback_configuration_appender_jms">
			<title>JMSQueue/JMSTopicAppender</title>
			<para>JMSQueue/JMSTopicAppender는  JMS(JAVA Messaging Service)를 이용하여  로그메시지를 전송하는 역할을 담당한다. 
			logback에서 제공하는 JMSAppender의 경우 내부적으로 Apache ActiveMQ를 이용하고 있기 때문에 해당 Appender를 사용하기 위해서는 ActiveMQ 라이브러리를 추가해야 한다. 
			ActiveMQ 라이브러리 추가 시 주의할 점은 ActiveMQ 5.5 버전 부터 JDK 1.6 이상을 필요로 하기때문에 JDK 1.5를 사용하는 환경에서는 해당 버전보다 이전의 라이브러리를 사용해야 한다.
			또한 JNDI를 사용하여 해당 Session과 Connection 객체 생성시에 사용하므로 클래스패스에 jndi.properties 파일이 필요하다.
			</para>
			<para>다음은 JMSTopicAppender를 설정하는 예제이다. JMSQueueAppender는 전체적으로  JMSTopicAppender와 설정이 유사하고 일부 속성명 TopicConnectionFactoryBindingName을 QueueConnectionFactoryBindingName로 
				 TopicBindingName을 QueueBindingName으로 변경하면 사용가능하다. 
			</para>
			<programlisting language="xml"><![CDATA[    <appender name="Topic" class="ch.qos.logback.classic.net.JMSTopicAppender">
        <InitialContextFactoryName>
        org.apache.activemq.jndi.ActiveMQInitialContextFactory
        </InitialContextFactoryName>
        <ProviderURL>${providerURL}</ProviderURL>
        <TopicConnectionFactoryBindingName>
           ConnectionFactory
        </TopicConnectionFactoryBindingName>
        <TopicBindingName>MyTopic</TopicBindingName>
    </appender>]]></programlisting>
		</section>
		
		<section id="logback_logback_configuration_appender_sifting">
			<title>SiftingAppender</title>
			<para>
			Logback에서는 특정 런타임 기준에 따라 Appender를 분리하여 로깅을 수행할 수 있는 SiftingAppender를 제공한다.
			SiftingAppender는 기본적으로 MDC에 있는 값에 따라서 실제 사용하는 appender를 구분한다.
			appender가 서로 구분되어 생성되기 위해서는 서로 다른 name 속성을 가져야 하고 그렇게 하기 위해 일반적으로 MDC에 있는 값을 이용하여 이름을 설정한다. 
			일반적으로 SiftingAppender를 이용하는 경우는 FileAppender 혹은 RollingFileAppender를 이용하게 되는데 이때 파일이 생성되는 경로나 파일명도 appender 별로 구분될 수 있도록 설정한다.
			</para>
			
			<para>다음은 SiftingAppender를 이용하여 MDC에 설정된 값에 따라 따라 서로 다른 파일에 로그를 남기게 한 예제이다.</para>
			<programlisting language="xml"><![CDATA[    <appender name="sift" class="ch.qos.logback.classic.sift.SiftingAppender">
        <discriminator>
            <key>mdcKey</key>
            <defaultValue>defaultValue</defaultValue>
        </discriminator>
        <sift>
            <appender]]> <emphasis role="bold">name="${mdcKey}_appender" </emphasis><![CDATA[ class="ch.qos.logback.core.FileAppender">
                <file>]]><emphasis role="bold">${mdcKey}.log</emphasis><![CDATA[</file>
                ...
            </appender>
            ...
        </sift>
    </appender>]]></programlisting> 
      	
	</section>
	</section>
	
	<section id="logback_logback_configuration_logger">
		<title>Logger</title>
		<para>Logger는 appender와 encoder를 이용하여 로깅을 수행하는 역할을 담당한다. 어플리케이션에서 Logger 객체를 검색할때 이름 규칙에 따라 가장 유사한 Logger 객체를 반환한다.
		이때 일치되는 조건이 없는 경우 Root Logger를 반환한다.</para>
		
		<para>Logger의 주요 속성은 다음과 같다.</para>
		<informaltable>
			<caption>Logger의 주요 속성</caption>
				<tgroup cols="4">
					<colspec colnum="1" colname="col1" colwidth="1*" />
					<colspec colnum="2" colname="col2" colwidth="6*" />
					<colspec colnum="3" colname="col3" colwidth="1*" />
					<colspec colnum="4" colname="col4" colwidth="1*" />
					<thead>
						<row>
							<entry align="center">속성명</entry>
							<entry align="center">기능</entry>
							<entry align="center">타입</entry>
							<entry align="center">기본값</entry>				
						</row>
					</thead>
					<tbody>
						<row>
							<entry>name</entry>	
							<entry>해당 Logger의 고유한 식별자. Root Logger는 이름을 별도로 설정하지 않는다.</entry>
							<entry>String</entry>
							<entry>N/A</entry>
						</row>
						<row>
							<entry>level</entry>	
							<entry>해당 Logger에 대한 로그 요청을 출력할지 여부를 결정하는 기준속성. 레벨은 TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR 이고 OFF로 설정하는 경우 모든 로그요청은 처리되지 않는다. </entry>
							<entry>ch.qos.logback.classic.Level</entry>
							<entry>N/A</entry>
						</row>
						<row>
							<entry>additivity</entry>	
							<entry>해당 Logger의 상위 Logger에게 로그 이벤트를 전달할지 여부를 결정하는 속성</entry>
							<entry>boolean</entry>
							<entry>true</entry>
						</row>
					</tbody>			
				</tgroup>
			</informaltable>
			
			<para>다음은 logger 와 Root를 설정하는 예제이다. 하나의 logger에 다중의 appender-ref를 설정할 수 있다.</para>
			
			<programlisting language="xml"> <![CDATA[    <logger name="myLogger" level="DEBUG" additivity="false">
        <appender-ref ref="console" />
        <appender-ref ref="file" />
    </logger>

    <root level="DEBUG">
        <appender-ref ref="console"/>
    </root>]]></programlisting>
	</section>
	
	<section id="logback_logback_configuration_encoder">
		<title>Encoder</title>
		<para>
		Encoder는 Layout과 pattern을 이용하여 로그이벤트 정보를 사용자가 설정한 형식에 맞춰서 변환하는 역할을 담당한다. encoder 설정 시에 클래스 속성을 설정하지 않는 경우 디폴트로 ch.qos.logback.classic.encoder.PatternLayoutEncoder가 사용된다.
		</para>
		
		<para>다음은 encoder와 pattern을 사용하는 예제이다. 특별한 설정을 하지 않았기때문에 PatternLayoutEncoder가 사용된다. pattern 속성 설정시에는 %가 escape 문자로 사용된다. 샘플에 사용된 패턴은  %d로 현재 일시,  %-5level 로그이벤트 요청시 레벨을 5글자 넓이로, %thread는 현재 쓰레드의 이름, %logger는 사용된 Logger의 풀네임과 로그 요청시 사용된 메시지를 출력하는 패턴을 지정하였다.
		 </para>
		
		<programlisting language="xml"><![CDATA[    <appender name="FILE" class="ch.qos.logback.core.FileAppender"> 
        <file>foo.log</file>
        <encoder>
            <pattern>%d %-5level [%thread] %logger: %msg%n</pattern>
        </encoder> 
    </appender>]]></programlisting>
		<para>pattern에 지정하는 키워드에 대한 자세한 설명은 <ulink url="http://logback.qos.ch/manual/layouts.html#ClassicPatternLayout">여기</ulink>를 참조한다.</para>
	</section>
	
	<section id="logback_logback_configuration_listener">
		<title>StatusListener</title>
		<para>Logback에서는 Logback 자체에서 발생하는 이벤트를 처리할 수 있도록 StatusListener 인터페이스를 제공한다. 
			    해당 구현체로는 이벤트가 발생할때마다 상태 메시지를 콘솔로 출력해주는 OnConsoleStatusListener가 있다.
			    리스너를 사용하기 위해서는 설정파일에 해당 리스너를 등록해야 한다.
		</para>
		
		<!-- Exception Handling -->
		<para> Logback에서는 로그를 수행하다가 발생하는 모든 Exception을 throw하지 않고 내부적으로 Error Status 객체를 생성하여 해당 정보를 담아서 기록한다.
		따라서 로그를 남기는 중에 발생한 Exception을 처리하기 위해서는 Listener를 이용하면 일관된 방법으로  Exception을 처리할 수 있다. 
		</para>
		
		<para>다음은 Listener를 구현하여 Logback에서 발생하는 Exception을 처리하기 위한 예제이다.</para>
		
		<programlisting language="java"> <![CDATA[    public class OnErrorStatusListener extends ContextAwareBase implements StatusListener, LifeCycle {
	
    private boolean isStarted = false;
	
    public void addStatusEvent(Status status) {
        if (!isStarted()){
            return;
        }
		
        if (status.getLevel() == Status.ERROR){
            // 에러 처리
            ....
        }
    }
	
    public boolean isStarted() {
        return isStarted;
    }

    public void start() {
        isStarted = true;
    }

    public void stop() {
        isStarted = false;
    }
}		 ]]></programlisting>

		<para>다음은 구현한 Listener를 설정파일에 등록하는 예제이다.</para>
		<programlisting language="xml"> <![CDATA[<statusListener class="org.anyframe.logback.appender.db.OnErrorStatusListener" />]]></programlisting>	
	</section>
	
	<section id="logback_logback_configuration_filter">
		<title>Filter</title>
		<para>Filter는  단순히 logger에 설정하는 level뿐 아니라 다양한 조건으로 로그 이벤트의 처리여부를 결정할 수 있다. 
		필터는 기본적으로 해당 로그 이벤트 처리여부를 결정하는 decide() 메소드를 가지고, 해당 메소드에서는 FilterReply를 enumeration을 리턴하는데 DENY, NEUTRAL, ACCEPT가 있다.
		해당 필터가 DENY를 리턴하는 경우 해당 로그 이벤트는 처리가 중단되고, NEUTRAL인 경우 다음 필터가 존재하는 경우 다음 필터에서 처리여부를 결정하게 된다. ACCEPT가 리턴되는 경우 해당 로그 이벤트는 다음 필터에 관계 없이 처리되게 된다. 
		이러한 필터는 선언되어 있는 위치에 따라 전역적으로 사용되는 TurboFilter와 특정 Appender내에 존재하는 RegularFilter로 구분된다. </para>
				
		<section id="logback_logback_configuration_filter_regular">
			<title>RegularFilter</title>
			<para>RegularFilter는 특정 Appender의 내부에서 선언되어 Appender의 로그수행여부를 결정한다.
			</para>
			
			<para>다음은 EvaluatorFilter와 JaninoEventEvaluator를 이용하여 SMTPAppender를 사용할때 MDC의 IP가 127.0.0.1인 경우는 로그를 남기지 않도록 한 설정파일 이다.</para>
			<programlisting language="xml"><![CDATA[    <appender name="EMAIL_FILTER" class="ch.qos.logback.classic.net.SMTPAppender">	
		]]><emphasis role="bold">
        &lt;filter class="ch.qos.logback.core.filter.EvaluatorFilter"&gt;
            &lt;evaluator&gt;
                &lt;expression&gt;return mdc.get("req.remoteHost") != null
                          &amp;&amp; "127.0.0.1".equals(mdc.get("req.remoteHost")); &lt;/expression&gt;
            &lt;/evaluator&gt;
            &lt;OnMismatch&gt;NEUTRAL&lt;/OnMismatch&gt;
            &lt;OnMatch&gt;DENY&lt;/OnMatch&gt;
        &lt;/filter&gt;
        </emphasis>		
        <![CDATA[        <smtpHost>${smtpHost}</smtpHost>
        <smtpPort>${smtpPort}</smtpPort>
        <SSL>true</SSL>
        <username>${userName}</username>
        <password>${password}</password>
        <to>${to}</to>
        <from>${from}</from>
        <subject>SMTP-WITH: %logger{20} - %m</subject>
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%date %-5level %logger{35} - %message%n</pattern>
        </layout>
    </appender>]]></programlisting>
		</section>
		
        <section id="logback_logback_configuration_filter_turbo">
			<title>TurboFilter</title>
			<para> TurboFilter는 기본적으로  RegularFilter와 기능적으로는 유사하지만 Context 전역적으로 선언되기때문에 모든 로그 이벤트 요청에 필터가 적용된다는 특징을 가지고 있다.
			Logback은 로그요청을 처리하는 가장 처음 단계로 TurboFilter를 적용한다. 반면에 Regular필터는 로그이벤트 객체를 생성하고 Logger 레벨을 확인하는 추가적인 과정을 거치기 때문에
			전역적으로 필터링을 해야할 조건이 있는 경우 TurboFilter를 사용하면 성능상  이점을 얻을 수 있다.
			단, TurboFilter를 사용할 때 주의점은 TurboFilter가 Accept를 리턴하는 경우 사용하려는 Logger의 레벨에 관계없이 해당 로그 이벤트가 처리된다는 특징이 있다는 점이다.</para>
			
			<para>다음은 TurboFilter의 예제이다. MarkerFilter를 활용하여 billing Marker가 있는 경우 해당 로그 요청을 필터링 하도록 설정하였다.</para>
			
			<programlisting language="xml"><![CDATA[    <turboFilter class="ch.qos.logback.classic.turbo.MarkerFilter">
        <Marker>billing</Marker>
        <OnMatch>DENY</OnMatch>
    </turboFilter>]]></programlisting>
		</section>
	</section>
	
	<section id="logback_logback_configuration_mdc">
		<title>MDC(Mapped Diagnostic Context)</title>
		<para>Request 또는 사용자별로 특정한 정보를 로그로 남기기 위해서 사용할 수 있는것이 MDC이다. 
		MDC는 Mapped Diagnostic Context의 약자로 쓰레드 별로 존재하는 Map과 유사한 객체이다. 
		하나의 request를 처리하기 위해서 thread를 사용하므로 이 MDC를 이용함으로써 사용자정보를 남길 수 있고 Logback은 MDC를 이용한 다양한 기능을 제공한다.
		일반적인 web 환경의 경우 ServletFilter를 이용하여 해당 MDC의 정보를 관리하면 좀더 손쉽게 해당정보를 관리할 수 있다. 
		</para>
		
		<para>
		다음은 Logback Plugin 설치시 추가되는  MDCServletFilter 클래스이다. 
		요청처리 전 request와 session 정보를 이용하여 필요한 정보를 MDC에 넣고 요청이 처리가 완료되면 MDC의 값을 clear 한다. 
		<programlisting language="java"><![CDATA[    public class MDCServletFilter implements Filter{
	
	        public void doFilter(ServletRequest request, ServletResponse response,
	            FilterChain chain) throws IOException, ServletException {
	            ]]><emphasis role="bold">insertIntoMDC(request)</emphasis><![CDATA[;
	            try{
	                chain.doFilter(request, response); 
	            }finally{
	                ]]><emphasis role="bold">clearMDC()</emphasis><![CDATA[;
	            }	
	        }	
			
	        private void insertIntoMDC(ServletRequest request){
	            MDC.put(REMOTE_HOST_MDC_KEY, request.getRemoteHost());
			
	            if (request instanceof HttpServletRequest){
	                HttpServletRequest httpServletRequest = (HttpServletRequest) request;
				
	                StringBuffer requestURL = httpServletRequest.getRequestURL();
	                if (requestURL != null) {
	                    MDC.put(REQUEST_URL_MDC_KEY, requestURL.toString());
			    	}
	                HttpSession session = httpServletRequest.getSession();
			    
	                if (session != null && session.getAttribute(USER_ID_MDC_KEY) != null){
	                    MDC.put(USER_ID_MDC_KEY, (String)session.getAttribute(USER_ID_MDC_KEY));
	                }
			    
	            }		
	        }
	    ...]]></programlisting>
		<emphasis role="bold">
	      주의할 점은 필터를 이용하여 MDC에 기록한 값은 처리가 request 처리가 끝난 후 반드시 clear를 해줘야 한다는 점이다.
		</emphasis>
		</para>
		
		<para>
		MDCServletFilter를 구현한 후 web.xml에 등록해주어야 한다.
		<programlisting language="xml"><![CDATA[    <filter>
        <filter-name>mdcServletFilter</filter-name>
        <filter-class>....logback.filter.MDCServletFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>mdcServletFilter</filter-name>
        <url-pattern>*.do</url-pattern>
    </filter-mapping>]]></programlisting> 	
		</para>
	</section>
	
	
</chapter>
