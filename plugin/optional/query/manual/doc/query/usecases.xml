<chapter id="query_usecases">
	<title>Usecases</title>
	<para>
		이 페이지를 통하여 다양한 Query Service 사용 방법에 대해 소개하고자 한다. 상세한 내용을 알고자 한다면, 아래 나열된 
		각각의 Use Case를 참고하도록 한다.
		(이 페이지에서는 org.anyframe.query.impl.config.loader.MappingXMLLoader를 이용하여 XML 형태의 파일에 매핑 정보가 정의되어 
		있는 경우에 대해 다루기로 한다.)
	</para>

	<section id="query_usecases_resultmapping">
		<title>Result Mapping</title>

		<para>
			다음은 Query Service를 통해 목록 조회를 수행한 이후 조회 결과를 특정 객체에 매핑하기 위한 방법들이다.
		</para>

		<section id="query_usecases_resultmapping_case1">
			<title>조회 결과 매핑이 별도로 정의되어 있지 않은 경우</title>

			<para>
				조회 결과 매핑을 위해 <![CDATA[<table-mapping/>]]>, <![CDATA[<result-mapping/>]]>을
				별도로 정의하지 않은 경우, 쿼리문 수행 결과는 각 결과 Row 별로 Map에 담아 ArrayList 형태로 리턴된다. 
				조회 결과값을 추출하기 위해서는 각 Map으로부터 get("칼럼명")을 통해 해당 칼럼의 값을 얻어낼 수 있다.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="selectGeneral" isDynamic="false">
            <statement>
                SELECT * FROM TBL_CUSTOMER WHERE SSNO like ?
            </statement>
            <param type="VARCHAR" />
        </query>
    </queries>
</queryservice>]]></programlisting>
			</para>	
		</section>

		<section id="query_usecases_resultmapping_case2">
			<title><![CDATA[<result-mapping>]]> 없이 <![CDATA[<table-mapping>]]>을 이용할 경우</title>					

			<para>
				특정 클래스와 단일 테이블 사이의 매핑 정보를 정의할 때 사용하며, 테이블과 특정 클래스 간의 매핑 정보를 정의해 두면 
				특정 조회문의 조회 결과를 매핑할 때 별도의 <![CDATA[<result-mapping>]]>없이 해당 클래스명만 <![CDATA[<result>]]>에 
				정의해 두면 되므로 	XML 정의가 보다 간단해질 수 있다. 또한 <![CDATA[<table-mapping>]]>을 이용하면 별도 쿼리문 정의없이 
				객체만으로도 단건 데이터 생성/수정/삭제/조회가 가능해진다. <![CDATA[<result class=""org.anyframe.sample.domain.Customer"/>]]>와
				같이 table mapping시 정의한 클래스를 이용하면 쿼리문 수행 결과는 해당 클래스의 setter 호출을 통해 저장되고, getter를 
				호출함으로써 결과값을 얻을 수 있게 된다.
				<programlisting language="xml"><![CDATA[<queryservice>
    <table-mapping>
        <table name="TBL_CUSTOMER"
            ]]><emphasis role="bold">class="org.anyframe.sample.domain.Customer"</emphasis><![CDATA[>
            <field-mapping>
                <dbms-column>ssno</dbms-column>
                <class-attribute>ssno</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>name</dbms-column>
                <class-attribute>nm</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>address</dbms-column>
                <class-attribute>addr</class-attribute>
            </field-mapping>
            <primary-key>
                <dbms-column>ssno</dbms-column>
            </primary-key>
        </table>
    </table-mapping>    
    <queries>
        <query id="select" isDynamic="false">
            <statement>
                SELECT * FROM TBL_CUSTOMER WHERE SSNO like ?
            </statement>
            <param type="VARCHAR" />
            <]]><emphasis role="bold">result class="org.anyframe.sample.domain.Customer"</emphasis><![CDATA[/>
        </query>
    </queries>
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_resultmapping_case3">
			<title><![CDATA[<table-mapping>]]>,<![CDATA[<result-mapping>]]>없이 <![CDATA[<result>]]>만을 이용할 경우</title>	

			<para>
				매핑 대상 클래스의 속성명이 조회 칼럼명과 동일하거나 CamelCase된 형태이어서, <![CDATA[<table-mapping>]]>나 
				<![CDATA[<result-mapping>]]>를 통해 별도 매핑을 수행하지 않아도 되는 경우에 사용할 수 있다. 
				즉, isCamelCase, mappingStyle 속성값에 따라 조회된 칼럼명과 매핑되는 클래스의 속성명을 찾는다. (예를 들어,
				mappingStyle의 속성값이 'camel'이고 조회 칼럼명이 USER_NAME인 경우 매핑되는 속성명은 userName이 된다.))
		       </para>

			<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="getUser" isDynamic="false">
            <statement>
                SELECT USER_ID, USER_NAME, PASSWORD, SSN, SL_YN, 
                    BIRTH_DAY, AGE, CELL_PHONE, ADDR, EMAIL, EMAIL_YN, 
                    IMAGE_FILE, REG_DATE
                FROM USERS
                WHERE USER_ID = ?
            </statement>
            <param type="VARCHAR" />
            <]]><emphasis role="bold">result class="org.anyframe.sample.domain.User"/</emphasis><![CDATA[>
        </query>
    </queries>
</queryservice>]]></programlisting>	   

			<para>
				* Query 서비스는 내부적으로 쿼리문 수행으로 얻어진 조회 결과를 매핑할 때 다음과 같은 순서로 매핑 기준을 찾는다.
			</para>

			<orderedlist>
				<listitem>
					<para>
						정의된 <![CDATA[<result-mapping>]]> 정보가 있으면 이를 기반으로 매핑
					</para>
				</listitem>
				<listitem>
					<para>
						정의된 <![CDATA[<result>]]> 클래스에 대한 <![CDATA[<table-mapping>]]> 정보가 있으면 이를 기반으로 매핑
					</para>
				</listitem>
				<listitem>
					<para>
						정의된 <![CDATA[<result>]]> 클래스에 대한 정보가 있으면 이를 기반으로 매핑
					</para>
				</listitem>
				<listitem>
					<para>
						HashMap에 mappingStyle, isCamelCase 속성값을 기반으로 매핑
					</para>
				</listitem>
			</orderedlist>
		</section>

		<section id="query_usecases_resultmapping_case4">
			<title><![CDATA[<result-mapping>]]>을 이용할 경우</title>

			<para>
				<![CDATA[<result-mapping>]]>은 <![CDATA[<table-mapping>]]>에 정의되지 않은 클래스이면서,
				조회된 칼럼명과 매핑 클래스의 속성명이 연관성이 없어 별도 매핑이 필요한 경우 사용한다. <![CDATA[<result-mapping>]]>에 
				해당 column과 attribute를 일대일로 매핑한다. 	<![CDATA[<result>]]>에 정의된 클래스의 setter 호출을 통해 저장되고, 
				getter 호출을 통해 결과값을 얻을 수 있다.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="selectUsingResultMapping" isDynamic="false">
            <statement>SELECT * FROM TBL_CUSTOMER WHERE SSNO like ?</statement>
            <param type="VARCHAR"/>
            <]]><emphasis role="bold">result class="org.anyframe.sample.domain.CompositionCustomer"</emphasis><![CDATA[>
                <]]><emphasis role="bold">result-mapping column="NAME" attribute="nm"/</emphasis><![CDATA[>
                <]]><emphasis role="bold">result-mapping column="ADDRESS" attribute="addr"/</emphasis><![CDATA[>
            </result>
        </query>
    </queries>
</queryservice>]]></programlisting>
			</para>
		</section>

		<warning>
			<title>Result Mapping 시 유의사항</title>
			<para>
				<itemizedlist>
					<listitem>
						<para>
							SELECT 문을 통해 조회된 칼럼 중 <![CDATA[<result-mapping>]]>을 통해 매핑하지 않은
							경우에는 기본적으로 mappingStyle을 이용하여, 매핑 처리를 수행한다. 만약 정의된 Result
							클래스 내에 mappingStyle에 맞는 속성명이 존재하지 않으면 매핑은 수행되지 않을 것이다.</para>
						<para>즉, <![CDATA[<result-mapping>]]>을 통하여 선언된 매핑규칙은 mappingStyle에 의한 것보다 우선한다.</para>
					</listitem>
					<listitem>
						<para>
							Result 클래스가 내부에 다른 User Defined Object를 포함하고 있는 Composite
							Object인 경우에는 column/attribute 사이의 매핑 정보를 정의할 때, {} 내에 ,를 구분자로 하여
							정의할 수 있다. 단, attribute 정의시 반드시 내부 Object의 변수명을 그대로 사용해야
							한다. 
						</para>
						<para>Composite Object에 대한 맵핑은 <![CDATA[<result-mapping>]]>을 통해서만 맵핑할 수 있으며, 
						mappingStyle에 대한 기본 매핑은 Composite Object에는 해당되지 않는다</para>
						<programlisting language="xml"><![CDATA[<query id="findWithCompositeResultMapping">
    <statement>
        select grp.GROUP_ID, grp.GROUP_NAME, cd.CODE_ID, cd.CODE_NAME,
               cd.CODE_DESC, cd.CODE_USE_YN
        from TB_CODE_GROUP grp, TB_CODE cd
        where grp.GROUP_ID = cd.GROUP_ID and cd.GROUP_ID = :groupId 
    </statement>
    <result class="org.anyframe.core.query.vo.LocalResultMappingVO">
        <result-mapping column="{ GROUP_ID, GROUP_NAME }"
                attribute="{ group.groupId, group.codeNm }" />
        <result-mapping attribute="codeID" column="CODE_ID" />
        <result-mapping attribute="codeDescription" column="CODE_DESC" />
    </result>
</query>]]></programlisting>
						<para>
							위에서 정의한 쿼리 정의에 의해 'findWithCompositeResultMapping'의 수행 결과는 LocalResultMappingVO 객체에 담겨져 전달될  
							것이다. 이 때, GROUP_ID, GROUP_NAME 칼럼값은 LocalResultMappingVO 내의 group이라는 이름의 변수에 해당하는 객체의
							groupId, codeNm에 각각 매핑된다. 따라서 전달된 LocalResultMappingVO로부터 GROUP_ID, GROUP_NAME 값을 추출하기 위해서는 
							LocalResultMappingVO.getGroup().getGroupId(),LocalResultMappingVO.getGroup().getCodeNm()을 호출하면 된다.
						</para>
						<para>
						 	다음은 CodeVO라는 객체를 포함하고 있는 LocalResultMappingVO라는 객체의 일부이다.
						</para>
							<programlisting language="java">public class LocalResultMappingVO implements Serializable {
    private String groupID;
    private String groupName;
    private String codeID;
    private String codeName;
    private String codeDescription;
    private String codeUseYn;
    <emphasis role="bold">private CodeVO group;</emphasis>

    // getter, setter...
}</programlisting>
					</listitem>
				</itemizedlist>
			</para>
		</warning>

		<section id="query_usecases_resultmapping_case5">
			<title>테스트 코드 Sample</title>

			<para>
				다음은 앞서 제시한 매핑 XML 파일에 정의된 쿼리문을 실행하는 테스트 코드의 
				일부이다.
				<programlisting language="java">/**
 * Query 서비스를 통해 DB에 입력된 데이터를 조회하는 테스트 코드
 */
public void selectCustomer() {
    QueryService queryService = (QueryService) context.getBean("queryService");

    //find() : 매핑 XML 파일에 정의되어 있는 query id를 이용하여 SELECT를 실행한다.

    //별도 Result Mapping을 정의하지 않은 경우
    <![CDATA[List<Map<String, Object>> rsquery]]> = <emphasis role="bold">queryService
                                 .find("selectGeneral", new Object[] { "%12345%" });</emphasis>
    <![CDATA[Map<String, Object> hsRsquery = new HashMap<String, Object>();]]>
    <![CDATA[for( int i = 0 ; i < rsquery.size() ; i ++ ){]]>
        <emphasis role="bold">hsRsquery = rsquery.get(i);</emphasis>
        String name = (String) hsRsquery.get("name");
    }

    // table-mapping을 정의한 경우
    <![CDATA[List<Customer> rsqueryUsingTableMapping]]> = queryService.find(
            "selectUsingTableMapping", new Object[] { "%12345%" });
    <![CDATA[Iterator<Customer> rsqueryItr]]> = rsqueryUsingTableMapping.iterator();
    while (rsqueryItr.hasNext()) {
        <emphasis role="bold">Customer customer = rsqueryItr.next();</emphasis>
        String name = customer.getNm();
    }

    // result-mapping을 정의한 경우
    <![CDATA[List<CompositionCustomer> rsqueryUsingResultMapping]]> = <emphasis role="bold">queryService.find("selectUsingResultMapping"
            , new Object[] { "%12345%" });</emphasis>
    <![CDATA[Iterator<CompositionCustomer> rsqueryItr_01]]> = rsqueryUsingResultMapping.iterator();
    while (rsqueryItr_01.hasNext()) {
        <emphasis role="bold">CompositionCustomer compositionCustomer = rsqueryItr_01.next();</emphasis>
        String name =  compositionCustomer.getCompositionName();
    }

    // result class만 정의한 경우
    <![CDATA[List<CamelCasedCustomer> rsqueryUsingOnlyResultClass]]> = <emphasis role="bold">queryService.find(
            "selectUsingOnlyResultClass", new Object[] { "%12345%" });</emphasis>
    <![CDATA[Iterator<CamelCasedCustomer> rsqueryItr_02]]> = rsqueryUsingOnlyResultClass.iterator();
    while (rsqueryItr_02.hasNext()) {
        <emphasis role="bold">CamelCasedCustomer camelCasedCustomer = rsqueryItr_02.next();</emphasis>
        String name = camelCasedCustomer.getName();
    }
}</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_embeddedsql">
		<title>Embedded SQL</title>

		<para>
			다음은 Embedded SQL을 사용하는 경우로, 매핑 XML 파일에 별도로 쿼리문을 정의해 두지 않고도 특정
			쿼리문을 소스 코드 내에 직접 입력하여 실행할 수 있다.
		</para>

		<section id="query_usecases_embeddedsql_attribute">
			<title>속성 정의 파일 Sample</title>

			<para>
				다음은 Query 서비스를 정의한 context-query.xml 파일의 일부이다.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    중략...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean> ]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_embeddedsql_testcode">
			<title>테스트 코드 Sample</title>

			<para>
				다음은 매핑 XML 파일에 별도 쿼리문을 정의하지 않고 쿼리문을 직접 입력하여 실행하는 테스트 코드의 일부이다. 
				다음에서 볼 수 있듯이 Query 서비스는 매핑 XML 	파일없이도 INSERT, SELECT, UPDATE, DELETE를 실행할 수 있도록 지원한다.
				<programlisting language="java">/**
 * 테스트 코드를 샐행하기 위한 data table 생성
 */
public void insertCustomer() throws Exception{
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    //createBySQL() : 매핑 XML 파일에 쿼리문이 정의되어 있지 않을 때 INSERT를 실행한다.
    int result = <emphasis role="bold">queryService.createBySQL(
            "insert into TBL_CUSTOMER values (?, ?, ?)",
            new String[] {"VARCHAR", "VARCHAR", "VARCHAR" },
            new Object[] {"1234567890123", "GilDongHong", "Seoul" });</emphasis>
    if ( result == -1 ){
        throw new Exception("Insert Query failed");
    }
}

/**
 * Query 서비스를 통해 DB에 입력된 데이터를 조회하는 테스트 코드
 */	
public void selectCustomer() {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    //findBySQL() :  매핑 XML 파일에 쿼리문이 정의되어 있지 않을 때 SELECT를 실행한다.
    <![CDATA[List<Map<String, Object>> result]]> = <emphasis role="bold">queryService.findBySQL(
            "select NAME, ADDRESS from TBL_CUSTOMER where SSNO like ?",
            new String[] { "VARCHAR" }, 
            new Object[] { "%4567890123" });</emphasis>
    <![CDATA[Iterator<Map<String, Object>> resultItr]]> = result.iterator();
    while( resultItr.hasNext() ){
        <![CDATA[Map<String, Object> resultMap]]> = resultItr.next();
        resultMap.get("name");
    }
	
    System.out.println("result.size() : " + result.size());
}

/**
 * Query 서비스를 통해 DB에 입력된 데이터를 수정하는 테스트 코드
 */	
public void updateCustomer() {
    QueryService queryService = (QueryService) context.getBean("queryService");

    //updateBySQL() : 매핑 XML 파일에 쿼리문이 정의되어 있지 않을 때 UPDATE를 실행한다.
    int result = <emphasis role="bold">queryService.updateBySQL(
            "update TBL_CUSTOMER set NAME=? where SSNO=?", 
            new String[] {"VARCHAR", "VARCHAR" },
            new Object[] { "Anonymous","1234567890123" });</emphasis>

    System.out.println("result : " + result);
}

/**
 * Query 서비스를 통해 DB에 입력된 데이터를 삭제하는 테스트 코드
 */
public void deleteCustomer() {
    QueryService queryService = (QueryService) context.getBean("queryService");

    //removeBySQL() : 매핑 XML 파일에 쿼리문이 정의되어 있지 않을 때 DELETE를 실행한다.
    int result = <emphasis role="bold">queryService.removeBySQL(
            "delete from TBL_CUSTOMER where SSNO=?",
            new String[] { "VARCHAR" },
            new Object[] { "1234567890123" });</emphasis>

    System.out.println("result : " + result);
}</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_ormapping">
		<title>OR Mapping</title>

		<para>
			다음은 OR mapping을 사용하는 예로, query 정의없이 object만을 사용해서 기본적인 INSERT,
			UPDATE, DELETE, SELECT를 실행한다.
		</para>

		<section id="query_usecases_ormapping_attribute">
			<title>속성 정의 파일 Sample</title>

			<para>
				다음은 Query 서비스를 정의한 context-query.xml과 Query 서비스에서 읽어들일 매핑 XML 파일의 위치를 정의한
				context-query-sqlloader.xml	파일의 일부이다.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    중략...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <property name="mappingFiles">
        <value>
            <!-- xml files in folder -->
            file:./src/test/resources/foldermappings/**/testcase-*.xml,
            file:./src/test/resources/dynamicreload/testcase-queries-dynamicreload.xml,
            <!-- xml files in classpath -->
            classpath*:/mappings/testcase-queries-dynamic.xml,
            classpath*:/mappings/testcase-queries-general.xml,
            classpath*:/mappings/testcase-queries-resultmapping.xml,
            classpath*:/mappings/testcase-queries-resultsetmapper.xml,
            classpath*:/mappings/testcase-table-mappings.xml,
            classpath*:/mappings/testcase-queries-extended.xml,
            classpath*:/mappings/testcase-queries-mappingstyle.xml,
            <!-- xml files in jar  --> 
            classpath*:/jarmappings/testcase-queries-lob.xml
        </value>
    </property>
        중략 ...
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_ormapping_xml">
			<title>매핑 XML 파일 Sample</title>

			<para>
				다음은 앞서 정의한 Query 서비스를 통해 로드된 mapping-query-ormapping.xml 파일의 일부로, 테이블
				TBL_ORMapping와 ORMapping 클래스 사이의 매핑 정보를 포함하고 있다.
				<programlisting language="xml"><![CDATA[<queryservice>
    <table-mapping>
        <table name="TBL_ORMapping"
            class="org.anyframe.sample.domain.ORMapping">
            <field-mapping>
                <dbms-column>id</dbms-column>
                <class-attribute>id</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>name</dbms-column>
                <class-attribute>nm</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>address</dbms-column>
                <class-attribute>addr</class-attribute>
            </field-mapping>
            <primary-key>
                <dbms-column>id</dbms-column>
            </primary-key>
        </table>
    </table-mapping>
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_ormapping_mappingclass">
			<title>OR Mapping시 사용할 매핑 클래스 Sample</title>

			<para>
				다음은 앞서 언급한 매핑 XML 파일에 정의된 OR Mapping 정보를 기반으로 특정 테이블에 데이터를 INSERT, UPDATE, SELECT할 때 
				사용되는 클래스 ORMapping.java 내용의 일부이다.
				<programlisting language="java">public class ORMapping implements Serializable {

    public String id;
    public String nm;
    public String addr;

    public ORMapping() {
    }

    public ORMapping(String i, String n, String a) {
        id = i;
        nm = n;
        addr = a;
    }

    // getter, setter ...
}</programlisting>
			</para>
		</section>

		<section id="query_usecases_ormapping_testcode">
			<title>테스트 코드 Sample</title>

			<para>
				다음은 매핑 XML 파일에 별도 쿼리문을 정의하지 않고 객체만을 이용하여 INSERT, SELECT, UPDATE, DELETE를 실행하는 
				테스트 코드의 일부이다. 매핑 클래스에 필요한 값을 셋팅하여 Query 서비스에 전달함으로써 
				해당하는 쿼리문을 실행시킬 수 있다.
				<programlisting language="java">/**
 * Query 서비스를 통해 DB에 신규 데이터를 입력하는 테스트 코드
 */
public void insertORMapping() {
    QueryService queryService = (QueryService) context.getBean("queryService");

    ORMapping ormapping = new ORMapping("1234567890123", "HonggilDong", "Ansan");

    // ORMapping 객체에 초기값을 셋팅하고 이 객체를 통해 INSERT를 실행한다.
    // 다음 코드에 의해 실행되는 쿼리문은
    // INSERT INTO TBL_ORMapping (address ,name ,id ) 
    // values ( '1234567890123', 'HonggilDong', 'Ansan' )	
    int result = <emphasis role="bold">queryService.create(ormapping);</emphasis>
    System.out.println("result : " + result);
}

/**
 * Query 서비스를 통해 DB에 입력된 데이터를 조회하는 테스트 코드
 */	
public void selectORMapping() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    ORMapping ormapping = new ORMapping();
    ormapping.setId("1234567890123");

    // primary-key로 지정한 칼럼에 매핑되는 attribute에 값을 입력하고 
    // find를 실행하면 primary-key를 조회 조건으로  하는 SELECT를 실행한다.
    // 다음 코드에 의해 실행되는 쿼리문은 
    // SELECT NAME, ADDRESS FROM TBL_ORMAPPING WHERE ID = '1234567890123'
    <![CDATA[List<ORMapping> result]]> = <emphasis role="bold">queryService.find(ormapping);</emphasis>
    if ( result.size() != 1 ){
        throw new Exception("Select failed");
    }
}

/**
 * Query 서비스를 통해 DB에 입력된 데이터를 수정하는 테스트 코드
 */
public void updateORMapping() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    ORMapping ormapping = new ORMapping("1234567890123", "HonggilDongn", "Seoul");

    // 다음 코드에 의해 실행되는 쿼리문은 
    // Update TBL_ORMapping set address = 'Seoul' ,name = 'HonggilDong'
       where id = '1234567890123'	
    int result = <emphasis role="bold">queryService.update(ormapping);</emphasis>
    if ( result == -1 ){
        throw new Exception("Update failed");
    }
}

/**
 * Query 서비스를 통해 DB에 입력된 데이터를 삭제하는 테스트 코드
 */	
public void deleteORMapping() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    ORMapping ormapping = new ORMapping();
    ormapping.setId("1234567890123");

    // 다음 코드에 의해 실행되는 퀴리문은 
    // DELETE FROM TBL_ORMapping where id = 1234567890123	
    int result = queryService.remove(ormapping);
    if ( result == -1 ){
        throw new Exception("Update failed");
    }
}</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_dynamic">
		<title>Dynamic Query</title>

		<para>
			Query 서비스는 text 치환, named parameter 형태 등을 통해 운영 시 입력된 조건 값에 따라 동적으로 
			변경되는 쿼리문 정의를 지원한다. 이를 위해서는 다음과 같은 syntax를 사용할 수 있다.
		</para>

		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold">:ParameterName</emphasis>
					: 특정 쿼리문에 입력되어야 할 변수를 지정할 때 사용한다.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">{{치환 문자열 키}}</emphasis>
					: 치환 문자열 키에 해당하는 값으로 치환되어야 하는 부분에 정의한다.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">#if ~ (#elseif) ~ #end</emphasis>
						: 조건 분기가 필요한 부분에 정의한다.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold"># foreach ~ #end</emphasis>
					: Loop가 필요한 부분에 정의한다.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">$velocityCount </emphasis>
					: foreach 구문내의 Loop index를 체크하고자 하는 부분에 정의한다.
				</para>
			</listitem>
		</itemizedlist>
		
		<section id="query_usecases_dynamic_attribute">
			<title>속성 정의 파일 Sample</title>

			<para>
				다음은 Query 서비스를 정의한 context-query.xml 과 Query 서비스에서 읽어들일 매핑 XML 파일의 위치를 정의한
				context-query-sqlloader.xml 파일의 일부이다.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    중략...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-dynamic.xml</filename>
        중략...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_dynamic_xml">
			<title>매핑 XML 파일 Sample</title>

			<para>
				다음은 앞서 정의한 Query 서비스를 통해 로드된 mapping-query-dynaminc.xml의 일부로, 여러
				유형의 dynamic 쿼리문을 포함하고 있다.
				<programlisting language="xml"><![CDATA[<queries>	
    <query ]]><emphasis role="bold">id="getLogonIdByNamedParam"</emphasis><![CDATA[ isDynamic="true">
        <statement>
            SELECT LOGON_ID 
            FROM TBL_USER 
            WHERE LOGON_ID BETWEEN ]]><emphasis role="bold">:lowId AND :highId</emphasis><![CDATA[
        </statement>
        <param name="lowId" type="VARCHAR"/>
        <param name="highId" type="VARCHAR"/>
    </query>
    <query ]]><emphasis role="bold">id="getEmployeesByTextReplacement"</emphasis><![CDATA[ isDynamic="true">
        <statement>
            SELECT LOGON_ID 
            FROM ]]><emphasis role="bold">{{schema}}</emphasis><![CDATA[ 
            ORDER BY ]]><emphasis role="bold">{{sortColumn}}</emphasis><![CDATA[
        </statement>
    </query>
    <query ]]><emphasis role="bold">id="getLogonIdByIf"</emphasis><![CDATA[ isDynamic="true">
        <statement>
            SELECT LOGON_ID 
            FROM TBL_USER
            ]]><emphasis role="bold">#if ($id &amp;&amp; !$id.equals(""))
            WHERE LOGON_ID like '%' || :logonId || '%'
            #end </emphasis><![CDATA[
            ORDER BY {{sortColumn}}
        </statement>
        <param name="logonId"	type="VARCHAR"/>
    </query>
    <query ]]><emphasis role="bold">id="getLogonIdByForeach"</emphasis><![CDATA[ isDynamic="true">
        <statement>
            SELECT LOGON_ID, NAME 
            FROM TBL_USER
            WHERE LOGON_ID IN (
                ]]><emphasis role="bold">#foreach ($logonId in $logonIdList) 
                    #if ($velocityCount	== 1 )
                        '$logonId'
                    #else
                        , '$logonId'
                    #end
                #end </emphasis><![CDATA[
            ) 
            ORDER BY NAME
        </statement>
    </query>
</queries>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_dynamic_testcode">
			<title>테스트 코드 Sample</title>

			<para>
				다음은 앞서 언급한 매핑 XML 파일에 정의된 parameter 값에 따라 동적으로 변경 가능한 쿼리문들을 실행하는 테스트 코드의 
				일부이다.

				<programlisting language="java">/**
 * Named Parameter를 이용해서 query id가 'getLogonIdByNamedParam'인 Dynamic 쿼리문을
 * 실행한다. getLogonIdByNamedParam : key가 lowId, highId인 Named Parameter의 값을
 * key=value 형태로 Query 서비스에 전달하면 Query 서비스는 해당 value를 PreparedStatement
 * 에 셋팅하고 해당 쿼리문을 실행한다. 이 메소드에서는 "lowId = a", "highId = z"라는
 * paramter를  Object[] 형태로 Query 서비스에 전달하고 있으며, 이 때 실행되는 쿼리문은
 * 다음과 같다.
 * SELECT LOGON_ID FROM TBL_USER WHERE LOGON_ID BETWEEN 'a' AND 'z'
 */
public void dynamicQueryUsingNamedParameter() {
    QueryService queryService = (QueryService) context.getBean("queryService");

    Object[] iVal = new Object[2];
    iVal[0] = new Object[]{"lowId", "a"};
    iVal[1] = new Object[]{"highId", "z"};

    <![CDATA[List<Map<String, Object>> rtList]]>
        <emphasis role="bold">= queryService.find("getLogonIdByNamedParam", iVal);</emphasis>
    System.out.println("rtList.size() : " + rtList.size());
}

/**
 * {{치환문자열키}}를 이용해서  query id가 'getEmployeesByTextReplacement'인 Dynamic 
 * 쿼리문을 실행한다. getEmployeesByTextReplacement : key가 schema, sortColumn인
 * 치환문자열의 값을 key=value 형태로 Query 서비스에 전달하면 Query 서비스는 해당 value를
 * 문자열로 그대로 치환해서 사용한다. 이 메소드에서는 "schema=TBL_USER", "sortColumn=NAME"
 * 라는 parameter를 Object[] 형태로 Query 서비스에 전달하고 있으며, 이 때 실행되는 쿼리문은
 * 다음과 같다.
 * SELECT * FROM TBL_USER ORDER BY NAME
 */
public void dynamicQueryUsingTextreplace() {
    QueryService queryService = (QueryService) context.getBean("queryService");

    Object[] iVal = new Object[2];
    iVal[0] = new Object[]{"schema", "TBL_USER"};
    iVal[1] = new Object[]{"sortColumn", "NAME"};

    <![CDATA[List<Map<String, Object>> rtList]]>
        <emphasis role="bold">= queryService.find("getEmployeesByTextReplacement", iVal);</emphasis>
    System.out.println("rtList.size() : " + rtList.size());
}

/**
 * 조건분기를 위한 #if를 이용해서  query id가 'getLogonIdByIf'인 Dynamic 쿼리문을 실행한다.
 * getLogonIdByIf : key가 id인 parameter의 값이 Null이 아니고, 빈 문자열도 아니라면, #if문
 * 내에 포함된 WHERE절이 실행될 쿼리문에 포함된다. (#if문이 끝나는 지점에는 반드시 #end를
 * 정의해주어야 함에 유의하자.)
 * 또한, WHERE절 내에서는  '%' || :logonId || '%'와 같은 형태의 문장을 사용하고 있는데
 * 이것은 Named Parameter의 값에 앞뒤로 %를 붙인 형태의 문자열을 만들어 내기 위함이다.
 * (이 때, '%', ||, :logonId 사이에는 빈 칸을 두어야 WHERE절이 정상적으로 동작한다. )
 * 이 메소드에서는 "id=test", "sortColumn=NAME" 라는 parameter를 Object[] 형태로 Query
 * 서비스에 전달하고 있으며 실행되는 쿼리문은 다음과 같다.
 * SELECT LOGON_ID
 * FROM TBL_USER
 * WHERE LOGON_ID like '%test%'
 * ORDER BY NAME
 */
public void dynamicQueryUsingCondition() {
    QueryService queryService = (QueryService) context.getBean("queryService");

    Object[] iVal = new Object[3];
    iVal[0] = new Object[]{"id", "yes"};
    iVal[1] = new Object[]{"logonId", "test"};
    iVal[2] = new Object[]{"sortColumn", "NAME"};

    <![CDATA[List<Map<String, Object>> rtList]]>
        <emphasis role="bold">= queryService.find("getLogonIdByIf", iVal);</emphasis>
    System.out.println("rtList.size() : " + rtList.size());
}

/**
 * Loop를 위한 #foreach를 이용해서  query id가 'getLogonIdByForeach'인 Dynamic 쿼리문을
 * 실행한다. getLogonIdByForeach : key가 logonIdList인  parameter의 값은 List 형태이며, 
 * List에서 순서대로 추출된 값들은 내부적으로 logonId라는 변수에 셋팅된다. logonId는 
 * Query 서비스에 전달되어야 하는 입력 parameter가 아니다.
 * velocityCount가 1인 경우 즉, 첫번째 Loop일 경우 logonIdList의 첫번째 값이 그대로
 * 추가되고 그 이후부터는 ,를 붙인 값이 추가되게 된다. (#foreach, #if문이 끝나는 지점에는
 * 반드시 #end를 정의해주어야 함에 유의하자.) 이 메소드에서는 logonIdList의 값이 "admin",
 * "test"라는 두개의 문자열로 구성된 ArrayList를 Object[] 형태로 Query 서비스에 전달하고
 * 있으며 실행되는 쿼리문은 다음과 같다.
 * SELECT LOGON_ID, NAME
 * FROM TBL_USER
 * WHERE LOGON_ID IN ('admin', 'test')
 * ORDER BY NAME
 */
public void dynamicQueryUsingLoop() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    <![CDATA[List<String> logonIdList = new ArrayList<String>();]]>
    logonIdList.add("admin");
    logonIdList.add("test");

    Object[] iVal = new Object[]{"logonIdList", logonIdList};

    <![CDATA[List<Map<String, Object>> rtList]]> 
        <emphasis role="bold">= queryService.find("getLogonIdByForeach", new Object[]{ iVal });</emphasis> 

    if (rtList.size() != 1) {
        throw new Exception("Dynamic Query Using Condition failed");
    }
}</programlisting>
			</para>
		</section>
		<note>
			<title>Dynamic Query 정의시 유의사항</title>
			<para>
				Query Service를 이용하여 목록 조회 결과를 특정 객체에 매핑하기 위해 쿼리문 실행시마다 매핑 정보 셋팅을 위한
				로직이 반복 수행된다. Query Service의 성능을 개선하기 위해 Anyframe 4.0.0 이후부터 이 로직을 변경하여 
				한 번 처리한 Result Mapping 정보를 SQLLoader에서 queryId를 기준으로 관리하도록 하였다. 따라서 조회되는 칼럼 정보가 
				쿼리문 실행시마다 변경될 수 있는 SELECT, FROM 절이 가변적으로 변경되는 쿼리문인 경우에는 Result Mapping 정보가 쿼리문 실행시마다 변경될 수 있으므로 
				별도 Mapper 클래스를 통해 처리될 수 있도록 해야 한다. Anyframe에서 org.anyframe.query.impl.jdbc.mapper 패키지 
				하위에 제공되는 Mapper 클래스는 다음과 같은 역할을 수행한다.

				<table>
					<title>Mapper Class</title>
					<tgroup cols="2">
						<colspec colnum="1" colname="col1" colwidth="3*" />
						<colspec colnum="2" colname="col2" colwidth="7*" />
						<thead>
							<row>
								<entry align="center">Class Name</entry>
								<entry align="center">Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>DefaultCallbackResultSetMapper</entry>
								<entry>
									[기본 적용] 특정 쿼리문에 대해 별도 mapper가 정의되어 있지 않고, 조회 결과를 Map 형태로 전달받는 경우에 
									Query Service에서 기본적으로 적용하는 Mapper.
									처음으로 실행하는 쿼리문의 조회 칼럼 정보는 저장되며, 다음 실행시에는 저장된 정보를 기반으로 조회 칼럼 매핑 수행.
								</entry>
							</row>
							<row>
								<entry>CallbackResultSetMapper</entry>
								<entry>
									조회 결과를 Map 형태로 전달받는 경우 쿼리문 실행 시점마다 조회 칼럼 매핑을 처리하는 Mapper.
									SELECT/FROM 절이 동적으로 구성되어 있어 쿼리문 실행시마다 조회 결과가 달라지는 쿼리문인 경우 
									활용 가능하며 해당하는 쿼리문의 mapper 속성값으로 정의.
								</entry>
							</row>
							<row>
								<entry>DefaultReflectionResultSetMapper</entry>
								<entry>
									[기본 적용] 특정 쿼리문에 대해 별도 mapper가 정의되어 있지 않고, 조회 결과를 특정 VO 형태로 전달받는 경우 
									Query Service에서 기본적으로 적용하는 Mapper.
									처음으로 실행하는 쿼리문의 조회 칼럼 정보는 저장되며, 다음 실행시에는 저장된 정보를 기반으로 조회 칼럼 매핑 수행.
								</entry>
							</row>
							<row>
								<entry>ReflectionResultSetMapper</entry>
								<entry>
									조회 결과를 특정 VO 형태로 전달받는 경우 쿼리문 실행 시점마다 칼럼 매핑을 처리하는 Mapper.
									SELECT/FROM 절이 동적으로 구성되어 있어 쿼리문 실행시마다 조회 결과가 달라지는 쿼리문인 경우 
									활용 가능하며 해당하는 쿼리문의 mapper 속성값으로 정의.
								</entry>
							</row>
							<row>
								<entry>MappingStyleColumnMapRowMapper</entry>
								<entry>
									StoredProcedure 수행시 CamelCase, Lower, Upper와 같은 Result Mapping Style을 적용하기
									위해 Query 서비스에서 기본적으로 사용하는 Mapper
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>

				<para>
					다음은 조건에 따라 FROM 절이 변경되는 쿼리문의 예이다. 앞서 언급한 바와 같이 QueryService에서는 기본적으로 queryId를 기준으로
					한번 실행된 쿼리문에 대해 Result Mapping 정보를 저장해두고 있기 때문에 다음과 같이 SELECT 또는 FROM 절이 변경되는 쿼리문의 경우 
					처음 실행된 쿼리문과 이후 실행되는 쿼리문이 달라질 수 있게 된다. 따라서 현재 실행된 쿼리문의 결과와 queryId를 기준으로 저장된 
					Result Mapping 정보가 맞지 않아 원치 않은 결과가 도출될 수 있을 것이다. 이와 같은 경우에는 다음과 같이 <![CDATA[<result mapper="..."/>]]>를 
					이용하여 해당 쿼리문을 별도 Mapper를 통해 처리될 수 있도록 정의해 주어야 함을 기억하도록 하자.
				</para>
				<para>
					'findUsers' 쿼리문의 경우 쿼리 수행 결과를 Map으로 전달받기 위해 CallbackResultSetMapper를 mapper로 정의하고 있음을 알 수 있다.
				</para>
				<programlisting language="xml"><![CDATA[<query id="findUsers" isDynamic="true">
    <statement>
        SELECT LOGON_ID FROM {{schema}} ORDER BY {{sortColumn}}
    </statement>
    <result ]]><emphasis role="bold">mapper="org.anyframe.query.impl.jdbc.mapper.
            CallbackResultSetMapper"</emphasis><![CDATA[/>
</query>]]></programlisting>
				<para>만일 'findUsers' 쿼리문의 수행 결과를 User Defined Object로 전달받기 위해서는 앞서 언급한 ReflectionResultSetMapper를 mapper로 정의하고,
				전달받고자하는 클래스를 명시해주면 된다.</para>
				<programlisting language="xml"><![CDATA[<query id="findUsers" isDynamic="true">
    <statement>
        SELECT LOGON_ID FROM {{schema}} ORDER BY {{sortColumn}}
    </statement>
    <result ]]><emphasis role="bold">class="org.anyframe.core.query.vo.UsersVO"
        mapper="org.anyframe.query.impl.jdbc.mapper.
                ReflectionResultSetMapper"</emphasis><![CDATA[/>
</query>]]></programlisting>
				<para>
					위에서 제시한 Mapper 외에 특정 쿼리문에 적합한 Custom ResultSetMapper 클래스를 별도 구현할 수 있으며 
					이것은 <link linkend="query_usecases_resultsetmapper_xml">Result Mapper 정의 방법</link>을 
					참고하도록 한다.
				</para>
			</para>
		</note>
	</section>

	<section id="query_usecases_pagination">
		<title>Pagination</title>

		<para>
			Query 서비스를 통해 조회 유형의 쿼리문 실행시 전체 결과를 조회하지 않고 해당 페이지에 속한 데이터만 조회할 수
			있으므로, 효율적이고 성능에 유리하다. Query 서비스는 페이징 처리를 위해 별도의 로직이나 특정 DB에 종속적인 쿼리문을
			요구하지 않는다. 다만 조회하고자 하는 페이지의 번호와 한 페이지에 보여지는 데이터의 개수만 입력 parameter로
			전달하면 된다.
		</para>

		<section id="query_usecases_pagination_attribute">
			<title>속성 정의 파일 Sample</title>

			<para>
				다음은 Query 서비스를 정의한 context-query.xml 과 Query 서비스에서 읽어들일 매핑 XML 파일의 위치를 정의한
				context-query-sqlloader.xml파일의 일부이다. (* 조회 유형의 쿼리에 대해 	페이징 처리를 수행하기 위해서는 해당 DB에 맞는 
				PagingSQLGenerator를 추가 셋팅해주어야 함에 유의하도록 한다.)
			</para>
			<important>
				<title>Pagination시 유의 사항</title>
				<para>
					QueryService 속성 정의시에는 반드시 DBMS에 적합한 PagingSQLGenerator를 셋팅해 주어야 한다.
					적절한 PagingSQLGenerator가 존재하지 않는 경우에는 QueryService에서 제공하는 org.anyframe.query.impl.jdbc.generator.DefaultPagingSQLGenerator를
					사용할 수 있으나, DefaultPagingSQLGenerator를 이용하여 findXXX() 메소드를 실행하면 QueryService 내부적으로
					조건에 해당하는 모든 데이터를 fetch한 이후 ResultSet Cursor의 위치를 이동시키는 방식으로 특정 페이지에 속한 데이터를
					걸러낸다. 이 때 ResultSet Cursor를 움직이는 로직에서 상당한 시간이 소요되어 다량의 데이터 조회시 성능에 심각한 영향을 
					끼칠 수 있다. 따라서, DefaultPagingSQLGenerator 사용은 권장하지 않는다.
				</para>
			</important>

			<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    <property name="pagingSQLGenerator" ref="pagingSQLGenerator"/>
    중략...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>
<bean id="pagingSQLGenerator"
        class="org.anyframe.query.impl.jdbc.generator.OraclePagingSQLGenerator"/>]]>  </programlisting>
			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-pagination.xml</filename>
    중략...
    </config:configuration>
</bean>]]>  		</programlisting>
			</para>
		</section>

		<section id="query_usecases_pagination_xml">
			<title>매핑 XML 파일 Sample</title>

			<para>
				다음은 앞서 정의한 Query 서비스를 통해 로드된 mapping-query-pagination.xml의 일부로, 테이블 매핑 정보와 쿼리문을 
				포함하고 있다.
				<programlisting language="xml"><![CDATA[<query id="selectUsingPagination">
    <statement>
        SELECT NAME FROM TBL_CUSTOMER WHERE SSNO like ?
    </statement>
    <param type="VARCHAR" />
    <result class="org.anyframe.sample.domain.Customer"/>
</query>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_pagination_testcode">
			<title>테스트 코드 Sample</title>

			<para>
				다음은 앞서 언급한 매핑 XML 파일에 정의된 SELECT 쿼리문을 실행하는 테스트 코드의 일부로,
				페이징 처리된 수행 결과를 얻어 내기 위한 테스트 로직을 포함하고 있다.
				<programlisting language="java">/**
 * SELECT 수행 결과를 특정 페이지별로 조회하는 테스트 코드
 * 이 메소드에서는 TBL_CUSTOMER 테이블에 여러 데이터가 입력되었을 때, 한 페이지에 표현하고자 
 * 하는 데이터의 개수(5)와 조회 페이지 페이지 번호(3)를 입력하여  특정 페이지에 속한 데이터만 
 * 조회해 본다.
 */
public void selectCustomer() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    /** findWithRowCount() : 매핑 XML 파일에 정의되어 있는 query id를 이용하여 SELECT를
     *                       실행한다. findWithRowCount()는 한번의 호출로 해당 SELECT로 
     *                       얻을 수 있는 전체 데이터의 개수와 특정 페이지에 해당하는
     *                       결과값들을 얻어 올 수 있다.
     */
    <![CDATA[Map<String, Object> resultMap]]> = <emphasis role="bold">queryService.findWithRowCount("selectUsingPagination",
            new Object[] { "%1234%" }, 3, 5);</emphasis>

    Customer customer = new Customer();

    // 특정 페이지에 속한 결과값들 추출
    <![CDATA[List<Customer> resultList]]> = (List) resultMap.get(<emphasis role="bold">QueryService.LIST</emphasis>);
    <![CDATA[for(int i = 0 ; i < resultList.size() ; i ++){
        customer = resultList.get(i);
        customer.getNm();
    }]]>

    // 해당 SELECT로 얻어질 수 있는 전체 데이터의 개수 추출
    int totalSize = ((Long) resultMap.get(<emphasis role="bold">QueryService.COUNT</emphasis>)).intValue();
    if (resultList.size() != 5 || totalSize != 15) {
        throw new Exception("Select query failed");
    }
}</programlisting>
			</para>

			<para>
				다음은 Query 서비스에서 제공하는 페이징 처리 기능을 수행하는 findXXX() 메소드 사용시 알아두어야 할 사항들이다.
				<emphasis role="bold">public Collection find...(..., int pageIndex, int pageSize);</emphasis>
			</para>

			<orderedlist>
				<listitem>
					<para>
						페이지 번호가 1보다 작으면 결과 데이터가 없다. (<emphasis role="bold">Anyframe 3.2.0 이후</emphasis>)
					</para>
				</listitem>
				<listitem>
					<para>
						페이지 번호가 1보다 작으면 첫번째 페이지가 조회된다. (<emphasis role="bold">Anyframe 3.2.0 이전</emphasis>	)
					</para>
				</listitem>
				<listitem>
					<para>한 페이지에 보여줘야 하는 데이터의 개수는 0보다 커야 한다.</para>
				</listitem>
				<listitem>
					<para>
						페이지 번호와 한 페이지에 보여줘야 하는 데이터의 개수를 사용하여 계산한 값이 전체 결과 데이터의 개수보다
						크면 결과 데이터가 없다.(<emphasis role="bold">Anyframe 3.2.0 이후</emphasis>)
					</para>
				</listitem>
				<listitem>
					<para>
						페이지 번호와 한 페이지에 보여줘야 하는 데이터의 개수를 사용하여 계산한 값이 전체 결과 데이터의 개수보다
						크면 마지막 페이지가 조회된다. (<emphasis role="bold">Anyframe 3.2.0 이전</emphasis>)
					</para>
				</listitem>
				<listitem>
					<para>
						한 페이지에 보여줘야 하는 데이터의 개수가 생략될 경우 매핑 XML 파일의 <![CDATA[<result>]]>에
						별도로 정의해 주어야 한다.
						<programlisting language="xml"><![CDATA[<query id="selectUsingPagination" isDynamic="false">
    <statement>
        SELECT NAME FROM TBL_CUSTOMER WHERE SSNO like ?
    </statement>
    <param type="VARCHAR" />
    <result length="10" class="org.anyframe.sample.domain.Customer"/>
</query>]]></programlisting>
					</para>
				</listitem>
			</orderedlist>
		</section>
	</section>

	<section id="query_usecases_batch">
		<title>Batch Update</title>

		<para>
			Query 서비스는 JDBC 2.0 batch updates를 사용해서 한번의 호출로 여러 건의 데이터를 INSERT, UPDATE, DELETE할 수 있게 한다.
		</para>

		<section id="query_usecases_batch_attribute">
			<title>속성 정의 파일 Sample</title>

			<para>
				다음은 Query 서비스를 정의한 context-query.xml과 Query 서비스에서 읽어들일 매핑 XML 파일의 위치를 정의한
				context-query-sqlloader.xml 파일의 일부이다.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    중략...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-batch.xml</filename>
        중략...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_batch_xml">
			<title>매핑 XML 파일 Sample</title>

			<para>
				다음은 앞서 정의한 Query 서비스를 통해 로드된 mapping-query-batch.xml 파일의 일부로, 테이블 매핑
				정보와 Batch로 처리할 쿼리문을 포함하고 있다.
				<programlisting language="xml"><![CDATA[<queryservice>
    <table-mapping>
        <table name="TBL_CUSTOMER"
            class="org.anyframe.sample.domain.Customer">
            <field-mapping>
                <dbms-column>ssno</dbms-column>
                <class-attribute>ssno</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>name</dbms-column>
                <class-attribute>nm</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>address</dbms-column>
                <class-attribute>addr</class-attribute>
            </field-mapping>
            <primary-key>
                <dbms-column>ssno</dbms-column>
            </primary-key>
        </table>
    </table-mapping>
    <queries>
        <query id="insertbatch" isDynamic="false">
            <statement>
                INSERT INTO TBL_CUSTOMER ( ssno, name, address ) VALUES (?,?,?)
            </statement>
            <param type="VARCHAR" />
            <param type="VARCHAR" />
            <param type="VARCHAR" />
        </query>
    </queries>
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_batch_testcode">
			<title>테스트 코드 Sample</title>

			<para>
				다음은 앞서 언급한 매핑 XML 파일에 정의된 INSERT 쿼리문을 Batch Update를 이용해 실행하는 테스트 
				코드의 일부이다. 입력 parameter를 LIST 형태로 담아서 Query 서비스에 전달하면, 
				Query 서비스는 한 번의 실행으로 전달된 List 개수 만큼의 쿼리문을 실행한다.
				<programlisting language="java">/**
 * 매핑 XML 파일에 정의된 쿼리문을 batch update를 이용해 실행.
 */
public void insertCustomer() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    //List에 입력할 데이터를 저장한다.
    <![CDATA[List<Object[]> args = new ArrayList<Object[]>();]]>
    Object[] arg = new Object[3];
    arg[0] = "1234567890123";
    arg[1] = "KimMinsu";
    arg[2] = "Ansan";
    args.add(arg);
    arg = new Object[3];
    arg[0] = "1234567890124";
    arg[1] = "LeeSungwook";
    arg[2] = "Seoul";
    args.add(arg);
    arg = new Object[3];
    arg[0] = "1234567890125";
    arg[1] = "ParkHeejin";
    arg[2] = "Seoul";
    args.add(arg);

    //List에 3개의 Object가 포함되어 있으므로 query id가 insertbatch인
    //쿼리문이 3번 실행된다.
    int[] results = queryService.batchUpdate("insertbatch", args);
    <![CDATA[for (int i = 0; i < results.length; i++) {
        if (results[i] == -1) {
            throw new Exception("Batch Insert falied");
        }
    }]]>
}

/**
 * 매핑 XML 파일에 쿼리문이 정의되어 있지 않을 때, 실행할 쿼리문을 직접 입력하여
 * batch update를 실행 
 */
public void insertCustomerBySQLQuery() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    //실행 할 쿼리문을 정의
    String sql = "INSERT INTO TBL_CUSTOMER ( ssno, name, address ) VALUES (?,?,?)";

    //입력할 parameter의 SQL Type을 정의
    String[] types = new String[3];
    types[0] = "VARCHAR";
    types[1] = "VARCHAR";
    types[2] = "VARCHAR";

    //List에 입력할 데이터를 저장한다.
    <![CDATA[List<Object[]> args = new ArrayList<Object[]>();]]>
    Object[] arg = new Object[3];
    arg[0] = "1234567890126";
    arg[1] = "HongGildong";
    arg[2] = "Suwon";
    args.add(arg);
    arg = new Object[3];
    arg[0] = "1234567890127";
    arg[1] = "LeeSoonsin";
    arg[2] = "Seongnam";
    args.add(arg);
    arg = new Object[3];
    arg[0] = "1234567890128";
    arg[1] = "ChoiMinsu";
    arg[2] = "Seoul";
    args.add(arg);

    //List에 3개의 Object가 포함되어 있으므로 해당 쿼리문이 3번 실행된다.	
    int[] results = queryService.batchUpdateBySQL(sql, types, args);

    <![CDATA[for (int i = 0; i < results.length; i++) {
        if (results[i] == -1) {
            throw new Exception("BatchInsertBySQL falied");
        }
    }]]>
}

/**
 * OR Mapping을 이용해서 batch update를 실행
 */
public void insertCustomerByObject() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
    
    <![CDATA[List<Customer> args = new ArrayList<Object[]>();]]>
    Customer customer = new Customer();

    customer.setSsno("1234567890129");
    customer.setNm("Smith");
    customer.setAddr("LA");
    args.add(customer);

    customer = new Customer();
    customer.setSsno("1234567890130");
    customer.setNm("Brown");
    customer.setAddr("Newyork");
    args.add(customer);

    customer = new Customer();
    customer.setSsno("1234567890131");
    customer.setNm("Eugene");
    customer.setAddr("Boston");
    args.add(customer);

    // 실행되는 쿼리문은 기본적인 INSERT문인
    // insert into TBL_CUSTOMER (ssno ,address ,name ) values ( ?, ?, ? )이다.
    int[] results = queryService.batchCreate(args);

    <![CDATA[for (int i = 0; i < results.length; i++) {
        if (results[i] == -1) {
            throw new Exception("BatchInsertByObject falied");
        }]]>
    }
}</programlisting>
			</para>
			<note>
				<title>Oracle-style Batch Update</title>
				<para>
					Oracle-style의 batch update가 필요한 경우 Anyframe에서 제공하는 <link linkend="query_configuration_jdbctemplate">OraclePagingJdbcTemplate</link>를 
					사용해야 한다.
					OraclePagingJdbcTemplate는 입력된 쿼리문에 대해 내부적으로 PreparedStatement 형태로 변경하여 쿼리문을 batch로 처리하고 있다.
					그런데 입력된 쿼리문이 Stored Procedure, Function 등일 경우 PreparedStatement 형태로 batch 처리하고자 할 때 SQLException이 발생하게 된다.
				    이를 해결하기 위해 Anyframe에서는 CallableStatement 형태로 처리되어야 하는 쿼리문(Stored Procedure, Function 등)에 대해 batch update 할 수 있도록 
				    OraclePagingJdbcTemplate 내에 별도의 메소드를 추가하였다.
				    이 메소드는 QueryService의 batchExecute(), batchExecuteBySQL() 메소드를 통해 내부적으로 호출된다.
				</para>
				<para>
					따라서 Stored Procedure, Function 등에 대한 Oracle-style의 batch update를 위해서는 QueryService의 batchExecute(), batchExecuteBySQL() 메소드를 
					호출하여 처리해야 함을 기억하도록 하자.
				</para>
			</note>
		</section>
	</section>

	<section id="query_usecases_statement">
		<title>Callable Statement</title>

		<para>
			CallableStatment는 표준 DDL, DML이 아닌 DB의 Stored Procedure, Function 등을 호출할 때 사용한다. 
			Stored Procedure는 쿼리문을 하나의 파일 형태로 만들거나 DB에 저장해두고 함수처럼 호출해서 사용하는 것으로, 
			성능, 코드의 독립성, 보안성 등의 다양한 이점을 제공한다.
		</para>

		<section id="query_usecases_statement_attribute">
			<title>속성 정의 파일 Sample</title>

			<para>
				다음은 Query 서비스를 정의한 context-query.xml 과 Query 서비스에서 읽어들일 매핑 XML 파일의 위치를 정의한
				context-query-sqlloader.xml 파일의 일부이다.
				<programlisting language="xml"><![CDATA[<bean name="oracle_queryservice" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    중략...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-callablestatement.xml</filename>
                중략...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_xml">
			<title>매핑 XML 파일 Sample</title>

			<para>
				다음은 앞서 정의한 Query 서비스를 통해 로드된 mapping-query-callablestatement.xml 파일의 일부로, DB에 기 생성되어 
				있는 test_function이라는 Function을 실행시키기 위한 쿼리문을 포함하고 있다.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="callFunction">
            <statement>{? = call test_function(?)}</statement>
            <param type="NUMERIC" binding="OUT" name="outVal" />
            <param type="NUMERIC" binding="IN" name="inVal" />
        </query>
    </queries>    
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_testcode">
			<title>테스트 코드 Sample</title>

			<para>
				다음은 앞서 언급한 매핑 XML 파일에 정의된 Function을 호출하기 위한 쿼리문을 실행하는 테스트 코드의
				일부이다. Query 서비스를 통해 DB Function을 실행시키기 위해서는 사용하는 DB에 해당 Function이 미리 생성되어 있어야 한다.
				<programlisting language="java">/**
 * 매핑 XML 파일에 정의되어 있는 query id를 이용해 Function을 호출한다.
 */
public void callableStatementFunction() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    <![CDATA[Map<String, Integer> inVal = new HashMap<String, Integer>();]]>
    inVal.put("inVal", new Integer(10));

    <![CDATA[Map<String, Object> results]]> = <emphasis role="bold">queryService.execute("callFunction", inVal);</emphasis>
    BigDecimal rtVal = (BigDecimal) results.get("outVal");

    if (rtVal.intValue() != 1 ){
        throw new Exception("testCallableStatementProcedure failed");
    }
}

/**
 * 매핑 XML 파일에 정의되어 있지 않은 경우에도 특정 Function을 호출할 수 있다.
 * Map executeBySQL(String sql, String[] types, String[] names,
 *     String[] bindings, Map values) 
 */
public void callableStatementBySQL() throws Exception {
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");

    String sql = "{? = call test_function(?)}";
    String[] types = { "NUMERIC", "NUMERIC" };
    String[] bindings = { "OUT", "IN" };
    String[] names = { "outVal", "inVal" };

    <![CDATA[Map<String, Integer> inVal = new HashMap<String, Integer>();]]>
    inVal.put("inVal", new Integer(10));

    <![CDATA[Map<String, Object> results]]> = <emphasis role="bold">queryService.executeBySQL(sql, types, names, bindings, inVal);</emphasis>
    BigDecimal rtVal = (BigDecimal) results.get("outVal");

    if (rtVal.intValue() != 1 ){
        throw new Exception("testCallableStatementBySQL failed");
    }
}

/**
 * 매핑 XML 파일에 정의되어 있지 않은 경우에도 특정 Function을 호출할 수 있다.
 * 이 메소드에서는 페이징 처리된 조회 결과를 얻고자 한다.
 * Map executeBySQL(String sql, String[] types, String[] names, 
 * 					String[] bindings, Map values, int pageIndex, int pageSize) 
 */
public void callableStatementBySQLWithPaging() throws Exception {
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");

    String sql = "{? = call test_function(?)}";
    String[] types = { "NUMERIC", "NUMERIC" };
    String[] bindings = { "OUT", "IN" };
    String[] names = { "outVal", "inVal" };

    <![CDATA[Map<String, Integer> inVal = new HashMap<String, Integer>();]]>
    inVal.put("inVal", new Integer(10));

    <![CDATA[Map<String, Object> results]]> = <emphasis role="bold">queryService.executeBySQL(sql, types, names, bindings, inVal, 1, 1);</emphasis>
    BigDecimal rtVal = (BigDecimal) results.get("outVal");

    if (rtVal.intValue() != 1 ){
        throw new Exception("testCallableStatementBySQLWithPaging failed");
    }
}</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_lob">
		<title>CLOB, BLOB</title>

		<para>
			기본적으로 LOB 유형의 데이터와 다른 유형의 데이터를 다루는 방식은 다르지 않다. 다만, LOB 유형의 데이터 조작이
			필요한 경우에는 Query Service 속성 정의시 Lob Handler를 추가로 정의해 주어야 함을 기억하도록 하자. LobHandler 속성
			정의에 대한 자세한 내용은 <link linkend="query_configuration_lobhandler">[lobHandler] 속성</link>을 참고하도록 한다. 
			여기에서는 Oracle 9i 이상, Oracle 8i로 구분하여 LOB 유형의 데이터를 다루는 방법에 대해 살펴볼 것이다.
		</para>

		<section id="query_usecases_lob_oracle9i">
			<title>Oracle 9i 이상일 경우</title>

			<section id="query_usecases_lob_oracle9i_attribute">
				<title>속성 정의 파일 Sample</title>

				<para>
					다음은 Query 서비스를 정의한 context-query.xml 과 Query 서비스에서 읽어들일 매핑 XML 파일의 위치를 정의한
					context-query-sqlloader.xml 파일의 일부이다.
					<programlisting language="xml"><![CDATA[<bean name="oracle_queryservice" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    <property name="lobHandler" ref="lobHandler"/>
    중략...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>
<bean id="nativeJdbcExtractor"
    class="org.springframework.jdbc.support.nativejdbc.CommonsDbcpNativeJdbcExtractor"
    lazy-init="true"/>
<bean id="lobHandler" class="org.springframework.jdbc.support.lob.OracleLobHandler"
        lazy-init="true">
    <property name="nativeJdbcExtractor" ref="nativeJdbcExtractor"/>
</bean>]]></programlisting>
				</para>

				<para>
					<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-lob.xml</filename>
        중략...
    </config:configuration>		
</bean>]]></programlisting>
				</para>
			</section>

			<section id="query_usecases_lob_oracle9i_xml">
				<title>매핑 XML 파일 Sample</title>

				<para>
					다음은 앞서 정의한 Query 서비스를 통해 로드된 mapping-query-lob.xml 파일의 일부로, 테이블 매핑 정보와 
					LOB 유형의 데이터를 다루는 다양한 쿼리문들을 포함하고 있다.
					<programlisting language="xml"><![CDATA[<queries>  		
    <query id="insertLOB">
        <statement>insert into longVarchar values(?,?,?)</statement>
        <param type="INTEGER"/>
        <param type="BLOB"/>
        <param type="CLOB"/>
    </query>
    <query id="selectLOB">
        <statement>select myblob, myclob from longVarchar where count = ?</statement>
        <param type="INTEGER"/>
    </query>
    <query id="updateLOB">
        <statement>update longVarchar set myblob = ?, myclob = ? WHERE count = ?</statement>
        <param type="BLOB"/>
        <param type="CLOB"/>
        <param type="INTEGER"/>
    </query>
    <query id="deleteLOB">
        <statement>delete from longVarchar WHERE count = ?</statement>
        <param type="INTEGER"/>
    </query>
</queries>]]></programlisting>
				</para>
			</section>

			<section id="query_usecases_lob_oracle9i_testcode">
				<title>테스트 코드 Sample</title>

				<para>
					다음은 앞서 언급한 매핑 XML 파일에 정의된 LOB 유형의 데이터를 INSERT, SELECT, UPDATE, DELETE하는 테스트 코드의 
					일부이다.
					<programlisting language="java">/**
 * Query 서비스를 통해 DB에 신규 LOB 유형의 데이터를 입력하는 테스트 코드
 */
public void insertLOB() {
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");

    String strVal1 = "0무궁화꽃이피었습니다";
    String strVal2 = "1무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이
                     피었습니다무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었습니다
                     무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었습니다\n";
    strVal2 += "2무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었습
               니다무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었
               습니다무궁화꽃이피었습니다무궁화꽃이피었습니다\n";
    // skip
    strVal2 += "30무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었
               습니다무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이피었습니다무궁화꽃이
               피었습니다무궁화꽃이피었습니다무궁화꽃이피었습니다\n";

    int result = <emphasis role="bold">queryService.create("insertLOB"
        , new Object[] { new Integer(5), strVal1.getBytes() , strVal2 });</emphasis>
    System.out.println("result : " + result);
}

/**
 * Query 서비스를 통해 DB에 입력된 LOB 유형의 데이터를 조회하는 테스트 코드
 */
public void selectLOB() {
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");

    <![CDATA[List<Map<String, byte[]>> result]]> = <emphasis role="bold">queryService.find("selectLOB", new Object[] { new Integer(5) });</emphasis>

    <![CDATA[Iterator<Map<String, byte[]>> resultItr]]> = result.iterator();
    while (resultItr.hasNext()) {
        <![CDATA[Map<String, byte[]> binary]]> = resultItr.next();
        String myCLOB = binary.get("myclob");
        String myBLOB = new String(binary.get("myblob"));
    }

    System.out.println("result : " + result);
}

/**
 * Query 서비스를 통해 DB에 입력된 LOB 유형의 데이터를 수정하는 테스트 코드
 */
public void updateLOB() {
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");

    String strVal1 =  "0장미꽃이피었습니다";
    String strVal2 = "1장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다
                     장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다
                     장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다\n";
    strVal2 += "2장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다
               장미꽃이피었습니다 장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다
               장미꽃이피었습니다장미꽃이피었습니다\n";
    // skip
    strVal2 += "30장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다
               장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다장미꽃이피었습니다
               장미꽃이피었습니다장미꽃이피었습니다\n";

    int result = <emphasis role="bold">queryService.create("updateLOB"
        , new Object[] { strVal1.getBytes() , strVal2,  new Integer(5)});</emphasis>
}

/**
 * Query 서비스를 통해 DB에 입력된 LOB 유형의 데이터를 삭제하는 테스트 코드
 */
public void deleteLOB() {
	QueryService queryService = (QueryService) context.getBean("oracle_queryservice");
	<emphasis role="bold">queryService.remove("deleteLOB", new Object[]{new Integer(5)});</emphasis>
}						</programlisting>
					</para>
        		</section>
      		</section>

		<section id="query_usecases_lob_oracle8i">
        	<title>Oracle 8i일 경우</title>

        	<section id="query_usecases_lob_oracle8i_attribute">
          		<title>속성 정의 파일 Sample</title>

          		<para>
          			Spring에서 제공하는 Oracle LobHandler는 9i 이상에서만 적용 가능하므로, Oracle 8i 기반에서 LOB 유형의 데이터를 
          			다루기 위해서는 Query 서비스 속성 정의시에 Anyframe에서 제공하는 LobHandler를 셋팅해 주어야 한다. 다음은 Query 
          			서비스를 정의한 context-query.xml 파일의 일부로, Oracle 8i용으로 제공된 Oracle8iLobHandler를 정의한 
          			부분이다. 
          			<programlisting language="xml"><![CDATA[<bean id="lobHandler" class="org.anyframe.query.impl.jdbc.lob.Oracle8iLobHandler"
        lazy-init="true">
    <constructor-arg value="net.sf.log4jdbc.ResultSetSpy"/>
    <property name="nativeJdbcExtractor" ref="nativeJdbcExtractor"/>
</bean>]]></programlisting>
				</para>

          		<para>
          			DriverSpy를 써서 실행되는 쿼리문을 로그로 남기고 있을 경우에는 LobHandler의 <![CDATA[<constructor-arg>]]>를 정의하고, 
          			아닐 경우에는 제거해도 된다.
          		</para>
        	</section>

			<section id="query_usecases_lob_oracle8i_datasourece">
          		<title>DataSource 서비스 속성 정의 파일 Sample</title>

          		<para>
          			반드시 defaultAutoCommit의 속성을 false로 변경한다. 
          			<programlisting language="xml"><![CDATA[<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
            destroy-method="close">
    <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
    <property name="url" value="jdbc:oracle:thin:@localhost:1521:oracle"/>
    <property name="username" value="system"/>
    <property name="password" value="manager"/>
    <]]><emphasis role="bold">property name="defaultAutoCommit" value="false"/</emphasis><![CDATA[>     
</bean>]]></programlisting>
				</para>
        	</section>

        	<section id="query_usecases_lob_oracle8i_transaction">
          			<title>TransactionManager 속성 정의 파일 Sample</title>

          			<para>
          				DataSource 서비스의 defaultAutoCommit 속성을 false로 설정했으므로, TransactionManager 셋팅이 필요하다. 
          				<programlisting language="xml"><![CDATA[<bean id="txManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
        <tx:method name="*" propagation="REQUIRES_NEW"
            rollback-for="Exception" />
    </tx:attributes>
</tx:advice>

<aop:config>
    <aop:pointcut id="executionMethods"
        expression="execution(* org.anyframe.query..impl.QueryServiceImpl.*(..))" />
    <aop:advisor advice-ref="txAdvice"
        pointcut-ref="executionMethods" />
</aop:config>]]></programlisting></para>
			</section>

			<section id="query_usecases_lob_oracle8i_xml">
          		<title>매핑 XML 파일 Sample</title>

          		<para>
          			신규 LOB 유형의 데이터를 INSERT하는 쿼리문의 경우에는 기존 쿼리문 정의와 다르게 lobStatement
          			tag를 추가 정의해 주어야 한다. 
          			<programlisting language="xml"><![CDATA[<query id="insertBlobClobWithOra8i" isDynamic="false">
    <statement>insert into binary values(?,empty_blob(),empty_clob())</statement>
    <param  type="INTEGER"/>
    <]]><emphasis role="bold">lobStatement</emphasis><![CDATA[>
        <statement>select  myclob, myblob
            from binary where bin_id = ? for update</statement>
        <param type="INTEGER"/>
    <]]><emphasis role="bold">/lobStatement</emphasis><![CDATA[>                                                 
</query>]]></programlisting>
				</para>
			</section>
		</section>
	</section>

	<section id="query_usecases_vo">
		<title>Named Parameter 'vo' 활용</title>

		<para>
			매핑 XML 파일에 정의되어 있는 쿼리문을 실행시키기 위해 필요한 입력 Parameter들을 Query 서비스에 전달할
			때, 개별 Parameter들을 포함하고 있는 VO 유형의 객체로 전달 가능하다. 따라서 입력 Parameter 개수나 이름이
			변경되더라도, Query 서비스 사용 로직의 변경없이 매핑 XML 내의 해당되는 쿼리문만 변경함으로써 변경 사항 적용이 
			가능해지므로 쿼리문 변경이 용이해지는 장점을 제공한다.</para>

		<section id="query_usecases_vo_attribute">
			<title>속성 정의 파일 Sample</title>

			<para>
				다음은 Query 서비스를 정의한 context-query.xml 과 Query 서비스에서 읽어들일 매핑 XML 파일의 위치를 정의한
				context-query-sqlloader.xml	파일의 일부이다.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    중략...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>
			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-namedparamvo.xml</filename>
        중략...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_vo_xml">
			<title>매핑 XML 파일 Sample</title>

			<para>
				다음은 앞서 정의한 Query 서비스를 통해 mapping-query-namedparamvo.xml 로, Named Parameter로 전달된 'vo'를 
				활용한 다양한 쿼리문들을 포함하고 있다. Parameter명이 'vo'인 객체로부터 . 뒤에 붙은 이름에 대한 getter 메소드를 
				호출한 결과를 PreparedStatement에 셋팅한 후, 해당 쿼리문을 실행하게 된다.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="insertCategory">
            <statement>
                INSERT INTO TBL_CATEGORY 
                    (CATEGORY_NO, CATEGORY_NAME, CATEGORY_DESC, USE_YN, REG_ID, 
                    REG_DATE, MODIFY_ID, MODIFY_DATE) 
                VALUES (]]><emphasis role="bold">:vo.categoryNo, :vo.categoryName, :vo.categoryDesc, 
                    :vo.useYn, :vo.regId, sysdate, :vo.regId, sysdate</emphasis><![CDATA[)
            </statement>
        </query>
        <query id="updateCategory">
            <statement>
                UPDATE TBL_CATEGORY  
                SET CATEGORY_NAME =]]> <emphasis role="bold">:vo.categoryName,</emphasis> 
                    <emphasis role="bold">CATEGORY_DESC = :vo.categoryDesc, 
                    USE_YN =:vo.useYn, MODIFY_ID = :vo.modifyId,
                    MODIFY_DATE = sysdate</emphasis><![CDATA[
                WHERE CATEGORY_NO = ]]><emphasis role="bold">:vo.categoryNo</emphasis><![CDATA[
            </statement>
        </query>
        <query id="deleteCategory">
            <statement>
                delete from TBL_CATEGORY where CATEGORY_NO = ]]><emphasis role="bold">:vo.categoryNo</emphasis><![CDATA[
            </statement>
        </query>
        <query id="findCategoryList">
            <statement>
                SELECT CATEGORY_NO, CATEGORY_NAME, CATEGORY_DESC, USE_YN, REG_ID
                FROM TBL_CATEGORY
                WHERE CATEGORY_NO like ]]><emphasis role="bold">:vo.categoryNo</emphasis><![CDATA[
            </statement>
            <result class="org.anyframe.sample.domain.Category"></result>
        </query>
        <query id="findCategory">
            <statement>
                SELECT CATEGORY_NO, CATEGORY_NAME, CATEGORY_DESC, USE_YN, REG_ID
                FROM TBL_CATEGORY
                WHERE CATEGORY_NO = ]]><emphasis role="bold">:vo.categoryNo</emphasis><![CDATA[
            </statement>
            <result class="org.anyframe.sample.domain.Category"></result>
        </query>					
    </queries>
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_vocode_test">
			<title>테스트 코드 Sample</title>

			<para>
				다음은 앞서 언급한 매핑 XML 파일에 정의된 INSERT, SELECT, UPDATE, DELETE 쿼리문을 실행하는 테스트 코드의  
				일부이다. Query 서비스에 입력 Parameter 전달시 'vo'라는 
				Parameter명에 Category 또는 SearchVO 객체를 매핑시키고 있음을 알 수 있다.
				<programlisting language="java">/**
 * QueryService에 특정 쿼리의 입력 Parameter값을 전달할 때, named parameter 형태로 transfer
 * object를 전달한다. QueryService에서는 전달받은 객체의 getter 메소드를 호출하여 INSERT
 * 쿼리문의 Parameter값을 셋팅하고 실행한다.
 */
public Category testInsertCategory() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    Category category = makeCategory();
    
    Object[] args = new Object[] { "vo", category };
    int result = queryService.create("insertCategory",
        new Object[] { args });

    if (result != 1) {
        throw new Exception("Insert a new category failed");
    }

    return category;
}

/**
 * QueryService에 특정 쿼리의 입력 Parameter값을 전달할 때, named parameter 형태로 transfer
 * object를 전달한다. QueryService에서는 전달받은 객체의 getter 메소드를 호출하여 UPDATE
 * 쿼리문의 Parameter값을 셋팅하고 실행한다.
 */
public void updateCategory(Category category) throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
    category.setCategoryName("testUpdate");

    Object[] args = new Object[] { "vo", category };
    int result = queryService.update("updateCategory",
        new Object[] { args });

    if (result != 1) {
        throw new Exception("Update category failed");
    }
}

/**
 * QueryService에 특정 쿼리의 입력 Parameter값을 전달할 때, named parameter 형태로 transfer
 * object를 전달한다. QueryService에서는 전달받은 객체의 getter 메소드를 호출하여 DELETE
 * 쿼리문의 Parameter값을 셋팅하고 실행한다.
 */
public void deleteCategory(Category category) throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    Object[] args = new Object[] { "vo", category };
    int result = queryService.remove("deleteCategory",
        new Object[] { args });

    if (result != 1) {
        throw new Exception("Delete category failed");
    }

    args = new Object[] { "vo", category };
    <![CDATA[List<Category> rtCollection]]> = queryService.find("findCategory",
        new Object[] { args });

    if (rtCollection.size() != 0) {
        throw new Exception("Find categorylist failed");
    }
}

/**
 * QueryService에 특정 쿼리의 입력 Parameter값을 전달할 때, named parameter 형태로 transfer
 * object를 전달한다. QueryService에서는 전달받은 객체의 getter 메소드를 호출하여 SELECT
 * 쿼리문의 Parameter값을 셋팅하고 실행한다.
 */
public void findCategory(String categoryNo, String categoryName)
		throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    Category searchVO = new Category();
    searchVO.setCategoryNo(categoryNo);

    Object[] args = new Object[] { "vo", searchVO };
    <![CDATA[List<Category> rtCollection]]> = queryService.find("findCategory",
        new Object[] { args });

    if (rtCollection.size() != 1) {
        throw new Exception("Find category failed");
    }

    Category category = rtCollection.iterator().next();
    if (!(categoryNo.equals(category.getCategoryNo()) &amp;&amp; categoryName
        .equals(category.getCategoryName()))) {
        throw new Exception("Find category failed");
    }
}</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_dao">
		<title>extends QueryServiceDaoSupport</title>

		<para>
			일반적으로 Dao(Data Access Object) 클래스에서는 Query 서비스를 활용하여 데이터 접근 로직을 처리한다. 
			Query 서비스에서는 이러한 Dao 클래스를 간편하게 개발할 수 있도록 하기 위해 org.anyfram.query.dao.QueryServiceDaoSupport 클래스를 
			제공하고 있으며 다음과 같은 특징을 지닌다.
		</para>

		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold">입력 Parameter를 VO, Map, List, Object[] 형태에 담아 처리할 수 있다.</emphasis>
				</para>

				<para>
					입력된 Parameter는 Named Parameter로 처리되기 때문에 VO의 Map, VO의 ArrayList 등에 대한 
					처리도 가능해진다. 따라서 Dao 코드가 단순해질 수 있게 된다.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">단건 데이터 조회 결과 처리를 위해 필요한 공통 로직을 수행한다.</emphasis>
				</para>

				<para>
					Query 서비스의 find(), findBySQL() 메소드를 호출하면 SELECT문 실행 결과를 Collection 객체에 담아 전달한다. 
					따라서 조회 결과가 단건인 경우 Collection으로부터 단건 데이터를 꺼내서 전달하는 로직이 추가되어야 한다.
					<programlisting language="java">if (collection == null || collection.size() == 0)
    return null;
return collection.iterator().next();</programlisting>
				</para>

				<para>
					QueryServiceDaoSupport에서 제공하는 findByPk(...) 메소드를 호출하면 위에서 언급한 추가 로직을 중복
					구현하지 않고 단건 데이터를 얻을 수 있게 된다.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">UI 개발 편의를 위해서 다건 데이터 조회 결과를 별도의 Page 객체에 저장하는 로직을 
					수행한다.</emphasis>
				</para>

				<para>
					Query 서비스의 findWithRowCount() 메소드를 호출하면, SELECT문 실행 결과를 Map 객체에 담아 전달하며, 
					개발자는 UI 개발 편의를 위해 Map 객체로부터 필요한 데이터를 추출하여 별도의 Page 객체에 담기 위한 로직을 
					추가해야 한다.
					<programlisting language="java">List resultList = (List)queryMap.get(QueryService.LIST);
int totalSize = ((Long) queryMap.get(QueryService.COUNT)).intValue();
return new Page(resultList, (new Integer(pageIndex)).intValue(),
    totalSize, pageUnit, pageSize);</programlisting>
				</para>

				<para>
					QueryServiceDaoSupport에서 제공하는 findListWithPaging() 메소드를 호출하면 위에서 언급한 추가 로직을 중복 구현하지 않고도 
					org.anyframe.pagination.Page 형태의 객체를 얻을 수 있게 된다.</para>
			</listitem>
		</itemizedlist>
		
		<note>
			<title>AbstractDao Deprecated</title>
			<para>
				Query 서비스 1.1.2 버전 까지 제공하던 AbstractDao 클래스는 1.1.3 버전에서 deprecated 되었다. 1.1.3 버전 부터는 AbstractDao 클래스 대신 QueryServiceDaoSupport 를 사용하도록한다.
				변경된 사항은 기존의 AbstractDao 클래스의 경우 메소드의 첫번째 인자로 table name을 받아 정의된 prefix, postfix를 조합하여 query id를 생성하는 방식을 사용하였다.
				QueryServiceDaoSupport 클래스에서는 기존 방식의 불편함을 없애기 위해 query id를 바로 인자로 받도록 수정 했다. 또한 batchUpdate 메소드를 추가로 제공하여 batch 처리를 좀 더 쉽게
				할 수 있도록 하고 있다.
			</para>
		</note>

		<section id="query_usecases_dao_xml">
			<title>매핑 XML 파일 Sample</title>

			<para>
				다음은 Query 서비스를 통해 로드된 mapping-query-queryservicedaosupport.xml 파일의 일부로, Named Parameter를 포함한 
				다양한 쿼리문들을 포함하고 있다.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="]]><emphasis role="bold">createProduct</emphasis><![CDATA[">
            <statement>
                INSERT INTO PRODUCT 
                    ( PROD_NO, PROD_NAME, SELLER_ID, CATEGORY_NO, PROD_DETAIL, 
                    MANUFACTURE_DAY, AS_YN, SELL_QUANTITY, SELL_AMOUNT, IMAGE_FILE, 
                    REG_DATE ) 
                VALUES (:vo.prodNo, :vo.prodName, :vo.sellerId, :vo.category.categoryNo, 
                    :vo.prodDetail, :vo.manufactureDay, :vo.asYn, :vo.sellQuantity, 
                    :vo.sellAmount, :vo.imageFile, sysdate)
            </statement>
        </query>

        <query id="]]><emphasis role="bold">updateProduct</emphasis><![CDATA[">
            <statement>
                UPDATE PRODUCT 
                SET PROD_NAME = :vo.ProdName,
                    PROD_DETAIL = :vo.prodDetail,
                    MANUFACTURE_DAY = :vo.manufactureDay,
                    AS_YN = :vo.asYn,
                    SELL_QUANTITY = :vo.sellQuantity,
                    SELL_AMOUNT = :vo.sellAmount,
                    REG_DATE = sysdate
                WHERE PROD_NO = :vo.ProdNo
            </statement>
        </query>

        <query id="]]><emphasis role="bold">findProductByPk</emphasis><![CDATA[">
            <statement>
                SELECT	PROD_NO, PROD_NAME, SELLER_ID, CATEGORY_NO, PROD_DETAIL, 
                    MANUFACTURE_DAY, AS_YN, SELL_QUANTITY, SELL_AMOUNT, IMAGE_FILE, 
                    REG_DATE 
                FROM PRODUCT
                WHERE PROD_NO = :vo.ProdNo
            </statement>
            <result class="org.anyframe.sample.domain.Product">
                <result-mapping column="{CATEGORY_NO}" attribute="{category.categoryNo}" />
            </result>
        </query>

        <query id="]]><emphasis role="bold">removeProduct</emphasis><![CDATA[">
            <statement>
                DELETE FROM PRODUCT 
                WHERE PROD_NO = :vo.prodNo
            </statement>
        </query>

        <query id="]]><emphasis role="bold">findProductList</emphasis><![CDATA[">
            <statement>
                SELECT product.PROD_NO, product.PROD_NAME, product.SELLER_ID, 
                    product.CATEGORY_NO, product.PROD_DETAIL, product.MANUFACTURE_DAY, 
                    product.AS_YN, product.SELL_QUANTITY, product.SELL_AMOUNT, 
                    product.IMAGE_FILE, product.REG_DATE 
                FROM PRODUCT product 
                WHERE 
                    product.PROD_NAME like :vo.prodName
                    AND product.AS_YN = :vo.asYn
                ORDER BY product.PROD_NO DESC
            </statement>
            <result class="org.anyframe.sample.domain.Product">
                <result-mapping column="{CATEGORY_NO}" attribute="{category.categoryNo}" />
            </result>
        </query>
    </queries>
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_dao_classcode">
			<title>Dao 클래스 코드 Sample</title>

			<para>
				다음은 QueryServiceDaoSupport를 상속받아 구현한 ProductDaoImpl.java 클래스의 일부이다. QueryServiceDaoSupport에서 제공하는 메소드를 
				호출함으로써 Product 정보를 INSERT, UPDATE, DELETE, SELECT하는 역할을 수행하는ProductDaoImpl 로직이 보다 
				간단해졌음을 알 수 있을 것이다. QueryServiceDaoSupport 클래스를 상속받은 경우 Query 서비스의 API를 직접 호출하려면 
				getQueryService() 메소드 호출을 통해 Query 서비스를 얻어내어 활용하면 된다.
				<programlisting language="java">public class ProductDaoImpl <emphasis
              role="bold">extends QueryServiceDaoSupport</emphasis> {
    // <emphasis role="bold">query id가 'createProduct'인 INSERT문을 실행</emphasis>
    public int createProduct(Product vo) {
        return <emphasis role="bold">super.create("createProduct", vo);</emphasis>
    }

    // <emphasis role="bold">query id가 'deleteProduct'인 DELETE문을 실행</emphasis>
    public int deleteProduct(Product vo) {
        return super.remove("deleteProduct", vo);
    }

    // <emphasis role="bold">query id가 'findProductByPk'인 SELECT문을 실행하고 </emphasis>
    // <emphasis role="bold">조회 결과인 Product 객체를 전달 </emphasis>
    public Product selectProduct(String prodNo) {
        Product vo = new Product();
        vo.setProdNo(prodNo);
        <emphasis role="bold">Product resultVo = super.findByPk("findProductByPk", vo);</emphasis>
        return resultVo;
    }

    // <emphasis role="bold">query id가 'findProductList'인 SELECT문을 실행하고</emphasis> 
    // <emphasis role="bold">조회 결과인 Page 객체를 전달</emphasis>
    public Page selectProductList(Product vo, int pageIndex, int pageSize,
        int pageUnit) {
        return <emphasis role="bold">super.findListWithPaging("findProductList", vo, pageIndex,</emphasis>
                <emphasis role="bold">pageSize, pageUnit);</emphasis>
    }

    // <emphasis role="bold">query id가 'updateProduct'인 UPDATE문을 실행</emphasis>
    public int updateProduct(Product vo) {
        return <emphasis role="bold">super.update("updateProduct", vo);</emphasis>
    }
}</programlisting>
			</para>
		</section>

		<section id="query_usecases_dao_attribute">
			<title>Dao 클래스 속성 정의 파일 Sample</title>

			<para>
				다음은 QueryServiceDaoSupport 클래스를 상속받은 ProductDaoImpl 클래스의 속성을 정의한 context-service.xml 파일의 
				일부이다. QueryServiceDaoSupport 클래스에서 내부적으로 Query 서비스를 사용하므로 Query 서비스의 Bean Id를 속성으로 
				셋팅해주도록  한다.
				<programlisting language="xml"><![CDATA[<bean id="productDao" class="org.anyframe.sample.query.sales.dao.impl.ProductDaoImpl">
    <property name="queryService" ref="queryService" />
    <property name="propertiesService" ref="propertiesService" />
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_dao_testcode">
			<title>Dao 클래스 테스트 코드 Sample</title>

			<para>
				다음은 앞서 언급한 매핑 XML 파일에 정의된 INSERT, SELECT, UPDATE, DELETE 쿼리문을 실행하는 테스트 코드의  
				일부이다.
					
				<programlisting language="java">/**
 * QueryServiceDaoSupport를 통해 DB에 신규 데이터를 입력하는 테스트 코드
 */
public void insertProduct() throws Exception {
    Category category = categoryService.get("CATEGORY-00004");
    Product product = new Product();
    product.setProdName("sample.sportsone");
    product.setCategory(category);
    product.setProdDetail("sports one detail");
    product.setSellerId("woos41");
    product.setAsYn("Y");
    product.setManufactureDay("20081225");
    product.setSellAmount(new Long(50));
    product.setSellQuantity(new Long(50));
    
	// 매핑 XML 파일에 정의되어 있는 query id를 이용하여 INSERT를 실행한다.
    <emphasis role="bold">productDao.create(product);</emphasis>
}

/**
 * QueryServiceDaoSupport를 통해 DB에 입력된 데이터를 조회하는 테스트 코드
 */
public void selectProduct(String prodNo) throws Exception {
    // 매핑 XML 파일에 정의되어 있는 query id를 이용하여 SELECT를 실행한다.
    Product vo = <emphasis role="bold">productDao.get(prodNo);</emphasis>
}

/**
 * QueryServiceDaoSupport를 통해 DB에 입력된 데이터를 페이징 처리하기 위한 테스트 코드
 */
public void selectProductList() throws Exception {
    ProductSearchVO searchVO = new ProductSearchVO();
    searchVO.setSearchCondition("0");
    searchVO.setSearchKeyword("sample.sportsone");
    searchVO.setPageIndex(1);
    searchVO.setPageSize(2);
    
    // 매핑 XML 파일에 정의되어 있는 query id를 이용하여 SELECT를 실행하고,
    // 페이징 처리된 실행 결과를 얻는다.
    Page <emphasis role="bold">products = productDao.getPagingList(searchVO);</emphasis>
}

/**
 * QueryServiceDaoSupport를 통해 DB에 입력된 데이터를 수정하는 테스트 코드
 */
public void updateProduct(Product product) throws Exception {
    // 매핑 XML 파일에 정의되어 있는 query id를 이용하여 UPDATE를 실행한다.
    product.setProdName("sportsone-update");
    product.setProdDetail("sports one detail-update");
    
    <emphasis role="bold">productDao.update(product);</emphasis>
}

/**
 * QueryServiceDaoSupport를 통해 DB에 입력된 데이터를 삭제하는 테스트 코드
 */
public void deleteProduct(String prodNo) throws Exception {
    // 매핑 XML 파일에 정의되어 있는 query id를 이용하여 DELETE를 실행한다.
    <emphasis role="bold">productDao.remove(prodNo);</emphasis>
}					</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_resultsetmapper">   
		<title>implements ResultSetMapper</title>

		<para>
			일반적으로 Query 서비스는 매핑 XML 파일에 정의되어 있는 쿼리문을 실행한 후, 그 실행 결과를 <![CDATA[<result>]]> 
			내에 정의된 객체나 HashMap에 담아 전달한다. 그런데 실행 결과를 <![CDATA[<result>]]> 내에 정의된 객체에 담기 위해서는 
			Java Reflection API 호출이 발생하므로 대량의 데이터를 처리할 때 성능 저하가 예상된다. 또한 실행 결과를 HashMap에 담는 
			경우에는 Java Reflection API 호출없이, 칼럼명을 키값으로 하여 칼럼값을 셋팅하나 특정 메소드 호출을 통해 주고 받는 데이터가 
			명확히 식별되지 않게 되어 	어플리케이션 분석 및 변경시 불리할 수 있다. QueryService에서는 이러한 점을 보완하기 위해서
			ResultSetMapper 실행을 지원한다. 즉, 쿼리문 실행 결과 처리를 Query 서비스에 위임하지 않고, 별도 구현된 ResultSetMapper를 
			통해 직접 처리할 수 있도록 지원한다.
		</para>

		<section id="query_usecases_resultsetmapper_attribute">
			<title>속성 정의 파일 Sample</title>

			<para>
				다음은 Query 서비스를 정의한 context-query.xml 과 Query 서비스에서 읽어들일 매핑 XML 파일의 위치를 정의한
				context-query-sqlloader.xml 파일의 일부이다.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    중략...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-resultsetmapper.xml</filename>
        중략...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_resultsetmapper_xml">
			<title>매핑 XML 파일 Sample</title>

			<para>
				다음은 앞서 정의한 Query 서비스를 통해 로드된 mapping-query-resultsetmapper.xml의 일부로, 쿼리문을 포함하고 있다. 
				Query Id가 findCustomerWithResultSetMapper인 쿼리문 실행 결과는 사용자가 정의한 
				org.anyframe.sample.query.CustomerMapper를 통해 처리되도록 정의하고 있음을 알 수 있다.
				<programlisting language="xml"><![CDATA[<queries>  		
    <query id="findCustomerWithResultSetMapper" isDynamic="false">
        <statement>select NAME, ADDRESS from TB_CUSTOMER where SSNO like ?</statement>
        <param type="VARCHAR"/>
        <result ]]><emphasis role="bold">mapper="org.anyframe.sample.query.CustomerMapper"</emphasis><![CDATA[/>
    </query>
</queries>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_resultsetmapper_code">
			<title>ResultSetMapper 코드 Sample</title>

			<para>
				사용자는 다음과 같은 순서로 ResultSetMapper를 구현하면 된다.
			</para>

			<orderedlist>
				<listitem>
					<para>
						Query 서비스에서 제공하는 인터페이스 org.anyframe.query.ResultSetMapper를
						implements한 클래스 정의
					</para>
				</listitem>
				<listitem>
					<para>
						ResultSet을 입력 인자로 하는 콜백 메소드 mapRow() 정의
					</para>
				</listitem>
				<listitem>
					<para>
						maprRow() 메소드 내에서 ResultSet을 이용하여 원하는 객체에 실행 결과 셋팅하고 
						실행 결과를 return
					</para>
				</listitem>
			</orderedlist>

			<para>
				다음은 앞서 언급한 매핑 XML 파일에 정의된  CustomerMapper.java의 일부이다.
				<programlisting language="java">public class CustomerMapper <emphasis
              role="bold">implements ResultSetMapper</emphasis> {

    <emphasis role="bold">public Customer mapRow(ResultSet resultSet) throws SQLException</emphasis> {
        Customer customer = new Customer();
        customer.setNm(resultSet.getString("name"));
        customer.setAddr(resultSet.getString("address"));
        return customer;
    }
}</programlisting>
			</para>
		</section>

		<section id="query_usecases_resultsetmapper_testcode">
			<title>테스트 코드 Sample</title>

			<para>
				다음은 앞서 언급한 매핑 XML 파일에 정의된 SELECT 쿼리문을 실행하는 테스트 코드의 
				일부이다.
				<programlisting language="java">/**
 * QueryService의 find() 메소드를 호출하여 매핑 XML에 정의된 쿼리문을 실행시키고, 매핑 XML에 정의된
 * ResultSetMapper 유형의 Mapper를 이용하여, 결과값이 매핑되는지 체크하기 위한 테스트 코드
 */
public void findWithCustomResultSetMapper() throws Exception {
    QueryService queryService = (QueryService) context
            .getBean("queryService");

    // execute query
    <![CDATA[List<Customer> rtList]]> = queryService.find(
            "findCustomerWithResultSetMapper", new Object[] { "%123456%" });
    // assert a size of result
    if (rtList.size() != 3)
        throw new Exception("Fail to select with custom ResultSetMapper.");

    // assert in detail
    <![CDATA[Iterator<Customer> resultItr]]> = rtList.iterator();
    while (resultItr.hasNext()) {
        Customer customer = resultItr.next();
        if (!customer.getAddr().equals("Seoul"))
            throw new Exception("Fail to compare result in defail.");
    }
}</programlisting>
			</para>
		</section>
	</section>
</chapter>
