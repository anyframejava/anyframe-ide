<chapter id="query_usecases">
	<title>Usecases</title>
	<para>
		This page will describe how to use Query service variously.
		For more details, refer to each use case listed below.
		(This page covers use cases which handles defined mapping information in XML files 
		using org.anyframe.query.impl.config.loader.MappingXMLLoader.)		
	</para>

	<section id="query_usecases_resultmapping">
		<title>Result Mapping</title>

		<para>
			The following are ways of mapping execution result onto specific object
			after performing list search through Query service.
		</para>

		<section id="query_usecases_resultmapping_case1">
			<title>When search result mapping is not defined</title>
				
			<para>
				For search result mapping, when <![CDATA[<table-mapping/>]]>, <![CDATA[<result-mapping/>]]>
				is not defined, the execution result is returned ArrayList type.
				ArrayList is composed of map contained by row. 
				The search result can be gotten through calling get("column name") method from each Map.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="selectGeneral" isDynamic="false">
            <statement>
                SELECT * FROM TBL_CUSTOMER WHERE SSNO like ?
            </statement>
            <param type="VARCHAR" />
        </query>
    </queries>
</queryservice>]]></programlisting>
			</para>	
		</section>	
			
		<section id="query_usecases_resultmapping_case2">
			<title>When using <![CDATA[<table-mapping>]]> without <![CDATA[<result-mapping>]]></title>					

			<para>
				Used when defining mapping information between specific class and single table.
				If mapping information is defined, when mapping the search result of a specific SQL statement,
				XML definition will become much simpler as only the class name will be defined in <![CDATA[<result>]]>
				without separate <![CDATA[<result-mapping>]]>.
				In addition, using <![CDATA[<table-mapping>]]> enables INSERT/UPDATE/DELETE/SELECT single data
				with object only, without any SQL statement.
				Like <![CDATA[<result class="anyframe.sample.domain.Customer"/>]]>,
				by using the class defined in table mapping,
				execution result will be saved by calling setter method of the class
				and result can be gotten by calling getter method.
				<programlisting language="xml"><![CDATA[<queryservice>
    <table-mapping>
        <table name="TBL_CUSTOMER"
            ]]><emphasis role="bold">class="anyframe.sample.domain.Customer"</emphasis><![CDATA[>
            <field-mapping>
                <dbms-column>ssno</dbms-column>
                <class-attribute>ssno</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>name</dbms-column>
                <class-attribute>nm</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>address</dbms-column>
                <class-attribute>addr</class-attribute>
            </field-mapping>
            <primary-key>
                <dbms-column>ssno</dbms-column>
            </primary-key>
        </table>
    </table-mapping>
    <queries>
        <query id="select" isDynamic="false">
            <statement>
                SELECT * FROM TBL_CUSTOMER WHERE SSNO like ?
            </statement>
            <param type="VARCHAR" />
            <]]><emphasis role="bold">result class="anyframe.sample.domain.Customer"</emphasis><![CDATA[/>
        </query>
    </queries>
</queryservice>]]>	</programlisting>
			</para>				
		</section>
			
		<section id="query_usecases_resultmapping_case3">
			<title>When using only <![CDATA[<result>]]> without <![CDATA[<table-mapping>]]>,<![CDATA[<result-mapping>]]></title>	
				
			<para>
				If attribute name of mapping class and column name is the same or 
                attribute name of mapping  class and camel-cased column name is the same,
                mapping is not needed through  <![CDATA[<table-mapping>]]> or <![CDATA[<result-mapping>]]>.
	            In other words, find column name mapping onto the searched column name
                according to value of isCamelCase, mappingStyle property.
			    (For example, if value of mappingStyle is 'camel' and searched column name is USER_NAME,
				mapping attribute name is userName.)
		       </para>
	            
			<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="getUser" isDynamic="false">
            <statement>
                SELECT USER_ID, USER_NAME, PASSWORD, SSN, SL_YN, 
                    BIRTH_DAY, AGE, CELL_PHONE, ADDR, EMAIL, EMAIL_YN, 
                    IMAGE_FILE, REG_DATE
                FROM USERS
                WHERE USER_ID = ?
            </statement>
            <param type="VARCHAR" />
            <]]><emphasis role="bold">result class="anyframe.sample.domain.User"/</emphasis><![CDATA[>
        </query>
    </queries>
</queryservice>]]></programlisting>	   

			<para>
				* When mapping the search result from performing SQL statement, 
				Query service internally searches mapping standard in the following order.
			</para>

			<orderedlist>
				<listitem>
					<para>
						If defined <![CDATA[<result-mapping>]]> exists, mapping is based on this.
					</para>
				</listitem>
				<listitem>
					<para>
						If  <![CDATA[<table-mapping>]]> on the defined <![CDATA[<result>]]> class exists, mapping is based on this.
					</para>
				</listitem>

				<listitem>
					<para>
						If information on the defined <![CDATA[<result>]]> class exists, mapping is based on this.
					</para>
				</listitem>

				<listitem>
					<para>
						Mapping based on mappingStyle, isCamelCase property value in HashMap.
					</para>
				</listitem>
			</orderedlist>    
		</section>     
	            
		<section id="query_usecases_resultmapping_case4">
			<title>When using <![CDATA[<result-mapping>]]></title>	
	                        
			<para>
			    <![CDATA[<result-mapping>]]> is a class undefined in <![CDATA[<table-mapping>]]>
				and used when separate mapping is needed as the column name and the attribute name is not related.
				Perform one to one mapping between column name and attribute name in <![CDATA[<result-mapping>]]>.
				It will be saved through class setter calling defined in <![CDATA[<result>]]>
				and the result value can be gotten through getter calling.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="selectUsingResultMapping" isDynamic="false">
            <statement>SELECT * FROM TBL_CUSTOMER WHERE SSNO like ?</statement>
            <param type="VARCHAR"/>
            <]]><emphasis role="bold">result class="anyframe.sample.domain.CompositionCustomer"</emphasis><![CDATA[>
                <]]><emphasis role="bold">result-mapping column="NAME" attribute="nm"/</emphasis><![CDATA[>
                <]]><emphasis role="bold">result-mapping column="ADDRESS" attribute="addr"/</emphasis><![CDATA[>
            </result>
        </query>
    </queries>
</queryservice>]]></programlisting>
			</para>	  			
		</section>    
			
		<warning>
			<title>Notes for using Result Mapping</title>
			<para>
				<itemizedlist>
					<listitem>
						<para>
							Among columns searched by SELECT statement,
							when mapping is not performed through <![CDATA[<result-mapping>]]>,
							basically use mappingStyle to perform mapping.
							If attribute name that fits mappingStyle in the defined result class does not exist, mapping is not performed.
						</para>
					</listitem>
					<listitem>
						<para>
							If result class is a composite object containing other user defined object,
							in case of object, when defining mapping information between column and attribute, 
							mapping information can be defined in {} using , as delimiter. 
							But when defining attribute, the variable name of the internal object should not be changed.
						</para>
						<para>
							Remember that table for successfully mapping query execution result in Result class 
							should not include column named ID.
						</para>
						<programlisting language="xml"><![CDATA[<query id="findWithCompositeResultMapping">
    <statement>
        select grp.GROUP_ID, grp.GROUP_NAME, cd.CODE_ID, cd.CODE_NAME,
               cd.CODE_DESC, cd.CODE_USE_YN
        from TB_CODE_GROUP grp, TB_CODE cd
        where grp.GROUP_ID = cd.GROUP_ID and cd.GROUP_ID = :groupId 
    </statement>
    <result class="anyframe.core.query.vo.LocalResultMappingVO">
        <result-mapping column="{ GROUP_ID, GROUP_NAME }"
                attribute="{ group.groupId, group.codeNm }" />
        <result-mapping attribute="codeID" column="CODE_ID" />
        <result-mapping attribute="codeDescription" column="CODE_DESC" />
    </result>
</query>]]></programlisting>
						<para>
							According to the query definition above, 
							'findWithCompositeResultMapping' execution results will be returned by being contained in LocalResultMappingVO object. 
							In this case, GROUP_ID and GROUP_NAME column value are each mapped in groupId and codeNm of object that is related to 'group' member variable. 
							So, to extract GROUP_ID and GROUP_NAME value from returned LocalResultMappingVO, 
							call LocalResultMappingVO.getGroup().getGroupId(),LocalResultMappingVO.getGroup().getCodeNm().
						</para>
						<para>
						 	The following is a part of LocalResultMappingVO object that includes CodeVO object.
						</para>
							<programlisting language="java">public class LocalResultMappingVO implements Serializable {
    private String groupID;
    private String groupName;
    private String codeID;
    private String codeName;
    private String codeDescription;
    private String codeUseYn;
    <emphasis role="bold">private CodeVO group;</emphasis>
    
    // getter, setter...
}</programlisting>
					</listitem>
				</itemizedlist>
			</para>
		</warning>				      
	            				
		<section id="query_usecases_resultmapping_case5">
			<title>Test code Sample</title>

			<para>
				The following is a part of test code executing SQL statement defined in the above-mentioned mapping XML file.
				<programlisting language="java">/**
				* Test code searching for data inserted in DB through Query service
				*/
				public void selectCustomer() {
				QueryService queryService = (QueryService) context.getBean("queryService");

				//find() : By using query id defined in mapping XML file, execute SELECT.
						
				//When result mapping is not defined

    <![CDATA[List<Map<String, Object>> rsquery]]>  = <emphasis role="bold">queryService
                                 .find("selectGeneral", new Object[] { "%12345%" });</emphasis>
    <![CDATA[Map<String, Object> hsRsquery = new HashMap<String, Object>();]]>
    <![CDATA[for( int i = 0 ; i < rsquery.size() ; i ++ ){]]>
        <emphasis role="bold">hsRsquery = rsquery.get(i);</emphasis>
        String name = (String) hsRsquery.get("name");
    }
	
    // When defining table-mapping
    <![CDATA[List<Customer> rsqueryUsingTableMapping]]> = queryService.find(
            "selectUsingTableMapping", new Object[] { "%12345%" });
    <![CDATA[Iterator<Customer> rsqueryItr]]> = rsqueryUsingTableMapping.iterator();
    while (rsqueryItr.hasNext()) {
        <emphasis role="bold">Customer customer = rsqueryItr.next();</emphasis>
        String name = customer.getNm();
    }

    // When defining result-mapping
    <![CDATA[List<CompositionCustomer> rsqueryUsingResultMapping]]> = <emphasis role="bold">queryService.find("selectUsingResultMapping"
            , new Object[] { "%12345%" });</emphasis>
    <![CDATA[Iterator<CompositionCustomer> rsqueryItr_01]]> = rsqueryUsingResultMapping.iterator();
    while (rsqueryItr_01.hasNext()) {
        <emphasis role="bold">CompositionCustomer compositionCustomer 
                = rsqueryItr_01.next();</emphasis>
        String name =  compositionCustomer.getCompositionName();
    }
	
    // When defining result class only
    <![CDATA[List<CamelCasedCustomer> rsqueryUsingOnlyResultClass]]> = <emphasis role="bold">queryService.find(
            "selectUsingOnlyResultClass", new Object[] { "%12345%" });</emphasis>
    <![CDATA[Iterator<CamelCasedCustomer> rsqueryItr_02]]> = rsqueryUsingOnlyResultClass.iterator();
    while (rsqueryItr_02.hasNext()) {
        <emphasis role="bold">CamelCasedCustomer camelCasedCustomer
                = rsqueryItr_02.next();</emphasis>
        String name = camelCasedCustomer.getName();
    }	
}</programlisting>
			</para>
		</section>
	</section>
		
	<section id="query_usecases_embeddedsql">
		<title>Embedded SQL</title>

		<para>
		    The following is a case of using embedded sql.
			Even without defining SQL statement in mapping XML file, 
			it can be executed by defining a specific SQL statement in the code.
		</para>

		<section id="query_usecases_embeddedsql_attribute">
			<title>Configuration file sample</title>

			<para>
				The following is a part of context-query.xml file defining Query service.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    ...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean> ]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_embeddedsql_testcode">
			<title>Test code sample</title>

			<para>
				The following is a part of test code which directly defines in code and executes SQL statement
				without defining SQL statement in mapping XML file.
				As you can see below, by using Query service, INSERT, SELECT, UPDATE, and DELETE can be executed without mapping XML file.
				<programlisting language="java">/**
 * Test code for inserting data in DB using Query service
 */
public void insertCustomer() throws Exception{
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    //createBySQL() : Execute INSERT even if SQL statement is not defined in mapping XML file.
    
    int result = <emphasis role="bold">queryService.createBySQL(
            "insert into TBL_CUSTOMER values (?, ?, ?)",
            new String[] {"VARCHAR", "VARCHAR", "VARCHAR" },
            new Object[] {"1234567890123", "GilDongHong", "Seoul" });</emphasis>
    if ( result == -1 ){
        throw new Exception("Insert Query failed");
    }
}

/**
 * Test code for searching data in DB using Query service.
 */	
public void selectCustomer() {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    //findBySQL() : Execute SELECT even if SQL statement is not defined in mapping XML file.
    
    <![CDATA[List<Map<String, Object>> result]]> = <emphasis role="bold">queryService.findBySQL(
            "select NAME, ADDRESS from TBL_CUSTOMER where SSNO like ?",
            new String[] { "VARCHAR" }, 
            new Object[] { "%4567890123" });</emphasis>
    <![CDATA[Iterator<Map<String, Object>> resultItr]]> = result.iterator();
    while( resultItr.hasNext() ){
        Map resultMap = resultItr.next();
        resultMap.get("name");
    }
	
    System.out.println("result.size() : " + result.size());
}

/**
 * Test code to update data in DB through Query service
 */	
public void updateCustomer() {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    //updateBySQL() : Execute UPDATE even if SQL statement is not defined in mapping XML file.
    int result = <emphasis role="bold">queryService.updateBySQL(
            "update TBL_CUSTOMER set NAME=? where SSNO=?", 
            new String[] {"VARCHAR", "VARCHAR" }, 
            new Object[] { "Anonymous","1234567890123" });</emphasis>
			
    System.out.println("result : " + result);
}

/**
 * Test code to delete data in DB through Query service
 */
public void deleteCustomer() {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    //removeBySQL() : Execute DELETE even if SQL statement is not defined in mapping XML file.
    int result = <emphasis role="bold">queryService.removeBySQL(
            "delete from TBL_CUSTOMER where SSNO=?", 
            new String[] { "VARCHAR" },
            new Object[] { "1234567890123" });</emphasis>
			
    System.out.println("result : " + result);
}</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_ormapping">
		<title>OR Mapping</title>

		<para>
			The following is an example of using OR mapping.
			By using only object without SQL statement definition, basic INSERT, UPDATE, DELETE, SELECT are executed.
		</para>

		<section id="query_usecases_ormapping_attribute">
			<title>Configuration file sample</title>

			<para>
				The following is a part of context-query.xml file defining Query service
				and context-query-sqlloader.xml file defining the location of mapping XML to be loaded in Query service.
					
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    ...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
   	<property name="mappingFiles">
   	   	<value>
   	   	   	<!-- xml files in folder -->
   	   	   	file:./src/test/resources/foldermappings/**/testcase-*.xml,
   	   	   	file:./src/test/resources/dynamicreload/testcase-queries-dynamicreload.xml,
   	   	   	<!-- xml files in classpath -->
   	   	   	classpath*:/mappings/testcase-queries-dynamic.xml,
   	   	   	classpath*:/mappings/testcase-queries-general.xml,
   	   	   	classpath*:/mappings/testcase-queries-resultmapping.xml,
   	   	   	classpath*:/mappings/testcase-queries-resultsetmapper.xml,
   	   	   	classpath*:/mappings/testcase-table-mappings.xml,
   	   	   	classpath*:/mappings/testcase-queries-extended.xml,
   	   	   	classpath*:/mappings/testcase-queries-mappingstyle.xml,
   	   	   	<!-- xml files in jar  --> 
   	   	   	classpath*:/jarmappings/testcase-queries-lob.xml
   	   	</value>
   	</property>	
   	...
</bean>]]></programlisting>
			</para>
		</section>
			
		<section id="query_usecases_ormapping_xml">
			<title>Mapping XML file sample</title>

			<para>
				The following is a part of mapping-query-ormapping.xml which was loaded through the above-mentioned Query service.
				It contains mapping information between TBL_ORMapping and ORMapping class.
				<programlisting language="xml"><![CDATA[<queryservice>
    <table-mapping>
        <table name="TBL_ORMapping"
            class="anyframe.sample.domain.ORMapping">
            <field-mapping>
                <dbms-column>id</dbms-column>
                <class-attribute>id</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>name</dbms-column>
                <class-attribute>nm</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>address</dbms-column>
                <class-attribute>addr</class-attribute>
            </field-mapping>
            <primary-key>
                <dbms-column>id</dbms-column>
            </primary-key>
        </table>
    </table-mapping>
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_ormapping_mappingclass">
			<title>Sample code of mapping class used in OR mapping.</title>

			<para>
				The following is a part of class ORMapping.java which is used when executing 
			    INSERT, UPDATE, SELECT for a specific table based on OR mapping information defined in 
				the above-mentioned mapping XML file.
				<programlisting language="java">public class ORMapping implements Serializable {

    public String id;
    public String nm;
    public String addr;
	
    public ORMapping() {
    }
	
    public ORMapping(String i, String n, String a) {
        id = i;
        nm = n;
        addr = a;
    }
	
    // getter, setter ...
}</programlisting>
			</para>
		</section>

		<section id="query_usecases_ormapping_testcode">
			<title>Test code sample</title>

			<para>
				The following is a part of test code executing INSERT, SELECT, UPDATE, DELETE 
				using only object without defining SQL statement in mapping XML file.
				By setting necessary value in mapping class and passing it into Query service, the relevant SQL statement can be executed.
				<programlisting language="java">/**
 * Test code to insert new data to DB through Query service
 */	
public void insertORMapping() {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    ORMapping ormapping = new ORMapping("1234567890123", "HonggilDong", "Ansan");

    // Set initial value in ORMapping object and execute INSERT.
    // The SQL statement executed in the following code is 
    // INSERT INTO TBL_ORMapping (address ,name ,id ) 
    // values ( '1234567890123', 'HonggilDong', 'Ansan' )	
    int result = <emphasis role="bold">queryService.create(ormapping);</emphasis>
    System.out.println("result : " + result);
}

/**
 * Test code to search for data inserted in DB through Query service
 */	
public void selectORMapping() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    ORMapping ormapping = new ORMapping();
    ormapping.setId("1234567890123");

    // Enter value in attribute mapped in column assigned as primary-key,  
    // execute find, then execute SELECT having primary-key as search condition.
    // The SQL statement executed in the following code is
    // SELECT NAME, ADDRESS FROM TBL_ORMAPPING WHERE ID = '1234567890123'
    <![CDATA[List<ORMapping> result]]> = <emphasis role="bold">queryService.find(ormapping);</emphasis>
    if ( result.size() != 1 ){
        throw new Exception("Select failed");
    }
}

/**
 * Test code to update data inserted in DB through Query service
 */	
public void updateORMapping() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    ORMapping ormapping = new ORMapping("1234567890123", "HonggilDongn", "Seoul");

    // The SQL statement executed in the following code is
    // Update TBL_ORMapping set address = 'Seoul' ,name = 'HonggilDong'
    //   where id = '1234567890123'	
    int result = <emphasis role="bold">queryService.update(ormapping);</emphasis>
    if ( result == -1 ){
        throw new Exception("Update failed");
    }
}

/**
 * Test code to delete data inserted in DB through Query service
 */	
public void deleteORMapping() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
		
    ORMapping ormapping = new ORMapping();
    ormapping.setId("1234567890123");
	
    // The SQL statement executed in the following code is
    // DELETE FROM TBL_ORMapping where id = 1234567890123	
    int result = queryService.remove(ormapping);
    if ( result == -1 ){
        throw new Exception("Update failed");
    }
}</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_dynamic">
		<title>Dynamic Query</title>

		<para>
		Query service supports the defining of text replacement, named parameter format, etc. 
		to support the defining of SQL statement which dynamically changes 
		according to condition value entered during operation. 
		To do this, the following syntax can be used.
		</para>

		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold">:ParameterName</emphasis>
					: Used when assigning variable to be entered in a specific SQL statement.
				</para>
			</listitem>

			<listitem>
				<para>
					<emphasis role="bold">{{replacement key}}</emphasis>
					: In replacement key, define the relevant value in the part that should be replaced.
				</para>
			</listitem>

			<listitem>
				<para>
					<emphasis role="bold">#if ~ (#elseif) ~ #end</emphasis>
					: Define in the part which requires conditional branch
				</para>
			</listitem>

			<listitem>
				<para>
					
					<emphasis role="bold"># foreach ~ #end</emphasis>
					: Define in the part which requires loop 	
				</para>
			</listitem>

			<listitem>
				<para>
					<emphasis role="bold">$velocityCount </emphasis>
					: Define in the part to check loop index in foreach syntax.
				</para>
			</listitem>
		</itemizedlist>

		<section id="query_usecases_dynamic_attribute">
			<title>Configuration file sample</title>

			<para>
				The following is a part of context-query.xml file which defines Query service 
				and context-query-sqlloader.xml file which defines the location of mapping XML file 
				to be loaded in Query service.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    ...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

        	<para>
        		<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
   	<config:configuration>
        <filename>classpath:/query/mapping-query-dynamic.xml</filename>
        ...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>
			
		<section id="query_usecases_dynamic_xml">
			<title>Mapping XML file sample</title>

			<para>
				The following is a part of mapping-query-dynaminc.xml file which was loaded through the above-mentioned Query service. 
				It contains several dynamic SQL statements.
				<programlisting language="xml"><![CDATA[<queries>	
    <query ]]><emphasis role="bold">id="getLogonIdByNamedParam"</emphasis><![CDATA[ isDynamic="true">
        <statement>
            SELECT LOGON_ID 
            FROM TBL_USER 
            WHERE LOGON_ID BETWEEN ]]><emphasis role="bold">:lowId AND :highId</emphasis><![CDATA[
        </statement>
        <param name="lowId" type="VARCHAR"/>
        <param name="highId" type="VARCHAR"/>
    </query>
    <query ]]><emphasis role="bold">id="getEmployeesByTextReplacement"</emphasis><![CDATA[ isDynamic="true">
        <statement>
            SELECT LOGON_ID 
            FROM ]]><emphasis role="bold">{{schema}}</emphasis><![CDATA[ 
            ORDER BY ]]><emphasis role="bold">{{sortColumn}}</emphasis><![CDATA[
        </statement>
    </query>
    <query ]]><emphasis role="bold">id="getLogonIdByIf"</emphasis><![CDATA[ isDynamic="true">
        <statement>
            SELECT LOGON_ID 
            FROM TBL_USER 
            ]]><emphasis role="bold">#if ($id &amp;&amp; !$id.equals(""))
            WHERE LOGON_ID like '%' || :logonId || '%'
            #end </emphasis><![CDATA[
            ORDER BY {{sortColumn}}
        </statement>
        <param name="logonId"	type="VARCHAR"/>
    </query> 
    <query ]]><emphasis role="bold">id="getLogonIdByForeach"</emphasis><![CDATA[ isDynamic="true">
        <statement>
            SELECT LOGON_ID, NAME 
            FROM TBL_USER 
            WHERE LOGON_ID IN (
                ]]><emphasis role="bold">#foreach ($logonId in $logonIdList) 
                    #if ($velocityCount	== 1 ) 
                        '$logonId' 
                    #else 
                        , '$logonId' 
                    #end
                #end </emphasis><![CDATA[
            ) 
            ORDER BY NAME
        </statement> 
    </query> 	
</queries>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_dynamic_testcode">
			<title>Test code sample</title>

			<para>
				The following is a part of test code executing SQL statements which can be dynamically
				modified according to the parameter value defined in the above-mentioned mapping XML file.
					
				<programlisting language="java">/**
 * Using Named Parameter, execute dynamic SQL statement whose query id is 'getLogonIdByNamedParam'.
 * getLogonIdByNamedParam : When returning Named Parameter value whose key is lowId, highId to Query service in key=value format,
 * Query service sets relevant value into PreparedStatement and executes SQL statement.
 * This method passes "lowId = a", "highId = z" parameter to Query service in Object[] type.
 * In this case, the executed SQL statement is as follows. 
 * SELECT LOGON_ID FROM TBL_USER WHERE LOGON_ID BETWEEN 'a' AND 'z'
 */
public void dynamicQueryUsingNamedParameter() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    Object[] iVal = new Object[2];
    iVal[0] = new Object[]{"lowId", "a"};
    iVal[1] = new Object[]{"highId", "z"};
	
    <![CDATA[List<Map<String, Object>> rtList]]> 
        <emphasis role="bold">= queryService.find("getLogonIdByNamedParam", iVal);</emphasis>
    System.out.println("rtList.size() : " + rtList.size());
}

/**
 * Using {{replacement key}}, execute dynamic SQL statement whose query id is 'getEmployeesByTextReplacement'.
 * getEmployeesByTextReplacement : When returning replacement string, that has schema, sortColumn as key, in key=value format to Query service,	
 * Query service uses the the value by replacing as it is.
 * This method passes "schema=TBL_USER", "sortColumn=NAME" parameter in Object[] type to Query service.
 * In this case, the executed SQL statement is as follows.				
 * SELECT * FROM TBL_USER ORDER BY NAME
 */
public void dynamicQueryUsingTextreplace() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    Object[] iVal = new Object[2];
    iVal[0] = new Object[]{"schema", "TBL_USER"};
    iVal[1] = new Object[]{"sortColumn", "NAME"};
    
	<![CDATA[List<Map<String, Object>> rtList]]>
        <emphasis role="bold">= queryService.find("getEmployeesByTextReplacement", iVal);</emphasis>        
    System.out.println("rtList.size() : " + rtList.size());
}

/**
 * By using #if for conditional branch, execute dynamic SQL statement whose query id is 'getLogonIdByIf'.
 * getLogonIdByIf : Unless the value of parameter, whose key is id, is null or empty string,
 *  WHERE clause included in #if statement is included in the SQL statement to be executed.
 * (Note. At the point where #if statement ends, #end must be defined.)
 * In WHERE clause, sentence with format such as '%' || :logonId || '%' is used, 
 * and this is to make string which % was added before and after parameter value.
 * (In this case, there must be space between '%', ||, :logonId, so that WHERE clause can properly be executed.
 * This method passes "id=test", "sortColumn=NAME" parameter in Object[] type to Query service.
 * The executed SQL statement is as follows. 
 *
 * SELECT LOGON_ID 
 * FROM TBL_USER 
 * WHERE LOGON_ID like '%test%' 
 * ORDER BY NAME
 */
public void dynamicQueryUsingCondition() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    Object[] iVal = new Object[3];
    iVal[0] = new Object[]{"id", "yes"};
    iVal[1] = new Object[]{"logonId", "test"};
    iVal[2] = new Object[]{"sortColumn", "NAME"};
	
    <![CDATA[List<Map<String, Object>> rtList]]>
        <emphasis role="bold">= queryService.find("getLogonIdByIf", iVal);</emphasis>
    System.out.println("rtList.size() : " + rtList.size());
}

/**
 * Using #foreach for Loop, execute dynamic SQL statement whose query id is 'getLogonIdByForeach'.
 * getLogonIdByForeach : Parameter value whose key is logonIdList is List type,
 * and values extracted from list in order are set as variable logonId internally.
 * logonId is not input parameter to be passed to Query service.
 * When velocityCount is 1, in the first loop, the first value of logonIdList is
 * added as it is, and from then on, value with , is added.
 * (Note that at the point where #foreach, #if statement ends, #end must be defined.)
 * This method passes ArrayList whose logonIdList value is composed of two strings of "admin", "test" in Object[] type to Query service.
 * The executed SQL statement is as follows.
 * SELECT LOGON_ID, NAME 
 * FROM TBL_USER 
 * WHERE LOGON_ID IN ('admin', 'test') 
 * ORDER BY NAME
 */
public void dynamicQueryUsingLoop() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    <![CDATA[List<String> logonIdList = new ArrayList<String>();]]>
    logonIdList.add("admin");
    logonIdList.add("test");

    Object[] iVal = new Object[]{"logonIdList", logonIdList};

    <![CDATA[List<Map<String, Object>> rtList]]> 
        <emphasis role="bold">= queryService.find("getLogonIdByForeach", new Object[]{ iVal });</emphasis> 

    if (rtList.size() != 1) {
        throw new Exception("Dynamic Query Using Condition failed");
    }
}</programlisting>
			</para>
		</section>
		<note>
			<title>Notes for defining Dynamic Query</title>
			<para>
				To perform mapping search result with a specific object using QueryService,
				logic for mapping was repetitively performed whenever SQL statement is executed.
				To improve Query service performance, from Anyframe 4.0.0 onwards, this logic is modified
				so that once-handled result mapping can be managed in SQLLoader based on queryId.
				In case of SQL statement whose search column can be changed whenever SQL statement is executed, 
				in other words when the SELECT or FROM changes in the SQL statement, result mapping can be changed. 
				So this should be handled through a special Mapper class.  
				Therefore, separate mapper class is needed to handle this.
				Mapper class which is provided in the subpackage of org.anyframe.query.impl.jdbc.mapper package plays the following role.
				<table>
					<title>Mapper Class</title>
					<tgroup cols="2">
						<colspec colnum="1" colname="col1" colwidth="3*" />
						<colspec colnum="2" colname="col2" colwidth="7*" />
						<thead>
							<row>
								<entry align="center">Class Name</entry>
								<entry align="center">Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>DefaultCallbackResultSetMapper</entry>
								<entry>
									[basic application] Mapper that QueryService applies as the default 
									when a separate mapper is not defined for a specific query statement, 
									and the search result is delivered in the Map type.  
									The search column information of the query statement executed first is saved, 
									and search column mapping is executed based on the saved information for the next execution. 
								</entry>
									 
							</row>						
							<row>
								<entry>CallbackResultSetMapper</entry>
								<entry>
									Mapper that conducts search column mapping at each point of executing query statements 
									when the search result is delivered in the Map type. 
									Utilized for the query statements whose search results are different every time the query statements are executed 
									as the SELECT/FROM clasue is constituted dynamically.  
									Defined with the property value of mapper of the relevant query statement.
								</entry>
							</row>
							<row>
								<entry>DefaultReflectionResultSetMapper</entry>
								<entry>
									[basic application] Mapper applied in QueryService as the default 
									when there is no separate mapper defined for a specific query statement 
									and the search result is delivered in a specific VO type.  
									The search column information of the query statement executed first is saved, 
									and the search column mapping is executed based on the saved information for the next execution. 
								</entry>
							</row>							
							<row>
								<entry>ReflectionResultSetMapper</entry>
								<entry>
									Mapper that executes column mapping every time the query statements are executed 
									when the search result is delivered in a specific VO type. 
									Can be utilized when the query statements produce different search results every time they are executed 
									as the SELECT/FROM clause is constituted dynamically.  
									Defined with the mapper property value of the relevant query statement. 
								</entry>
							</row>
							<row>
								<entry>MappingStyleColumnMapRowMapper</entry>
								<entry>
									Mapper mainly used in Query service to apply result mapping style 
									such as CamelCase, Lower, and Upper when executing StoredProcedure.
								</entry>
							</row>																												
						</tbody>
					</tgroup>
				</table>
					
				<para>
					The following is an example of SQL statement which the FROM clause changes according to conditions. 
					As explained above, result mapping information is saved for SQL statement executed once based on queryId, 
					so in case of SQL statement that the SELECT or FROM clause changes as the following, 
					SQL statement executed first and SQL statement executed later can be different. 
					Therefore, an unexpected result can occur when the currently executed SQL statement result 
					and result mapping information saved based on queryId does not match. 
					In this case remember that the related SQL statement should use <![CDATA[<result mapper="..."/>]]> as the following 
					to be defined so that it is handled through a specific Mapper.
				</para>
				<para>
					In case of 'findUsers' SQL statement, CallbackResultSetMapper is defined as mapper 
					in order to return query execution results with map type.
				</para>
				<programlisting language="xml"><![CDATA[<query id="findUsers" isDynamic="true">
    <statement>
        SELECT LOGON_ID FROM {{schema}} ORDER BY {{sortColumn}}
    </statement>
    <result ]]><emphasis role="bold">mapper="org.anyframe.query.impl.jdbc.mapper.
            CallbackResultSetMapper"</emphasis><![CDATA[/>
</query>]]></programlisting>
				<para>For 'findUsers' SQL statement execution results to be returned as User Defined Object, 
			    define mapper to ReflectionResultSetMapper mentioned before, and class to be returned.</para>
				<programlisting language="xml"><![CDATA[<query id="findUsers" isDynamic="true">
    <statement>
        SELECT LOGON_ID FROM {{schema}} ORDER BY {{sortColumn}}
    </statement>
    <result ]]><emphasis role="bold">class="anyframe.core.query.vo.UsersVO"
        mapper="org.anyframe.query.impl.jdbc.mapper.
                ReflectionResultSetMapper"</emphasis><![CDATA[/>
</query>]]></programlisting>					
				<para>
					Custom ResultSetMapper appropriate for specific SQL statement other than Mapper suggested above can by implemented. 
					For more information, refer to <link linkend="query_usecases_resultsetmapper_xml">Result Mapper implementation</link>.
				</para>
			</para>
		</note>			
	</section>

	<section id="query_usecases_pagination">
		<title>Pagination</title>

		<para>
			Executing SELECT query using Query service 
			is more efficient and improves performance because searching only relevant data and not the entire result is possible. 
			Query service does not require additional logic for pagination or SQL statement subjective to specific DB.
			Instead, the page number to search and the number of data to be shown in one page must be passed as input parameter.
		</para>

		<section id="query_usecases_pagination_attribute">
			<title>Configuration file Sample</title>

			<para>
				The following is a part of context-query.xml which file defines Query service 
			    and context-query-sqlloader.xml file which defines the location of mapping XML file to be loaded in Query service.
				(*To perform pagination on SELECT query, note that PagingSQLGenerator appropriate for DBMS must be additionally defined.)
					
			</para>
			<important>
				<title>Notes on Pagination</title>
				<para>
					From QueryService 4.1.0 onwards, when defining properties of QueryService,
					PagingSQLGenerator appropriate for DBMS must be set.
					When appropriate PagingSQLGenerator does not exist,
					org.anyframe.query.impl.jdbc.generator.DefaultPagingSQLGenerator를 can be used.
					But, when executing findXXX() using DefaultPagingSQLGenerator,
					Query service internally loads all data relevant to the condition 
					and filters the data for specific page by using ResultSet Cursor.
					This process takes significant amount of time and can 
					severely affect the performance when searching large amount of data.
					Therefore, using DefaultPagingSQLGenerator is not recommended.
				</para>
			</important>					
					
			<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    <property name="pagingSQLGenerator" ref="pagingSQLGenerator"/>
    ...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>  
<bean id="pagingSQLGenerator" 
        class="org.anyframe.query.impl.jdbc.generator.OraclePagingSQLGenerator"/>]]>  </programlisting>
			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-pagination.xml</filename>
    ...
    </config:configuration>		
</bean>]]>  		</programlisting>
			</para>
		</section>

		<section id="query_usecases_pagination_xml">
			<title>Mapping XML file sample</title>

			<para>
				The following is a part of mapping-query-pagination.xml loaded from the above-mentioned Query service
				and contains table mapping information and SQL statement.
				<programlisting language="xml"><![CDATA[<query id="selectUsingPagination">
    <statement>
        SELECT NAME FROM TBL_CUSTOMER WHERE SSNO like ?
    </statement>
    <param type="VARCHAR" />
    <result class="anyframe.sample.domain.Customer"/>
</query>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_pagination_testcode">
			<title>Test code sample</title>

			<para>
				The following is a part of test source code executing SELECT statement defined in the above-mentioned mapping XML file
				It contains test logic to get paginated execution results.
				<programlisting language="java">/**
 * Test code to assert SELECT execution result by specific page
 * When several data was inserted in TBL_CUSTOMER table,
 * this method searches for the data relevant only to the specific page
 * by passing the number of data to be shown in one page (5) and the number of the search page (3).
 */
public void selectCustomer() throws Exception {
    QueryService QueryService = (QueryService) context.getBean("queryService");
	
    /** findWithRowCount() : Using query id defined in mapping XML file, execute SELECT.
     *                       findWithRowCount() returns the total number of data which can be fetched from SELECT
     *                       and the result value relevant to a specific page through single calling.
     */
    <![CDATA[Map<String, Object> resultMap]]> = <emphasis role="bold">queryService.findWithRowCount("selectUsingPagination",
            new Object[] { "%1234%" }, 3, 5);</emphasis>
			
    Customer customer = new Customer();

    // Extract result values relevant to a specific page
    <![CDATA[List<Customer> resultList]]> = (List) resultMap.get(<emphasis role="bold">QueryService.LIST</emphasis>);
    <![CDATA[for(int i = 0 ; i < resultList.size() ; i ++){
        customer = resultList.get(i);
        customer.getNm();
    }]]>  
	
    // Extract the total number of data that can be fetched from SELECT
    int totalSize = ((Long) resultMap.get(<emphasis role="bold">QueryService.COUNT</emphasis>)).intValue();
    if (resultList.size() != 5 || totalSize != 15) {
        throw new Exception("Select query failed");
    }
}</programlisting>
			</para>

			<para>
				The following are things to be checked when using findXXX() which performs pagination provided in Query service.
					
				<emphasis role="bold">public Collection find...(..., int pageIndex, int pageSize);</emphasis>
			</para>

			<orderedlist>
				<listitem>
					<para>
						If page number is less than 1, result data does not exist. 
						(<emphasis role="bold">From Anyframe 3.2.0 onwards</emphasis>)
					</para>
				</listitem>

				<listitem>
					<para>
						If page number is less than 1, the 1 page is searched.
				        (<emphasis role="bold">Before Anyframe 3.2.0</emphasis>)
					</para>
				</listitem>

				<listitem>
					<para>The number of data to be shown on one page must be bigger than 0.</para>
				</listitem>

				<listitem>
					<para>
						If calculated value using the page number and the number of data to be shown on one page
						is bigger than the total number of data, result data does not exist. (<emphasis role="bold">From Anyframe 3.2.0</emphasis>)
					</para>
				</listitem>

				<listitem>
					<para>
						If calculated value using the page number and the number of data to be shown on one page
						is bigger than the total number of data, last page is returned.
						(<emphasis role="bold">Before Anyframe 3.2.0</emphasis>)
					</para>
				</listitem>

				<listitem>
					<para>
						When the number of data to be shown on one page is omitted, 
						it must be defined in <![CDATA[<result>]]> in mapping XML file.
						<programlisting language="xml"><![CDATA[<query id="selectUsingPagination" isDynamic="false">
    <statement>
        SELECT NAME FROM TBL_CUSTOMER WHERE SSNO like ?
    </statement>
    <param type="VARCHAR" />
    <result length="10" class="anyframe.sample.domain.Customer"/>
</query>]]></programlisting>
					</para>
				</listitem>
			</orderedlist>
		</section>
	</section>

	<section id="query_usecases_batch">
		<title>Batch Update</title>

		<para>
			Query service enables INSERT, UPDATE, DELETE of several data by single execution using JDBC 2.0 batch updates.
		</para>

		<section id="query_usecases_batch_attribute">
			<title>Configuration file sample</title>

			<para>
				The following is a part of context-query.xml file which defines Query service and context-query-sqlloader.xml file 
				which defines the location of mapping XML file to be loaded in Query service.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    ...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-batch.xml</filename>
        ...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_batch_xml">
			<title>Mapping XML file sample</title>

			<para>
				The following is a part of mapping-query-batch.xml file which was loaded through the above-mentioned Query service. 
				It contains table mapping information and SQL statement to handle as batch.
				<programlisting language="xml"><![CDATA[<queryservice>
    <table-mapping>
        <table name="TBL_CUSTOMER"
            class="anyframe.sample.domain.Customer">
            <field-mapping>
                <dbms-column>ssno</dbms-column>
                <class-attribute>ssno</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>name</dbms-column>
                <class-attribute>nm</class-attribute>
            </field-mapping>
            <field-mapping>
                <dbms-column>address</dbms-column>
                <class-attribute>addr</class-attribute>
            </field-mapping>
            <primary-key>
                <dbms-column>ssno</dbms-column>
            </primary-key>
        </table>
    </table-mapping>
    <queries>
        <query id="insertbatch" isDynamic="false">
            <statement>
                INSERT INTO TBL_CUSTOMER ( ssno, name, address ) VALUES (?,?,?)
            </statement>
            <param type="VARCHAR" />
            <param type="VARCHAR" />
            <param type="VARCHAR" />
        </query>
    </queries>
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_batch_testcode">
			<title>Test code sample</title>

			<para>
				The following is a part of test code which executes INSERT statement as batch
				defined in the above-mentioned mapping XML file.
				When input parameter is contained in list type and passed to Query service,
				Query service executes as many SQL statements as the number of lists passed through single execution.
				<programlisting language="java">/**
 * Execute SQL statement defined in mapping XML file as batch.
 */
public void insertCustomer() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    //Save input data in ArrayList.
    <![CDATA[List<Object[]> args = new ArrayList<Object[]>();]]>
    Object[] arg = new Object[3];
    arg[0] = "1234567890123";
    arg[1] = "KimMinsu";
    arg[2] = "Ansan";
    args.add(arg);
    arg = new Object[3];
    arg[0] = "1234567890124";
    arg[1] = "LeeSungwook";
    arg[2] = "Seoul";
    args.add(arg);
    arg = new Object[3];
    arg[0] = "1234567890125";
    arg[1] = "ParkHeejin";
    arg[2] = "Seoul";
    args.add(arg);

    //As three objects are contained in ArrayList,
    //SQL statement whose query id is insertbatch is executed three times.
    int[] results = queryService.batchUpdate("insertbatch", args);
    <![CDATA[for (int i = 0; i < results.length; i++) {
        if (results[i] == -1) {
            throw new Exception("Batch Insert falied");
        }
    }]]>
}

/**
 * When SQL statement is not defined in mapping XML file, 
 * execute by directly defining SQL statement as batch.
 */
public void insertCustomerBySQLQuery() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
    
    //Define SQL statement to execute
    String sql = "INSERT INTO TBL_CUSTOMER ( ssno, name, address ) VALUES (?,?,?)";

    //Define SQL type of input parameter
    String[] types = new String[3];
    types[0] = "VARCHAR";
    types[1] = "VARCHAR";
    types[2] = "VARCHAR";

    //Save input data in ArrayList.
    <![CDATA[List<Object[]> args = new ArrayList<Object[]>();]]>
    Object[] arg = new Object[3];
    arg[0] = "1234567890126";
    arg[1] = "HongGildong";
    arg[2] = "Suwon";
    args.add(arg);
    arg = new Object[3];
    arg[0] = "1234567890127";
    arg[1] = "LeeSoonsin";
    arg[2] = "Seongnam";
    args.add(arg);
    arg = new Object[3];
    arg[0] = "1234567890128";
    arg[1] = "ChoiMinsu";
    arg[2] = "Seoul";
    args.add(arg);

    //As three objects are contained in ArrayList, the relevant SQL statement is executed three times.
    int[] results = queryService.batchUpdateBySQL(sql, types, args);

    <![CDATA[for (int i = 0; i < results.length; i++) {
        if (results[i] == -1) {
            throw new Exception("BatchInsertBySQL falied");
        }
    }]]>
}

/**
 * Execute using OR mapping as batch.
 */
public void insertCustomerByObject() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    <![CDATA[List<Customer> args = new ArrayList<Object[]>();]]>
    Customer customer = new Customer();

    customer.setSsno("1234567890129");
    customer.setNm("Smith");
    customer.setAddr("LA");
    args.add(customer);

    customer = new Customer();
    customer.setSsno("1234567890130");
    customer.setNm("Brown");
    customer.setAddr("Newyork");
    args.add(customer);

    customer = new Customer();
    customer.setSsno("1234567890131");
    customer.setNm("Eugene");
    customer.setAddr("Boston");
    args.add(customer);

    // Executed SQL statement is INSERT statement, 
    // insert into TBL_CUSTOMER (ssno ,address ,name) values (?, ?, ?).
    
    int[] results = queryService.batchCreate(args);

    <![CDATA[for (int i = 0; i < results.length; i++) {
        if (results[i] == -1) {
            throw new Exception("BatchInsertByObject falied");
        }]]>
    }
}</programlisting>
			</para>
			<note>
				<title>Oracle-style Batch Update</title>
				<para>
					If Oracle-style batch update is needed, OraclePagingJdbcTemplate provieded by Anyframe 
					should be used.	OraclePagingJdbcTemplate internally to the input query by changing 
					the form of PreparedStatement query is processed as a batch. 
					However, the input query is Stored Procedure or Function, SQLException will be 
					occured when batch as a PreparedStatement. For this problem, Anyframe add a seperate 
					method in OraclePagingJdbcTemplate to be processed a query(Stored Procedure, 
					Function, etc.) in the form of CallableStatement to allow for a batch update.
					This method is called internally by QueryService batchExecute method and 
					batchExecuteBySQL method.
				</para>
				<para>
					Therefore, remember to execute batch update in Oracle-style with Stored Procedure and Function, calling the batchExecute method and batchExecuteBySQL method in Query Service.
				</para>
			</note>
		</section>
	</section>

	<section id="query_usecases_statement">
		<title>Callable Statement</title>

		<para>
			CallableStatment is used when calling Stored Procedure, Function of DB, etc., not standard DDL or DML.
			Stored Procedure is used when making SQL statement in one file or saving in DB and calling like function.
			Therefore, it provides various advantages in terms of performance, code independence, security, etc.
		</para>

		<section id="query_usecases_statement_attribute">
			<title>Configuration file sample</title>

			<para>
				The following is a part of context-query.xml file which defines Query service
				and context-query-sqlloader.xml file that defines the location of mapping XML file to be loaded in Query service.
				<programlisting language="java"><![CDATA[<bean name="oracle_queryservice" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>		
    <property name="sqlRepository" ref="sqlLoader"/>		
    ...
</bean>	
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-callablestatement.xml</filename>
        ...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_xml">
			<title>Mapping XML file sample</title>

			<para>
				The following is a part of mapping-query-callablestatement.xml 
				which was loaded through the above-mentioned Query service. 
				It contains SQL statement to execute test_function which is already created in DB.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>	
        <query id="callFunction">
            <statement>{? = call test_function(?)}</statement>
            <param type="NUMERIC" binding="OUT" name="outVal" />
            <param type="NUMERIC" binding="IN" name="inVal" />
        </query>
    </queries>    
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_testcode">
			<title>Test code sample</title>

			<para>
				The following is a part of test code to execute SQL statement calling function
				defined in the above-mentioned mapping XML file.
				To execute DB function through Query service, the function relevant to DB must be already created.
				
				<programlisting language="java">/**
 * Using query id defined in mapping XML file, call DB function.
 */
public void callableStatementFunction() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
	
    <![CDATA[Map<String, Integer> inVal = new HashMap<String, Integer>();]]>
    inVal.put("inVal", new Integer(10));
	    
    <![CDATA[Map<String, Object> results]]> = <emphasis role="bold">queryService.execute("callFunction", inVal);</emphasis>
    BigDecimal rtVal = (BigDecimal) results.get("outVal");
	
    if (rtVal.intValue() != 1 ){
        throw new Exception("testCallableStatementProcedure failed");
    }
}

/**
 * Even when not defined in mapping XML file, a specific function can be called.
 * Map executeBySQL(String sql, String[] types, String[] names,
 *     String[] bindings, Map values) 
 */
public void callableStatementBySQL() throws Exception {
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");
	
    String sql = "{? = call test_function(?)}";
    String[] types = { "NUMERIC", "NUMERIC" };
    String[] bindings = { "OUT", "IN" };
    String[] names = { "outVal", "inVal" };
	
    <![CDATA[Map<String, Integer> inVal = new HashMap<String, Integer>();]]>
    inVal.put("inVal", new Integer(10));
	    
    <![CDATA[Map<String, Object> results]]> = <emphasis role="bold">queryService.executeBySQL(sql, types, names, bindings, inVal);</emphasis>
    BigDecimal rtVal = (BigDecimal) results.get("outVal");

    if (rtVal.intValue() != 1 ){
        throw new Exception("testCallableStatementBySQL failed");
    }
}	

/**
 * Even when not defined in mapping XML file, a specific function can be called. 
 * This method is to return paginated search result. 
 * Map executeBySQL(String sql, String[] types, String[] names, 
 * 					String[] bindings, Map values, int pageIndex, int pageSize) 
 */
public void callableStatementBySQLWithPaging() throws Exception {
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");
	
    String sql = "{? = call test_function(?)}";
    String[] types = { "NUMERIC", "NUMERIC" };
    String[] bindings = { "OUT", "IN" };
    String[] names = { "outVal", "inVal" };
	
    <![CDATA[Map<String, Integer> inVal = new HashMap<String, Integer>();]]>
    inVal.put("inVal", new Integer(10));
	
    <![CDATA[Map<String, Object> results]]> = <emphasis role="bold">queryService.executeBySQL(sql, types, names, bindings, inVal, 1, 1);</emphasis>
    BigDecimal rtVal = (BigDecimal) results.get("outVal");

    if (rtVal.intValue() != 1 ){
        throw new Exception("testCallableStatementBySQLWithPaging failed");
    }
}</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_lob">
		<title>CLOB, BLOB</title>

		<para>
			Basically, handling LOB data is not different from handling other type of data.
			However, when LOB data handling is needed, 
			note that Lob Hander must be additionally defined when defining Query service property.
			For details on the lobHandler property,
			refer to <link linkend="query_configuration_lobhandler">[lobHandler] property</link>.
			Here, we will take a look at how to handle LOB data in case of Oracle 9i onwards, and Oracle 8i.
		</para>
			
		<section id="query_usecases_lob_oracle9i">
			<title>From Oracle 9i onwards</title>

			<section id="query_usecases_lob_oracle9i_attribute">
				<title>Configuration file sample</title>

				<para>
					The following is a part of context-query.xml file which defines Query service
					and context-query-sqlloader.xml file which defines the location of mapping XML file to be loaded in Query service.
					<programlisting language="xml"><![CDATA[<bean name="oracle_queryservice" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>		
    <property name="sqlRepository" ref="sqlLoader"/>		
    <property name="lobHandler" ref="lobHandler"/>
    ...
</bean>	
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>   
<bean id="nativeJdbcExtractor" 
    class="org.springframework.jdbc.support.nativejdbc.CommonsDbcpNativeJdbcExtractor" 
    lazy-init="true"/>
<bean id="lobHandler" class="org.springframework.jdbc.support.lob.OracleLobHandler"
        lazy-init="true">
    <property name="nativeJdbcExtractor" ref="nativeJdbcExtractor"/>
</bean>]]></programlisting>
				</para>

				<para>
					<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-lob.xml</filename>
        ...
    </config:configuration>		
</bean>]]></programlisting>
				</para>
			</section>
				
			<section id="query_usecases_lob_oracle9i_xml">
				<title>Mapping XML file sample</title>

				<para>
					The following is a part of mapping-query-lob.xml which was loaded through the above-mentioned Query service. 
					It contains table mapping information and various SQL statements handling LOB data.
					<programlisting language="xml"><![CDATA[<queries>  		
    <query id="insertLOB">
        <statement>insert into longVarchar values(?,?,?)</statement>
        <param type="INTEGER"/>
        <param type="BLOB"/>
        <param type="CLOB"/>
    </query>
    <query id="selectLOB">
        <statement>select myblob, myclob from longVarchar where count = ?</statement>
        <param type="INTEGER"/>
    </query>
    <query id="updateLOB">
        <statement>update longVarchar set myblob = ?, myclob = ? WHERE count = ?</statement>
        <param type="BLOB"/>
        <param type="CLOB"/>
        <param type="INTEGER"/>
    </query>
    <query id="deleteLOB">
        <statement>delete from longVarchar WHERE count = ?</statement>
        <param type="INTEGER"/>
    </query>
</queries>]]></programlisting>
				</para>
			</section>

			<section id="query_usecases_lob_oracle9i_testcode">
				<title>Test code sample</title>

				<para>
					The following is a part of test code to INSERT, SELECT, UPDATE,
					DELETE LOB data defined in the above-mentioned mapping XML file.
					<programlisting language="java">/**
 * Test code to insert new LOB data in DB through Query service
 */
public void insertLOB() throws Exception{
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");
               
   String strVal1 = "0The rose of Sharon is in blossom.";
   String strVal2 = "1The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.
			   The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.
			   The rose of Sharon is in blossom.The rose of Sharon is in blossom.\n";
   strVal2 += "2The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.
			   The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.
			   The rose of Sharon is in blossom.The rose of Sharon is in blossom.\n";
   // skip
   strVal2 += "30The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.
			   The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.The rose of Sharon is in blossom.
			   The rose of Sharon is in blossom.The rose of Sharon is in blossom.\n";
	
    int result = <emphasis role="bold">queryService.create("insertLOB"
        , new Object[] { new Integer(5), strVal1.getBytes() , strVal2 });</emphasis>
    System.out.println("result : " + result);
}

/**
 * Test code to search LOB data inserted in DB through Query service.
 */
public void selectLOB() throws Exception {
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");
	    
    <![CDATA[List<Map<String, byte[]>> result]]> = <emphasis role="bold">queryService.find("selectLOB", new Object[] { new Integer(5) });</emphasis>

    <![CDATA[Iterator<Map<String, byte[]>> resultItr]]> = result.iterator();
    while (resultItr.hasNext()) {
        <![CDATA[Map<String, byte[]> binary]]> = resultItr.next();
        String myCLOB = binary.get("myclob");
        String myBLOB = new String(binary.get("myblob"));
    }
	
    System.out.println("result : " + result);
}

/**
 * Test code to update LOB data inserted in DB through Query service
 */
public void updateLOB() throws Exception{
    QueryService queryService = (QueryService) context.getBean("oracle_queryservice");
	
    String strVal1 = "0Rose is in blossom.";
	String strVal2 = "1Rose is in blossom.Rose is in blossom.Rose is in blossom.Rose is in blossom.
	Rose is in blossom.Rose is in blossom.Rose is in blossom.
	Rose is in blossom.Rose is in blossom.Rose is in blossom.\n";
	strVal2 += "2Rose is in blossom.Rose is in blossom.Rose is in blossom.Rose is in blossom.
	Rose is in blossom. Rose is in blossom.Rose is in blossom.Rose is in blossom.
	Rose is in blossom.Rose is in blossom.\n";
	// skip
	strVal2 += "30Rose is in blossom.Rose is in blossom.Rose is in blossom.Rose is in blossom.
	Rose is in blossom.Rose is in blossom.Rose is in blossom.Rose is in blossom.
	Rose is in blossom.Rose is in blossom.\n";
	
    int result = <emphasis role="bold">queryService.create("updateLOB"
        , new Object[] { strVal1.getBytes() , strVal2,  new Integer(5)});</emphasis>
}

/**
 *  Test code to delete LOB type data inserted in DB through Query service
 */
public void deleteLOB() throws Exception{
	QueryService queryService = (QueryService) context.getBean("oracle_queryservice");
	<emphasis role="bold">queryService.remove("deleteLOB", new Object[]{new Integer(5)});</emphasis>
}						</programlisting>
					</para>
        		</section>
      		</section>

		<section id="query_usecases_lob_oracle8i">
        	<title>In case of Oracle 8i</title>

        	<section id="query_usecases_lob_oracle8i_attribute">
          		<title>Configuration file sample</title>

          		<para>
          			As Oracle LobHandler provided by Spring is applicable from 9i onwards,
					to handle LOB data in Oracle 8i, LobHandler provided in Anyframe must be set when defining Query service properties.
					The following is a part of context-query.xml file which defines Query service 
					and a part of Oracle8iLobHandler provided for Oracle 8i.
          			<programlisting language="xml"><![CDATA[<bean id="lobHandler" class="org.anyframe.query.impl.jdbc.lob.Oracle8iLobHandler"
        lazy-init="true">
    <constructor-arg value="net.sf.log4jdbc.ResultSetSpy"/>
    <property name="nativeJdbcExtractor" ref="nativeJdbcExtractor"/>
</bean>]]></programlisting>
				</para>

          		<para>
          			When logging SQL statement using DriverSpy,	define <![CDATA[<constructor-arg>]]> of LobHandler,
					and otherwise, remove it.
          		</para>
        	</section>

			<section id="query_usecases_lob_oracle8i_datasourece">
          		<title>DataSource service configuration file sample</title>

          		<para>
          			Make sure to modify the property of defaultAutoCommit to false.
          			<programlisting language="xml"><![CDATA[<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
            destroy-method="close">
    <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
    <property name="url" value="jdbc:oracle:thin:@localhost:1521:oracle"/>
    <property name="username" value="system"/>
    <property name="password" value="manager"/>
    <]]><emphasis role="bold">property name="defaultAutoCommit" value="false"/</emphasis><![CDATA[>     
</bean>]]></programlisting>
				</para>
        	</section>

        	<section id="query_usecases_lob_oracle8i_transaction">
          			<title>TransactionManager configuration file sample</title>

          			<para>
          				The property of DataSource service defaultAutoCommit is defined as false,
						so TransactionManager needs to be defined.
          				<programlisting language="xml"><![CDATA[<bean id="txManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> 
    <property name="dataSource" ref="dataSource"/>
</bean>

<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
        <tx:method name="*" propagation="REQUIRES_NEW"
            rollback-for="Exception" />
    </tx:attributes>
</tx:advice>    

<aop:config>
    <aop:pointcut id="executionMethods"
        expression="execution(* org.anyframe.query..impl.QueryServiceImpl.*(..))" />
    <aop:advisor advice-ref="txAdvice"
        pointcut-ref="executionMethods" />
</aop:config>]]></programlisting></para>
			</section>

			<section id="query_usecases_lob_oracle8i_xml">
          		<title>Mapping XML file sample</title>

          		<para>
          			In case of SQL statement to INSERT new LOB data,
					lobStatement tag must be additionally defined unlike general SQL statement definition.
          			<programlisting language="xml"><![CDATA[<query id="insertBlobClobWithOra8i" isDynamic="false">
    <statement>insert into binary values(?,empty_blob(),empty_clob())</statement>       
    <param  type="INTEGER"/>	
    <]]><emphasis role="bold">lobStatement</emphasis><![CDATA[>
        <statement>select  myclob, myblob
            from binary where bin_id = ? for update</statement>
        <param type="INTEGER"/>             
    <]]><emphasis role="bold">/lobStatement</emphasis><![CDATA[>                                                 
</query>]]></programlisting>
				</para>
			</section>
		</section>
	</section>

	<section id="query_usecases_vo">
		<title>Named Parameter 'vo'</title>

		<para>
			When passing input parameters to Query service which is required to execute SQL statement defined in
			mapping XML file, it is possible to pass in vo object which contains each parameters.
			Therefore, even when the number or name of input parameter changes,
			modification can be applied only by changing SQL statement in mapping XML file
			instead of changing logic that uses Query Service.
			As a result, modifying SQL statement becomes easier.
		</para>

		<section id="query_usecases_vo_attribute">
			<title>Configuration file sample</title>

			<para>
				The following is a part of context-query.xml file which defines Query service
				and context-query-sqlloader.xml file which defines the location of mapping XML file to be loaded in Query service.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    ...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>
			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader">
    <config:configuration>
        <filename>classpath:/query/mapping-query-namedparamvo.xml</filename>
        ...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_vo_xml">
			<title>Mapping XML file sample</title>

			<para>
				The following is mapping-query-namedparamvo.xml which was loaded through the above-mentioned Query service. 
				It contains various SQL statements using 'vo' passed as named parameter.
				Query service calls getter method relevant to attribute name after . from the object
				whose parameter name is 'vo' and get input value. After setting the input value to PreparedStatement, execute SQL statement.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="insertCategory">
            <statement>
                INSERT INTO TBL_CATEGORY 
                    (CATEGORY_NO, CATEGORY_NAME, CATEGORY_DESC, USE_YN, REG_ID, 
                    REG_DATE, MODIFY_ID, MODIFY_DATE) 
                VALUES (]]><emphasis role="bold">:vo.categoryNo, :vo.categoryName, :vo.categoryDesc, 
                    :vo.useYn, :vo.regId, sysdate, :vo.regId, sysdate</emphasis><![CDATA[)
            </statement>	
        </query>	
        <query id="updateCategory">
            <statement>
                UPDATE TBL_CATEGORY  
                SET CATEGORY_NAME =]]> <emphasis role="bold">:vo.categoryName,</emphasis> 
                    <emphasis role="bold">CATEGORY_DESC = :vo.categoryDesc, 
                    USE_YN =:vo.useYn, MODIFY_ID = :vo.modifyId,
                    MODIFY_DATE = sysdate</emphasis><![CDATA[
                WHERE CATEGORY_NO = ]]><emphasis role="bold">:vo.categoryNo</emphasis><![CDATA[
            </statement>
        </query>	
        <query id="deleteCategory">
            <statement>
                delete from TBL_CATEGORY where CATEGORY_NO = ]]><emphasis role="bold">:vo.categoryNo</emphasis><![CDATA[
            </statement>	
        </query>
        <query id="findCategoryList">
            <statement>
                SELECT CATEGORY_NO, CATEGORY_NAME, CATEGORY_DESC, USE_YN, REG_ID
                FROM TBL_CATEGORY
                WHERE CATEGORY_NO like ]]><emphasis role="bold">:vo.categoryNo</emphasis><![CDATA[
            </statement>
            <result class="anyframe.sample.domain.Category"></result>
        </query>
        <query id="findCategory">
            <statement>
                SELECT CATEGORY_NO, CATEGORY_NAME, CATEGORY_DESC, USE_YN, REG_ID
                FROM TBL_CATEGORY
                WHERE CATEGORY_NO = ]]><emphasis role="bold">:vo.categoryNo</emphasis><![CDATA[
            </statement>
            <result class="anyframe.sample.domain.Category"></result>
        </query>					
    </queries>
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_vocode_test">
			<title>Test code sample</title>

			<para>
				The following is a part of test code to execute INSERT, SELECT, UPDATE, DELETE statements
				defined in the above-mentioned mapping XML file.
				You can see that when passing input parameter to Query service,
				mapping of parameter name 'vo' with category or SearchVO object is being performed.
				<programlisting language="java">/**
 * When passing input parameter value to Query service, pass objects in named parameter format.
 * By calling getter method of each object, Query service sets and executes parameter value of INSERT statement.
 */
public Category testInsertCategory() throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    Category category = makeCategory();
    
    Object[] args = new Object[] { "vo", category };
    int result = queryService.create("insertCategory",
        new Object[] { args });

    if (result != 1) {
        throw new Exception("Insert a new category failed");
    }

    return category;
}

/**
 * When passing input parameter value to Query service, pass objects in named parameter format.
 * By calling getter method of each object, Query service sets and executes parameter value of UPDATE statement.
 */
public void updateCategory(Category category) throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");
    category.setCategoryName("testUpdate");

    Object[] args = new Object[] { "vo", category };
    int result = queryService.update("updateCategory",
        new Object[] { args });

    if (result != 1) {
        throw new Exception("Update category failed");
    }
}

/**
 * When passing input parameter value to Query service, pass objects in named parameter format.
 * By calling getter method of each object, Query service sets and executes parameter value of DELETE statement.
 */
public void deleteCategory(Category category) throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    Object[] args = new Object[] { "vo", category };
    int result = queryService.remove("deleteCategory",
        new Object[] { args });

    if (result != 1) {
        throw new Exception("Delete category failed");
    }

    args = new Object[] { "vo", category };
    <![CDATA[List<Category> rtCollection]]> = queryService.find("findCategory",
        new Object[] { args });

    if (rtCollection.size() != 0) {
        throw new Exception("Find categorylist failed");
    }
}

/**
 * When passing input parameter value to Query service, pass objects in named parameter type.
 * By calling getter method of each object, Query service sets and executes parameter value of SELECT statement.
 */
public void findCategory(String categoryNo, String categoryName)
		throws Exception {
    QueryService queryService = (QueryService) context.getBean("queryService");

    Category searchVO = new Category();
    searchVO.setCategoryNo(categoryNo);

    Object[] args = new Object[] { "vo", searchVO };
    <![CDATA[List<Category> rtCollection]]> = queryService.find("findCategory",
        new Object[] { args });

    if (rtCollection.size() != 1) {
        throw new Exception("Find category failed");
    }

    Category category = (Category) rtCollection.iterator().next();
    if (!(categoryNo.equals(category.getCategoryNo()) &amp;&amp; categoryName
        .equals(category.getCategoryName()))) {
        throw new Exception("Find category failed");
    }
}</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_dao">
		<title>extends QueryServiceDaoSupport</title>

		<para>
			In general, DAO (Data Access Object) class play a role which performs data access logic by using Query service.
			To develop such DAO class more conveniently, 
			Query service provides org.anyfram.query.dao.QueryServiceDaoSupport class and has the following features.
		</para>

		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold">Input parameter can be contained in VO, Map, List, Object[].</emphasis>
				</para>
				<para>
					As input parameter is handled as named parameter, handling of Map contains VO, ArrayList contains VO, etc. can be also possible. 
				    So, DAO code can become simpler.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">Perform common logic required to handle single row to be searched.</emphasis>
				</para>

				<para>
				    find(), findBySQL() method of query service contains SELECT statement execution result in collection object. 
					Therefore, if the search result is single, logic to extract single data from collection must be added.
					<programlisting language="java">if (collection == null || collection.size() == 0)
    return null;
return collection.iterator().next();</programlisting>
				</para>

				<para>
					By calling findByPk(...) method provided in QueryServiceDaoSupport,
					single data can be gotten without repetitively implementing the above-mentioned additional logic.
				</para>
			</listitem>

			<listitem>
				<para>
					<emphasis role="bold">Execute logic to save search result in a page object 
					for the convenience of UI development.</emphasis>
				</para>

				<para>
					When calling findWithRowCount() method of Query service,
					execution result of SELECT statement is contained in Map and returned, 
					and for the convenience of UI development, developr must add logic to extract required data from Map and put it in a page object.
					<programlisting language="java">List resultList = (List)queryMap.get(QueryService.LIST);
int totalSize = ((Long) queryMap.get(QueryService.COUNT)).intValue();
return new Page(resultList, (new Integer(pageIndex)).intValue(),
    totalSize, pageUnit, pageSize);</programlisting>
				</para>

				<para>
					By calling findListWithPaging() method, QueryServiceDaoSupport can get anyframe.common.Page object
					even without repetitively implementing the above-mentioned logic.
					</para>
			</listitem>
		</itemizedlist>

		<section id="query_usecases_dao_xml">
			<title>Mapping XML file sample</title>

			<para>
				The following is a part of mapping-query-queryservicedaosupport.xml loaded through Query service. 
				If contains various SQL statements including named parameter.
				<programlisting language="xml"><![CDATA[<queryservice>
    <queries>
        <query id="]]><emphasis role="bold">createProduct</emphasis><![CDATA[">
            <statement>
                INSERT INTO PRODUCT 
                    ( PROD_NO, PROD_NAME, SELLER_ID, CATEGORY_NO, PROD_DETAIL, 
                    MANUFACTURE_DAY, AS_YN, SELL_QUANTITY, SELL_AMOUNT, IMAGE_FILE, 
                    REG_DATE ) 
                VALUES (:vo.prodNo, :vo.prodName, :vo.sellerId, :vo.category.categoryNo, 
                    :vo.prodDetail, :vo.manufactureDay, :vo.asYn, :vo.sellQuantity, 
                    :vo.sellAmount, :vo.imageFile, sysdate)
            </statement>
        </query>

        <query id="]]><emphasis role="bold">updateProduct</emphasis><![CDATA[">
            <statement>
                UPDATE PRODUCT 
                SET PROD_NAME = :vo.ProdName,
                    PROD_DETAIL = :vo.prodDetail,
                    MANUFACTURE_DAY = :vo.manufactureDay,
                    AS_YN = :vo.asYn,
                    SELL_QUANTITY = :vo.sellQuantity,
                    SELL_AMOUNT = :vo.sellAmount,
                    REG_DATE = sysdate
                WHERE PROD_NO = :vo.ProdNo
            </statement>
        </query>

        <query id="]]><emphasis role="bold">findProductByPk</emphasis><![CDATA[">
            <statement>
                SELECT	PROD_NO, PROD_NAME, SELLER_ID, CATEGORY_NO, PROD_DETAIL, 
                    MANUFACTURE_DAY, AS_YN, SELL_QUANTITY, SELL_AMOUNT, IMAGE_FILE, 
                    REG_DATE 
                FROM PRODUCT
                WHERE PROD_NO = :vo.ProdNo
            </statement>
            <result class="anyframe.sample.domain.Product">
                <result-mapping column="{CATEGORY_NO}" attribute="{category.categoryNo}" />
            </result>
        </query>

        <query id="]]><emphasis role="bold">removeProduct</emphasis><![CDATA[">
            <statement>
                DELETE FROM PRODUCT 
                WHERE PROD_NO = :vo.prodNo
            </statement>
        </query>

        <query id="]]><emphasis role="bold">findProductList</emphasis><![CDATA[">
            <statement>
                SELECT product.PROD_NO, product.PROD_NAME, product.SELLER_ID, 
                    product.CATEGORY_NO, product.PROD_DETAIL, product.MANUFACTURE_DAY, 
                    product.AS_YN, product.SELL_QUANTITY, product.SELL_AMOUNT, 
                    product.IMAGE_FILE, product.REG_DATE 
                FROM PRODUCT product 
                WHERE 
                    product.PROD_NAME like :vo.prodName
                    AND product.AS_YN = :vo.asYn
                ORDER BY product.PROD_NO DESC
            </statement>
            <result class="anyframe.sample.domain.Product">
                <result-mapping column="{CATEGORY_NO}" attribute="{category.categoryNo}" />
            </result>
        </query>
    </queries>
</queryservice>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_dao_classcode">
			<title>DAO class code sample</title>

			<para>
				The following is a part of ProductDaoImpl.java which extends QueryServiceDaoSupport.
				By calling QueryServiceDaoSupport-provided method, ProductDaoImpl logic
				which executes INSERT, UPDATE, DELETE, SELECT product information has become simpler.
				When extending QueryServiceDaoSupport class, in order to directly call API of Query service,
				call getQueryService() method.
				<programlisting language="java">public class ProductDaoImpl <emphasis
              role="bold">extends QueryServiceDaoSupport</emphasis> {
    // <emphasis role="bold">Execute INSERT statement whose query id is 'createProduct'</emphasis>
    public int createProduct(Product vo) {
        return <emphasis role="bold">super.create("createProduct", vo);</emphasis>
    }
	
    // <emphasis role="bold">Execute DELETE statement whose query id is 'deleteProduct'.</emphasis>
    public int deleteProduct(Product vo) throws Exception {
        return super.remove("removeProduct", vo);
    }
	
    // <emphasis role="bold">Execute SELECT statement whose query id is 'findProductByPk'.</emphasis>
    // <emphasis role="bold">Transfer product object which is the search result.</emphasis>
    public Product selectProduct(String prodNo) throws Exception {
        Product vo = new Product();
        vo.setProdNo(prodNo);
        <emphasis role="bold">Product resultVo = super.findByPk("findProductByPk", vo);</emphasis>
        return resultVo;
    }
	
    // <emphasis role="bold">Execute SELECT statement whose query id is 'findProductList'.</emphasis> 
    // <emphasis role="bold">Transfer page object, the search result.</emphasis>
    public Page selectProductList(Product vo, int pageIndex, int pageSize,
        int pageUnit) throws Exception {
        return <emphasis role="bold">super.findListWithPaging("findProductList", vo, pageIndex,</emphasis>
                <emphasis role="bold">pageSize, pageUnit);</emphasis>
    }
	
    // <emphasis role="bold">Execute UPDATE statement whose query id is 'updateProduct'.</emphasis>
    public int updateProduct(Product vo) throws Exception {
        return <emphasis role="bold">super.update("updateProduct", vo);</emphasis>
    }
}</programlisting>
			</para>
		</section>

		<section id="query_usecases_dao_attribute">
			<title>DAO class configuration file sample</title>

			<para>
				The following is a part of context-service.xml file which defined the properties of ProductDaoImpl class 
				which extends QueryServiceDaoSupport class.
				As QueryServiceDaoSupport uses Query service internally, set properties as bean id of Query service.
				<programlisting language="xml"><![CDATA[<bean id="productDAO" class="anyframe.sample.query.sales.dao.impl.ProductDaoImpl">
    <property name="queryService" ref="queryService" />
    <property name="propertiesService" ref="propertiesService" />
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_dao_testcode">
			<title>DAO class test code sample</title>

			<para>
				The following is a part of test code executing INSERT, SELECT, UPDATE, DELETE statements 
				defined in the above-mentioned mapping XML file.
				<programlisting language="java">/**
 * Test code to insert new data in DB through QueryServiceDaoSupport
 */
public void insertProduct() throws Exception {
    Category category = categoryService.get("CATEGORY-00004");
    Product product = new Product();
    product.setProdName("sample.sportsone");
    product.setCategory(category);
    product.setProdDetail("sports one detail");
    product.setSellerId("woos41");
    product.setAsYn("Y");
    product.setManufactureDay("20081225");
    product.setSellAmount(new Long(50));
    product.setSellQuantity(new Long(50));
    
	// Execute INSERT statement using query id defined in mapping XML file.
    <emphasis role="bold">productDao.create(product);</emphasis>
}

/**
 * Test code to search data inserted DB through QueryServiceDaoSupport
 */
public void selectProduct(String prodNo) throws Exception {
    // Execute SELECT statement using query id defined in mapping XML file
    Product vo = <emphasis role="bold">productDao.get(prodNo);</emphasis>
}

/**
 * Test code to paginate data inserted DB through QueryServiceDaoSupport
 */
public void selectProductList() throws Exception {
    ProductSearchVO searchVO = new ProductSearchVO();
    searchVO.setSearchCondition("0");
    searchVO.setSearchKeyword("sample.sportsone");
    searchVO.setPageIndex(1);
    searchVO.setPageSize(2);
    
    // Execute SELECT statement using query id defined in mapping XML file
    // and get pagination result.
    Page <emphasis role="bold">products = productDao.getPagingList(searchVO);</emphasis>
}

/**
 * Test code to update data inserted in DB through QueryServiceDaoSupport
 */
public void updateProduct(Product product) throws Exception {
    // Execute UPDATE statement using query id defined in mapping XML file.
    product.setProdName("sportsone-update");
    product.setProdDetail("sports one detail-update");
    
    <emphasis role="bold">productDao.update(product);</emphasis>
}

/**
 * Test code to delete data inserted in DB through QueryServiceDaoSupport
 */
public void deleteProduct(String prodNo) throws Exception {
    // Execute DELETE statement using query id defined in mapping XML file.
    <emphasis role="bold">productDao.remove(prodNo);</emphasis>
}					</programlisting>
			</para>
		</section>
	</section>

	<section id="query_usecases_resultsetmapper">   
		<title>implements IResultSetMapper</title>

		<para>
		    Query service executes SQL statement defined as mapping XML file, 
    		and returns the execution result in object or HashMap format defined in <![CDATA[<result>]]>.
			But, to contain the execution result in the object defined in <![CDATA[<result>]]>,
			Java Reflection API calling occurs, which reduces the performance when handling a large amount of data.
			In addition, when putting the execution result in HashMap,
			column value is set with column name as a key without calling Java Reflection API,
			but as data transferred through a specific method calling cannot be identified,
			there may be some disadvantage in application analysis and modification.
			To solve this issue, Query service provides ResultSetMapper execution.
			In other words, instead of handling SQL statement execution result through Query service, 
			it supports direct handling through custom ResultSetMapper which is additional implemented.
		</para>

		<section id="query_usecases_resultsetmapper_attribute">
			<title>Configuration file sample</title>

			<para>
				The following is a part of context-query.xml file which defines Query service
				and a part of context-query-sqlloader.xml file which defines the location of
				mapping XML file to be loaded in Query service.
				<programlisting language="xml"><![CDATA[<bean id="queryService" class="org.anyframe.query.impl.QueryServiceImpl">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
    <property name="sqlRepository" ref="sqlLoader"/>
    ...
</bean>
<bean id="jdbcTemplate" class="org.anyframe.query.impl.jdbc.PagingJdbcTemplate">
    <property name="dataSource" ref="dataSource" />
</bean>]]></programlisting>
			</para>

			<para>
				<programlisting language="xml"><![CDATA[<bean name="sqlLoader" class="org.anyframe.query.impl.config.loader.MappingXMLLoader    <config:configuration>
        <filename>classpath:/query/mapping-query-resultsetmapper.xml</filename>
        ...
    </config:configuration>		
</bean>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_resultsetmapper_xml">
			<title>Mapping XML file sample</title>

			<para>
				The following is a part of mapping-query-resultsetmapper.xml which was loaded through the above-mentioned query service, 
				and contains SQL statement.
				Execution result of SQL statement whose query id is findCustomerWithResultSetMapper
				is defined to be handled through anyframe.sample.query.CustomerMapper which is defined by user.
				<programlisting language="xml"><![CDATA[<queries>  		
    <query id="findCustomerWithResultSetMapper" isDynamic="false">
        <statement>select NAME, ADDRESS from TB_CUSTOMER where SSNO like ?</statement>
        <param type="VARCHAR"/>
        <result ]]><emphasis role="bold">mapper="anyframe.sample.query.CustomerMapper"</emphasis><![CDATA[/>
    </query>
</queries>]]></programlisting>
			</para>
		</section>

		<section id="query_usecases_resultsetmapper_code">
			<title>ResultSetMapper code sample</title>

			<para>
				Users can implement ResultSetMapper in the following order.
			</para>

			<orderedlist>
				<listitem>
					<para>
						Define class which implements org.anyframe.query.ResultSetMapper를, an interface provided in Query service
					</para>
				</listitem>
				<listitem>
					<para>
						Define callback method mapRow() whose input parameter is ResultSet
					</para>
				</listitem>

				<listitem>
					<para>
						By using ResultSet in mapRow() method,
						set the execution result in user-defined object and return.
					</para>
				</listitem>
			</orderedlist>

			<para>
				The following is a part of CustomerMapper.java defined in the above-mentioned mapping XML file.
				<programlisting language="java">public class CustomerMapper <emphasis
              role="bold">implements IResultSetMapper</emphasis> {

    <emphasis role="bold">public Customer mapRow(ResultSet resultSet) throws SQLException</emphasis> {
        Customer customer = new Customer();
        customer.setNm(resultSet.getString("name"));
        customer.setAddr(resultSet.getString("address"));
        return customer;
    }
}</programlisting>
			</para>
		</section>

		<section id="query_usecases_resultsetmapper_testcode">
			<title>Test code sample</title>

			<para>
				The following is a part of test code to execute SELECT statement which is defined in the above-mentioned mapping XML file.
				<programlisting language="java">/**
 * Test code that calls find() method of QueryService to execute SQL statement defined in mapping XML, 
 * and uses IResultSetMapper type mapper defined in mapping XML to check the mapping of return value. 
 */
 
public void findWithCustomResultSetMapper() throws Exception {
    QueryService queryService = (QueryService) context
            .getBean("queryService");

    // execute query
    <![CDATA[List<Customer> rtList]]> = queryService.find(
            "findCustomerWithResultSetMapper", new Object[] { "%123456%" });
    // assert a size of result
    if (rtList.size() != 3)
        throw new Exception("Fail to select with custom ResultSetMapper.");

    // assert in detail
    <![CDATA[Iterator<Customer> resultItr]]> = rtList.iterator();
    while (resultItr.hasNext()) {
        Customer customer = (Customer) resultItr.next();
        if (!customer.getAddr().equals("Seoul"))
            throw new Exception("Fail to compare result in defail.");
    }
}</programlisting>
			</para>
		</section>
	</section>
</chapter>
	
	