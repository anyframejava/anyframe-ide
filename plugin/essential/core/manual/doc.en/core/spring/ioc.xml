<chapter id="core_spring_ioc">
	<title>IoC(Inversion of Control)</title>
	<para>
		Anyframe includes various application frameworks which integrated and extend 
		best-of-breed open sources based on Spring. From Anyframe 4.5.0, it is based on Spring Framework 3.0.
		
		
	</para>
	
	<para>
		The core characteristic of Spring Framework is IoC. The concept of IoC is nothing new, but it gains
		a great deal of attention from developers with the advent of concept of lightweight container such as Spring Framework.
		As IoC is a concept not only in Spring Framework but also all the area with container functions,
		knowledge of this concept is necessary.
		
		
	</para>

	<itemizedlist>
		<listitem>
			<para>
				<emphasis role="bold">IoC(Inversion of Control)concept</emphasis>
			</para>

			<para>
				IoC stands for  Inversion of Control. Let's have a look at what inversion of control is.
				In the past, when developing application in Java, the control for work of creating Java object and relating dependency
				lied in the developed application. However, in the case of using Servlet, EJB, etc., 
				the control is transferred to Servlet Container, EJB Container, therefore container holds the control of the
				life-cycle of object. In this sense, IoC means that all the control for object including creating 
				and life-cycle have been inverted.
				Spring Framework also provides the function to manage the object creation and life-cycle management.
				In other words, it provides IoC Container function.
				
				
				
	 		</para>

			<para>What is Inversion of Control(hereinafter, IoC)?</para>

			<itemizedlist>
				<listitem>
					<para>Design pattern to solve component dependency resolution, configuration and life-cycle.
			
					</para>
				</listitem>
				<listitem>
					<para>
						DIP(Dependency Inversion Principle) or Hollywood Principle
						(Don't call us we will call you)is also used.
					</para>
				</listitem>
				<listitem>
					<para>
						To perform specific task, instead of creating or getting other components, it defines such dependency to outside
						and get through container.
						
	        		</para>
				</listitem>
			</itemizedlist>

			<mediaobject>
				<imageobject>
					<imagedata align="center" fileref="../image/core/spring/ioc.jpg" />
				</imageobject>
			</mediaobject>		
			
			<para>IoC has the following merits.
			</para>

			<itemizedlist>
				<listitem>
					<para>Enhanced re-usability of class/component 
					</para>
				</listitem>

				<listitem>
					<para>Easy unit test </para>
				</listitem>

				<listitem>
					<para>Easy to develop system through Assemble and Configure
					</para>
				</listitem>
      		</itemizedlist>
    	</listitem>
  	</itemizedlist>
    
    <itemizedlist>
		<listitem>
			<para>
				<emphasis role="bold">Relationship between IoC and Dependency Injection</emphasis>
			</para>

			<para>
				IoC Container function has been highlighted as the biggest merit of Spring Framework, but the concept itself
				had been existed long before Spring Framework began. Against this backdrop, Martin Flowler maintained that
				it is not proper to mention that IoC is the merit of Spring Framework and new concept must be used.
				It is said that  Dependency Injection is more proper than what Lightweight containers define IoC.
				Since the argument of Martin Flowler, developers have been classifying IoC concept in various way, 
				but the following is the most common way to distinguish the relationship between IoC and Dependency Injection.
				
				
				
      		</para>
      
      		<mediaobject>
				<imageobject>
					<imagedata align="center"
						fileref="../image/core/spring/ioc-dependencyinjection.jpg" />
				</imageobject>
			</mediaobject>
			<para></para>
			<itemizedlist>
				<listitem>
				
					<para>
						<emphasis role="bold">Dependency Lookup</emphasis>
					</para>

					<para>
						Dependency Lookup is looking up bean to use by using API provided in container in order to access the bean saved
						 in the repository. Therefore, as developers use bean through direct lookup, 
						 dependency occurs on API container.
						
						
          			</para>
          			
          			<itemizedlist>
						<listitem>
							<para>
								<emphasis role="bold"> Object management repository</emphasis>
							</para>

							<para>
								Every IoC container has its own repository to manage objects needed to be managed in each container.
							Servlet Container manages Servlet in web.xml and in EJB Container, 
							information defined in  ejb-jar.xml is saved in 
							JNDI repository. Likewise, Spring Framework also has a separate xml file as a repository to manage POJOs.
								
								
							</para>
						</listitem>
					</itemizedlist>
					
					<itemizedlist>
            			<listitem>
              				<para>
              					<emphasis role="bold">Dependency Lookup example</emphasis>
              				</para>

              				<para>
              					Implementation class is developed as the following.  
              				</para>
                            <programlisting language="java">public class IoCServiceImpl1 implements IoCService1, 
        <emphasis role="bold">ApplicationContextAware</emphasis> {
    public void setApplicationContext (ApplicationContext context) {
        IoCService2 iocService2 = <emphasis role="bold">(IoCService2)context.getBean("IoCService2")</emphasis>;
    }
}</programlisting>
                             
                             <para>
                             	Configuration file is developed as the following. 
                             </para>
      
                             <programlisting language="xml"><![CDATA[<bean id="IoCService1" class="….IoCServiceImpl1">
    ...
</bean>
<bean id=]]><emphasis role="bold">"IoCService2"</emphasis> <![CDATA[class="….IoCServiceImpl2">
    ...
</bean>]]></programlisting>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </itemizedlist>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">Dependency Injection (DI)</emphasis>
					</para>

					<para>
						Dependency Injection means that container automatically injects the dependency of each class based on 
						bean definition. As container automatically injects dependency, developers do not need to be involved in the
						dependency using API, hence reducing the dependency on container API. Developers only need to add the information
						that dependency is needed in bean definition file (repository management file).
						In addition, dependency injection is divided into Setter Injection and Constructor Injection type.
						
					
          			</para>

					<itemizedlist>
						<listitem>
							<para>
								<emphasis role="bold">Dependency Injection example</emphasis>
							</para>

							<para>
								The following is how to develop implementation class. 
							</para>
      
                            <programlisting language="java">public class IoCServiceImpl implements IoCService {	
    <emphasis role="bold">public void setDependencyBean(DepBean dependencyBean) {</emphasis>
        <emphasis role="bold">this.dependencyBean = dependencyBean;</emphasis>
    <emphasis role="bold">}</emphasis>
     ... 
}</programlisting>
                            
                            <para>
                            	The following is how to develop configuration file.
                            	
                            </para>
      
                            <programlisting language="xml"><![CDATA[<bean id="IoCService" class="….IoCServiceImpl">
    <]]><emphasis role="bold">property name="dependencyBean" ref="depBean"</emphasis><![CDATA[/>
</bean>]]></programlisting>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </itemizedlist>
      
      		<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">Difference between Dependency Lookup and Dependency Injection</emphasis>
					</para>

					<para>
						Dependency Lookup is that developers themselves look up bean, while Dependency Injection is that container is
						automatically inject dependency when there are any dependency among classes.
						When using Dependency lookup, dependency occurs on container API for bean lookup.
						In this way, the more dependency on container API, the more dependent on the application container.
						Therefore, if you try not to use dependency look up as much as possible, you can reduce the dependency on container.
						How to reduce dependency on container is 
						introduced in <link linkend="core_spring_ioc_dependencies_injection">Dependency Injection</link>.
						
						
					</para>
				</listitem>
			</itemizedlist>
   		 </listitem>
  	</itemizedlist>

	<section id="core_spring_ioc_basic">
		<title>Basic</title>

		<para>
			Spring Framework is basically composed of Spring container and bean; Spring container runs and manages application
			business service and bean is managed by such container. Bean is an instanced object through container and is written and managed
			with other beans by container.
			
			
    	</para>
    	
    	<section id="core_spring_ioc_basic_bean">
      		<title>Container and Bean</title>

      		<para>
      			Bean makes a core part of application in Spring Framework and is managed by Spring IoC Container.
      			
      		</para>

			<itemizedlist>
				<listitem>
					<para>
						Bean set-up, creation, Life Cycle management
					</para>
				</listitem>

				<listitem>
					<para>
						Bean Wiring - Dependency of each bean is reflected as definition metadata by Spring IoC Container.
						
					</para>

					<mediaobject>
						<imageobject>
							<imagedata align="center" fileref="../image/core/spring/ioc-basic.jpg" />
						</imageobject>
					</mediaobject>
				</listitem>
			</itemizedlist>
		</section>

		<section id="core_spring_ioc_basic_container">
			<title>Container</title>

			<para>
				Spring IoC Container provides the two types of container as the following. 
			</para>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">BeanFactory</emphasis>
					</para>

					<informaltable>
						<tgroup cols="1">
							<thead>
								<row>
									<entry align="center">Description </entry>
								</row>
							</thead>

							<tbody>
								<row>
									<entry> Handle bean creating and extinction</entry>
								</row>

								<row>
									<entry> Configuration necessary for bean creation </entry>
								</row>

								<row>
									<entry> Calling method related to bean life-cycle</entry>
								</row>

								<row>
									<entry>
										Provide multiple BeanFactory interface implementation classes, 
										the most useful of which is XmlBeanFactory.
										</entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</listitem>
			</itemizedlist>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">ApplicationContext</emphasis>
					</para>

					<informaltable>
						<tgroup cols="1">
							<thead>
								<row>
									<entry align="center">Description</entry>
								</row>
							</thead>
		
							<tbody>
								<row>
									<entry>Provide all functions of BeanFactory</entry>
								</row>
		
								<row>
									<entry>Provide I18N using ResourceBundle file</entry>
								</row>
		
								<row>
									<entry>Provide various resource loading method</entry>
								</row>
		
								<row>
									<entry>Event handling</entry>
								</row>
		
								<row>
									<entry>Preload all Singleton beans when starting context->Can find error on setting and environment 
									at an early stage.
									</entry>
								</row>
		
								<row>
									<entry> Provide multiple ApplicationContext implementation classes(XmlWebApplicationContext,
											FileSystemXmlApplicationContext,ClassPathXmlApplicationContext)</entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
					
					<para>
					org.springframework.beans and org.springframework.context package provides the basic of IoC Container in Spring Framework.
					BeanFactory provides advance setting method of handling object and  ApplicationContext provides additional functions
					such as Spring AOP function, message resource handling, event proxy, WebApplicationContext integration for the use of web application.
					In other words, while BeanFactory provides setting framework and basic functions, ApplicaitonContext includes enterprise-centric
					functions as well as all the functions of BeanFactory.
					Other than the additional functions to ApplicationContext, another difference between ApplicationContext and
		          	BeanFactory is the way of loading Singleton Bean. BeanFactory delays bean creation until getBean() method is called (Lazy Loading).
		          	In contrast, ApplicationContext preloads all Singleton beans when starting context, thereby guaranteeing the immediate use
		          	of the bean whenever the bean is needed. By doing so, there is no need to wait for bean creation when running application.
		          
					
					
					
		          </para>
		        </listitem>
			</itemizedlist>

			<section id="core_spring_ioc_basic_container_beanfactory">
				<title>BeanFactory</title>

				<para>
					It is an actual representation of Spring IoC Container which includes and manages bean.
					The most commonly used implementation of BeanFactory is XmlBeanFactory, in xml type, 
					which defines the reference between application and object and creates defined system or application based on
					xml setting metadata.
					As the example below, XmlBeanFactory loads bean based on the definition of xml file.
					(Transfer object of org.springframework.core.io.Resource type to constructor.)
					
					
					
		        </para>

                <programlisting language="java">BeanFactory factory = new <emphasis role="bold">XmlBeanFactory(</emphasis>
new FileInputStream("beans.xml"));</programlisting>

				<para>
					For API regarding org.springframework.beans.factory.BeanFactory interface, refer to <ulink url="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html">
					here</ulink>.
					
				</para>

				<informaltable>
					<tgroup cols="2">
						<thead>
							<row>
								<entry align="center">Resource Implementation</entry>
		
								<entry align="center">Purpose</entry>
							</row>
						</thead>
		
						<tbody>
							<row>
								<entry align="left">org.springframework.core.io.ByteArrayResource</entry>
		
								<entry align="left">Defines a resource whose content is given
									by an array of bytes</entry>
							</row>
		
							<row>
								<entry align="left">org.springframework.core.io.ClassPathResource</entry>
		
								<entry align="left">Defines a resource that is to be retrieved
									from the classpath</entry>
							</row>
		
							<row>
								<entry align="left">org.springframework.core.io.DescriptiveResource
								</entry>
		
								<entry align="left">Defines a resource that holds a resource
									description but no actual readable resource</entry>
							</row>
		
							<row>
								<entry align="left">org.springframework.core.io.FileSystemResource</entry>
		
								<entry align="left">Defines a resource that is to be retrieved
									from the file system</entry>
							</row>
		
							<row>
								<entry align="left">org.springframework.core.io.InputStreamResource</entry>
		
								<entry align="left">Defines a resource that is to be retrieved
									from an input stream</entry>
							</row>
		
							<row>
								<entry align="left">org.springframework.web.portlet.context.
									PortletContextResource</entry>
		
								<entry align="left">Defines a resource that is available in a
									portlet context</entry>
							</row>
		
							<row>
								<entry align="left">org.springframework.web.context.support.
									ServletContextResource</entry>
		
								<entry align="left">Defines a resource that is available in a
									servlet context</entry>
							</row>
		
							<row>
								<entry align="left">org.springframework.core.io.UrlResource</entry>
		
								<entry align="left">Defines a resource that is to be retrieved
									from a given URL</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>
			</section>
			
			<section id="core_spring_ioc_basic_container_context">
        		<title>ApplicationContext</title>

        		<para>
        			The following is a general structure of org.springframework.context.ApplicationContext interface.
        			
        		</para>

		        <mediaobject>
        		  <imageobject>
            		<imagedata align="center"
                       fileref="../image/core/spring/ioc-basic-applicationcontext.jpg" />
			      </imageobject>
			    </mediaobject>
			
			    <para>
					The following is a frequently used implementation class of  ApplicationContext.
					
					
			    </para>
			
				<itemizedlist>
			      <listitem>
			        <para>
			         	XmlWebApplicationContext - Using internally when developing web-based Spring application
			        </para>
			      </listitem>
			
			      <listitem>
			        <para>
			            FileSystemXmlApplicationContext - ApplicationContext which reads xml configuration file located in file system
			        </para>
			      </listitem>
			
			      <listitem>
			        <para>
			           FileSystemXmlApplicationContext - ApplicationContext which reads xml configuration file located in file system 
			        </para>
			      </listitem>
				</itemizedlist>
				
				<para>
	                Implementation class of ApplicationContext can be used as the following.
	                
	                <programlisting language="java">ApplicationContext context = new <emphasis role="bold">FileSystemXmlApplicationContext</emphasis>("c:/beans.xml”);</programlisting>
	                <programlisting language="java">ApplicationContext context = new <emphasis role="bold">ClassPathXmlApplicationContext</emphasis>("beans.xml”);</programlisting>
                </para>
			</section>
			
			<section id="core_spring_ioc_basic_container_metadata">
        		<title>Setting metadata</title>

        		<para>
        			Let's have a look at how to set "instantiation, configuration, object composition" through container.
        			Most are provided in simple and intuitive xml type and define bean using xml-based setting metadata.
        			The following is the example of basic structure of xml-based configuration metadata.
        			
        			
                    <programlisting language="xml"><![CDATA[<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">
    <bean id="…" class="…">
        <!-- collaborators and configuration for this bean go here -->
    </bean>
        <!-- more bean definitions go here -->
</beans>]]></programlisting>
		        </para>
		        
		        <para>
		        	XML-based metadata configuration is the most commonly used type of configuration metadata.
		        	Other than xml, by using Java Properties file or processing with program (using Public API of Spring),
		        	it is possible to provide configuration metadata. This is because Spring IoC Container itself can be
		        	separated from configuration metadata type.
		        	
		        	
		        	
				</para>
      		</section>
      		
      		<section id="core_spring_ioc_basic_container_instance">
        		<title>Example of Spring IoC Container instancing</title>
					<orderedlist numeration="arabic" inheritnum="inherit">
						<listitem>
							<para>
							    Example of using BeanFactory
							</para>
                                <programlisting language="java">Resource resource = new FileSystemResource("beans.xml");
BeanFactory factory = new XmlBeanFactory(resource); </programlisting>
                                <programlisting language="java">ClassPathResource resource = new ClassPathResource("beans.xml");
BeanFactory factory = new XmlBeanFactory(resource);</programlisting>
		                </listitem>
		                <listitem>
			                <para>
			                    Example of using ApplicationContext
			                </para>
			                    <programlisting language="java">ApplicationContext context = 
        new ClassPathXmlApplicationContext(new String ("beans.xml"));
// of course, an ApplicationContext is just a BeanFactory
BeanFactory factory = (BeanFactory) context;</programlisting>
		                </listitem>
	                </orderedlist>	
            	</section>
			
			<section id="core_spring_ioc_basic_container_xml">
        		<title>XML-based configuration metadata composition</title>

        		<para>
        			XML-based configuration metadata can be defined separately in multiple xml file.
        			Note that <![CDATA[<import>]]> must be located before <![CDATA[<bean>]]>.
        			
        			
                        <programlisting language="xml"><![CDATA[<beans>
    <]]><emphasis role="bold">import resource="services.xml"/</emphasis><![CDATA[>
    <]]><emphasis role="bold">import resource="resources/messageSource.xml"/</emphasis><![CDATA[>
    <]]><emphasis role="bold">import resource="/resources/themeSource.xml"/</emphasis><![CDATA[>

    <bean id="bean1" class="…"/>
    <bean id="bean2" class="…"/>
</beans>]]></programlisting>
                </para>
                
                <para>
                	In the example above, external bean definition is loaded from three files (services.xml, messageSource.xml and themeSource.xml).
                	All the location is relative to xml file performing import. Therefore, messageSource.xml and
                	themeSource.xml must be located in resources under xml file to be imported, while services.xml
                	must be located in the same directory to the import file or classpath.
                	Like this example, '/' is actually ignored. The content of imported file must be xml bean configuration file
                	which is completely valid according to schema or DTD including <![CDATA[<beans>]]> at the top level.
                	
                	
        		</para>
      		</section>
    	</section>
    	
    	<section id="core_spring_ioc_basic_beans">
      		<title>Beans</title>

			<section id="core_spring_ioc_basic_beans_bean">
        		<title>Bean</title>

        			<para>
        				Bean is an object managed by Spring IoC Container and is created by configuration metadata provided in container
        				(usually XML <![CDATA[<bean>]]> type). Actually, it is represented as BeanDefinition object including main metadata information
        				as shown in the table below.
        				
        				
        			</para>

					<informaltable>
						<tgroup cols="2">
							<colspec colnum="1" colname="col1" colwidth="3*" />
							<colspec colnum="2" colname="col2" colwidth="7*" />
						<thead>
							<row>
								<entry align="center">Main metadata properties</entry>
								<entry align="center">Description</entry>
							</row>
						</thead>

						<tbody>
							<row>
								<entry align="left">id</entry>

								<entry align="left"> Information for dividing bean. Key to access the relevant bean.
								</entry>
							</row>
	
							<row>
								<entry align="left">class</entry>

								<entry align="left"> Actual implementation class of defined bean. Develop in full name all the time.
								</entry>
							</row>

							<row>
								<entry align="left">scope</entry>

								<entry align="left">
									Define the creation type of defined bean instancing; Select among singleton,
									prototype, request, session, globalSession.
									Default is singleton. For more details on Bean Scope, refer to Extensions
									<link linkend="core_spring_ioc_extensions_scope">Bean</link>
									
								</entry>
							</row>

							<row>
								<entry align="left">init-method</entry>
	
								<entry align="left">Define the initializing method called after the bean is initialized 
								
								</entry>
							</row>

							<row>
								<entry align="left">destroy-method</entry>

								<entry align="left">Define the called method when the bean is destroyed. </entry>
							</row>

							<row>
								<entry align="left">factory-method</entry>

								<entry align="left">Define when calling and creating a specific factory method without using constructor 
								when creating the relevant bean
								</entry>
							</row>

							<row>
								<entry align="left">lazy-init</entry>

								<entry align="left"> Has true/false value. Determine whether or not to initialize before the bean is called.
								When the default is false and true, it is initialized when the bean is called.
								</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>
			</section>

			<section id="core_spring_ioc_basic_beans_id">
				<title>Bean naming</title>

				<para>
					When defining bean, 'id' or 'name' attribute is used for dividing beans. When 'id' is used,
					one bean needs to have unique id in the container. Usually, when naming bean, standard Java rule is used on instance field.
					Bean name begins with lower case and camel-cased (first word starting with lower case and second one upper class).
					Examples are ‘genreService', 'movieDao',
					'movieFinderController',etc. Applying consistent method when naming bean makes it easier to read and understand.
					Applying such naming standard is not difficult. If you use spring AOP, it becomes easier when applying advice
					to the bean set related to bean name.
			
					
					
				</para>
			</section>

			<section id="core_spring_ioc_basic_beans_instantiation">
				<title>Bean instantiation</title>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">Instantiation using constructor</emphasis>
						</para>

						<para>
							No need to implement specific interface or code in specific type.
							
					        <programlisting language="xml"><![CDATA[<bean id="sampleBean" class="sample.SampleBean"/>
<bean name="anotherSample" class="sample.SampleBeanTwo"/>]]></programlisting>
				        </para>
			        </listitem>
		        </itemizedlist>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">Instancing using static factory method</emphasis>
						</para>

						<para>
							Created when bean object calls factory method. Note that this defines the class which does not specify
							returned object and includes factory method.
							In the example below, createInstance() must be static method.
							
							
                            <programlisting language="xml"><![CDATA[<bean id="sampleBean" class="sample.SampleBean2" 
    factory-method="createInstance"/>]]></programlisting>
						</para>
					</listitem>
				</itemizedlist>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">Instantiation using instance factory method</emphasis>
						</para>

						<para>
						Does not define 'class' attribute, but defines the bean including factory method in attribute.
							
                            <programlisting language="xml"><![CDATA[<!-- the factory bean, which contains a method 
called createInstance() --><bean id="myFactoryBean" class="…"/>
<!-- the bean to be created via the factory bean -->
<bean id="sampleBean"
    ]]><emphasis role="bold">factory-bean</emphasis><![CDATA[="myFactoryBean"
    ]]><emphasis role="bold">factory-method</emphasis><![CDATA[="createInstance"/>
    ...]]></programlisting>
				        </para>
					</listitem>
				</itemizedlist>
			</section>
		</section>
    	
		<section id="core_spring_ioc_basic_refer">
			<title>How to refer to Beans</title>

			<para>There are several ways to access Spring bean from business layer and presentation layer.
			</para>

			<section id="core_spring_ioc_basic_refer_business">
        		<title>Business layer</title>

        		<para>There are largely two ways of accessing Spring bean to use from business layer: Dependency Lookup and Dependency Injection.
        		
        		</para>

        		<itemizedlist>
          			<listitem>
            			<para><emphasis role="bold">Dependency Lookup</emphasis></para>

			            <para>
							Refers to Looking up bean to use to access bean saved in repository.
							In this case, as developers themselves lookup and use bean, dependency occurs on container API.
							For more information on Dependency Lookup of Spring IOC container,
							refer to <link linkend="core_spring_ioc">IoC</link> in this manual.
							
				        </para>

	            		<para>
	            		 	
	            		 	The following is an example of developing implementation class.
                            <programlisting language="java">public class IoCServiceImpl1 implements IoCService1, 
        <emphasis role="bold">ApplicationContextAware</emphasis> {
    public void setApplicationContext (ApplicationContext context) {
        IoCService2 iocService2 = <emphasis role="bold">(IoCService2)context.getBean("IoCService2");</emphasis>
    }
}</programlisting>
			        	</para>

                   	 	<para>
							The following is an example of developing configuration file.
                            <programlisting language="xml"><![CDATA[<bean id="IoCService1" class="….IoCServiceImpl1">
    ...
</bean>
<bean id=]]><emphasis role="bold">"IoCService2"</emphasis><![CDATA[ class="….IoCServiceImpl2">
    ...
</bean>]]></programlisting>
						</para>
          			</listitem>
        		</itemizedlist>

        		<itemizedlist>
        	 	 	<listitem>
        	 	   		<para>
							<emphasis role="bold">Dependency Injection</emphasis>
        	 	   		</para>

           				<para>
			           		When there is dependency needed in each class, as container automatically injects the dependency,
			           		there is no dependency on Container API.
			           		For more information on Dependency Injection  of Spring IoC, refer to <link linkend="core_spring_ioc_dependencies">
			            	Dependencies</link> in this manual.
			           		
		            	</para>

		            	<para>
		            		The following is an example of developing implementation class.
		            		In this example, Setter Injection method is introduced.
		            		
		            		
            	            <programlisting language="java">public class IoCServiceImpl implements IoCService {
    <emphasis role="bold">public void setDependencyBean(DepBean dependencyBean) {</emphasis>
        <emphasis role="bold">this.dependencyBean = dependencyBean;</emphasis>
    <emphasis role="bold">}</emphasis>
    ... 
}</programlisting>
					        </para>

            			<para>
            		 		The following is an example of developing configuration file.  
            	            <programlisting language="xml"><![CDATA[<bean id="IoCService" class="….IoCServiceImpl">
    <]]><emphasis role="bold">property name="dependencyBean" ref="depBean"/</emphasis><![CDATA[>
</bean>]]></programlisting>
				        </para>
					</listitem>
				</itemizedlist>
			</section>
    	
			<section id="core_spring_ioc_basic_refer_presentation">
				<title>Presentation layer</title>

				<para>
					Like business layer,there are two ways of accessing Spring bean from presentation layer: Lookup and Dependency Injection.
					Note that availability of the access method can be limited by web framework in use.
					For how to define web framework usage, refer to <link linkend=
					"core_springmvc_part"> Spring MVC</link>.
					
					
				</para>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">Dependency Lookup (Struts)</emphasis>
						</para>

						<para>
							When using Struts with web framework, you need to get Web ApplicationContext in Struts Action and use 
							getWebApplicationContext() method to get ApplicationContext.
							By using getWebApplicationContext() method in Action Support, get ApplicationContext.
							
			            </para>

						<para>
							The following is an example of developing action class. This example is a developed code using Anyframe
							and is a part of UpdateMovieAction inheriting DefaultActionSupport of Anyframe.
							Note that movieService Bean is used and bean id must be specified in Action class.
							
							
                            <programlisting language="java">public class UpdateMovieAction extends <emphasis role="bold">DefaultActionSupport</emphasis> {
    public ActionForward process(ActionMapping mapping, ActionForm form,
    HttpServletRequest req, HttpServletResponse res) throws Exception {
        ApplicationContext ctx = <emphasis role="bold">getWebApplicationContext()</emphasis>;
        MovieService movieService = (MovieServiceImpl) <emphasis role="bold">ctx.getBean</emphasis> ("movieServiceImpl");
        ...
     }
}</programlisting>
						</para>

						<para>
							The following is an example of developing configuration file. 
                            <programlisting language="xml"><![CDATA[<bean id=]]><emphasis 
    role="bold">"movieServiceImpl"</emphasis>
    <![CDATA[class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl">
    ...
</bean>]]></programlisting>
                        </para>
					</listitem>
				</itemizedlist>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">Dependency Injection (Spring MVC)</emphasis>
						</para>

						<para>
							When using Spring MVC as web framework, you can refer to Spring bean using dependency Injection method
							in Controller class.
							
							
            			</para>

						<para>
							
							The following is an example of developing controller class. 
							This example is a developed code using Anyframe
							and is a part of MovieController class.
							movieService bean is used, and in this case bean id is defined in MVC configuration file.
							
							
							
                            <programlisting language="java">public class MovieController{
    <emphasis role="bold">private MovieService movieService;</emphasis>;

    <emphasis role="bold">public void setMovieService(MovieService movieService) {</emphasis>
        <emphasis role="bold">this.movieService = movieService;</emphasis>
    }
    ...

    public ModelAndView list(HttpServletRequest request,
    HttpServletResponse response) throws Exception {
        Movie movie = new Movie();
        bind(request, movie);
        Page resultPage = <emphasis role="bold">movieService.getPagingList(movie);</emphasis>
    ...
    }
}</programlisting>
			            </para>

						<para>
							The following is an example of developing configuration file. 
                            <programlisting language="xml"><![CDATA[<bean name="/coreMovie.do"
        class="org.anyframe.plugin.core.moviefinder.web.MovieController">
    <]]><emphasis role="bold">property name="movieService"
    ref="coreMovieService"/</emphasis><![CDATA[>
    <property name="genreService" ref="coreGenreService"/>
 </bean>]]></programlisting>
						</para>
					</listitem>
				</itemizedlist>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">Dependency Lookup (Spring MVC)</emphasis>
						</para>

						<para>
							When using Spring MVC as web framework, Spring bean can be referred in Dependency lookup method in general class, not
							Controller class. After reading Spring configuration file from the web, create and save this at ServletContext
							of the relevant web application. Therefore, if ServletContext is accessible, you can get WebApplicationContext
							from general class as well. 
							
							
			            </para>

						<para>
							The following is an example of developing  in general class,
                        <programlisting language="java"><emphasis role="bold">WebApplicationContet ctx = 
    </emphasis><emphasis role="bold"> WebApplicationContextUtils.getWebApplicationContext(servletContext);</emphasis>
MovieService movieService = (MovieServiceImpl)<emphasis role="bold">ctx.getBean</emphasis>("movieServiceImpl");
    ...</programlisting>
						</para>

						<para>
			        		The following is an example of developing configuration file. 
				            <programlisting language="xml"><![CDATA[<bean id=]]><emphasis role="bold">"movieServiceImpl"</emphasis>
        <![CDATA[class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl">
    ...
</bean>]]></programlisting>
						</para>
					</listitem>
				</itemizedlist>
			</section>
    	</section>
  	</section>

	<section id="core_spring_ioc_dependencies">
    	<title>Dependencies</title>

    	<para>
    		Typical enterprise application is not created as a single object (or bean in Spring).
    		It is certain that even the simplest application had small number of objects that work together.
    		In this chapter, let's have a look at how many independent beans work together for object to accomplish several goals (usually
    		application that performs that end user want).
    		
    		
		</para>

		<section id="core_spring_ioc_dependencies_injection">
      		<title>Dependency Injection(DI)</title>

      		<para>
      			It means that container automatically injects dependency of each class based on bean definition information.
      			As container automatically injects dependency, developers do not need to be involved in dependency using container API.
      			By doing so, container API dependency decreases and developers only need to add the information that dependency
      			 is needed in bean definition file (repository management file).
      			 This is divided into Setter Injection and Constructor Injection type.
    
      			
      			
	  		</para>

      		<section id="core_spring_ioc_dependencies_injection_setter">
        		<title>Setter Injection</title>

        		<para>
        			When initializing through setter method implementation, this receives specific resources dependent on container.
        			After constructor or static factory method without parameter is called from bean instancing, bean setter method is called and
        			realized. The following is the part of Setter Injection in MovieServiceImpl.java.
     
        	       
        	        <programlisting language="java"><![CDATA[public class MovieServiceImpl implements MovieService {
    public void ]]><emphasis role="bold">set</emphasis><![CDATA[MovieDao(MovieDao movieDao) {
        this.movieDao = movieDao;
    }
    ... 
}]]></programlisting>		
            	</para>

        		<para>
        			The following is a part of context-core.xml, configuration file of Setter Injection.
        			
        			
        	        <programlisting language="xml"><![CDATA[<bean id="coreMovieService"
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl">
    <]]><emphasis role="bold">property name="movieDao" ref="coreMovieDao"</emphasis><![CDATA[ />
</bean>
	
<bean id="coreMovieDao" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieDao">
</bean>]]></programlisting>
				</para>
      		</section>

      		<section id="core_spring_ioc_dependencies_injection_constructor">
        		<title>Constructor Injection</title>

       			<para>
	       			When initializing through constructor implementation, by getting a specific dependent resource from container,
	       			call and realize constructor with multiple parameters showing each collaborator.
	       			In addition, calling static factory with specific parameter for bean creation, calling static factory method 
	       			with specific parameter for bean creation can be regarded as similar.
	       			The following is the part of Constructor Injection in MovieServiceImpl.java that is an implementation class of MovieService interface.
	       			
        	        <programlisting language="java"><![CDATA[public class MovieServiceImpl implements MovieService {
    MovieDao movieDao;
    ]]><emphasis role="bold">public MovieServiceImpl(MovieDao movieDao) {</emphasis>
        <![CDATA[super(movieDao);
        ]]><emphasis role="bold">this.movieDao = movieDao;</emphasis><![CDATA[
    }
        ...
}]]></programlisting>
				</para>

        		<para>
        		The following is an example of context-core.xml, configuration file of Constructor Injection.
        			 
        	        <programlisting language="xml"><![CDATA[<bean id="coreMovieService" 
    class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl">
    <]]><emphasis role="bold">constructor-arg ref="coreMovieDao"/</emphasis><![CDATA[>
</bean>
        
<bean id="coreMovieDao" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieDao">
    ...
</bean>]]></programlisting>
				</para>

        		<para>
        			By using type, using configuration file,class type of argument of Constructor can be defined explicitly.
        			 
        	        <programlisting language="xml"><![CDATA[<bean id="coreMovieService" 
    class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl">
    <constructor-arg ]]><emphasis role="bold">type="org.anyframe.plugin.core.moviefinder.service.BeanA"</emphasis><![CDATA[ ref="beanA"/>
    <constructor-arg ]]><emphasis role="bold">type="org.anyframe.plugin.core.moviefinder.service.BeanB"</emphasis><![CDATA[ ref="beanB"/>
</bean>]]></programlisting>
				</para>

        		<para>
        			When the number of constructor argument is two or more and argument of same class type exists,
        			to avoid ambiguity, defining value is available in order of argument through index configuration.
        			
        	        <programlisting language="xml"><![CDATA[<bean id="coreMovieService"
    class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl">
    <constructor-arg index="0" ref="beanA" /> 
    <constructor-arg index="1" ref="beanB" /> 
</bean>]]></programlisting>
				</para>
      		</section>
      		
			<section id="core_spring_ioc_dependencies_injection_compare">
        		<title>Setter Injection vs. Constructor Injection</title>

        		<informaltable>
					<tgroup cols="2">
						<thead>
							<row>
								<entry align="center">Merits of Setter Injection</entry>

								<entry align="center">Merits of Constructor Injection</entry>
							</row>
						</thead>

						<tbody>
							<row>
								<entry>- Prevent constructor parameter list from getting longer</entry>

								<entry align="left">- Force strong dependency injection</entry>
							</row>

							<row>
								<entry>- Prevent the increase of the number of constructor</entry>

								<entry align="left">- Inhibit the overuse of setter method</entry>
							</row>

							<row>
								<entry>- Prevent Circular dependencies</entry>

								<entry align="left">
									- Prevent modifying property value by mistake through removing unnecessary setter method
									</entry>
							</row>
						</tbody>
					</tgroup>
        		</informaltable>

       		 	<itemizedlist>
          			<listitem>
            			<para><emphasis role="bold">Circular dependencies</emphasis></para>

            			<para>
            				Need to be careful when using Constructor Injection. The following is an example, when two different beans
            				refer to bean each other as constructor argument.
            				
            	            <programlisting language="xml"><![CDATA[<bean id="beanFirst" class="test.BeanFirst">
    <constructor-arg ref="beanSecond" />
</bean>

<bean id="beanSecond" class="test.BeanSecond">
    <constructor-arg ref="beanFirst" />
</bean>]]></programlisting>
						</para>
          			</listitem>
        		</itemizedlist>
			</section>

      		<section id="core_spring_ioc_dependencies_injection_factor">
       	 		<title>Analysis of constructor parameter</title>

        		<para>In analysis of constructor, there are type matching and index.</para>

        		<itemizedlist>
          			<listitem>
            			<para><emphasis role="bold">Matching parameter type of constructor</emphasis></para>

            			<para>
            				By specifying parameter type of constructor explicitly using 'type' attribute, 
            				type matching to simple type is possible.
            				
            	            <programlisting language="xml"><![CDATA[<bean id="sampleBean" class="sample.SampleBean">
    <constructor-arg ]]><emphasis role="bold">type="int"</emphasis><![CDATA[><value>7500000</value></constructor-arg>
    <constructor-arg ]]><emphasis role="bold">type="java.lang.String"</emphasis><![CDATA[><value>42</value></constructor-arg>
</bean>]]></programlisting>
						</para>
          			</listitem>
        		</itemizedlist>

        		<itemizedlist>
          			<listitem>
            			<para><emphasis role="bold">Parameter index of constructor </emphasis></para>

            			<para>
            				Parameter of constructor can have explicitly specified index using index property.
            				In addition, specifying index can solve the ambiguity when parameters of constructor have same type.
            				(Note. Index starts from zero.)
            				
            				
            	            <programlisting language="xml"><![CDATA[<bean id="sampleBean" class="sample.SampleBean">
    <constructor-arg ]]><emphasis role="bold">index="0"</emphasis><![CDATA[ value="7500000"/>
    <constructor-arg ]]><emphasis role="bold">index="1"</emphasis><![CDATA[ value="42"/>
</bean>]]></programlisting>
						</para>
          			</listitem>
        		</itemizedlist>
      		</section>
    	</section>

		<section id="core_spring_ioc_dependencies_property">
			<title>Bean Property and constructor parameter</title>

			<para>
				Bean property and constructor parameter can refer to other management bean (collaborator) or inline defined value.
				For such purpose,xml-based configuration metadata in Spring supports a great deal of subtags in <![CDATA[<property>]]>
				and <![CDATA[<constructor-arg>]]>.
				
			</para>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">Primitive Type - Support pure value</emphasis>
					</para>

					<para>
						<![CDATA[<value>]]> specifies property or constructor parameter like string that people can read.
						.
					    <programlisting language="xml"><![CDATA[<bean id="myDataSource" destroy-method="close">
    <property name="driverClassName">
        <]]><emphasis role="bold">value</emphasis><![CDATA[>]]><emphasis
		    role="bold">com.mysql.jdbc.Driver</emphasis><![CDATA[<]]><emphasis
		role="bold">/value</emphasis><![CDATA[>
    </property>
</bean>]]></programlisting>
					</para>
				</listitem>
			</itemizedlist>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold"> <![CDATA[<ref>]]>
							Element 
						</emphasis>
					</para>

					<para>
						<![CDATA[<ref>]]>, reference to other bean, is the last element allowed in <![CDATA[<constructor-arg>]]>
						or <![CDATA[<property>]]>. This is used when setting property value for referring to other beans managed by container.
						All references are ultimately reference to other object, but there are three ways in specifying id/name of other
						object. 						The most common way is specifying the target bean 
						using bean property of <![CDATA[<ref>]]>, and creating reference to some bean in container (regardless of xml type)
						 or parent container will be allowed. Property value of 'bean' will be either 'id' property or 'name' property 
						 of the same bean.
						
						
						
					</para>

					<itemizedlist>
						<listitem>
							<para>
								Reference to other bean
							    <programlisting language="xml"><![CDATA[<!-- Property value of ‘bean’ is either 'id' or 'name' property of other bean.-->
<ref bean="someBean"/>]]></programlisting>
							</para>

							<para>
							    <programlisting language="xml"><![CDATA[<!-- Property value of ‘local’ is 'id'property of other bean in xml file. -->
<ref local="someBean"/>]]></programlisting>
							</para>
						</listitem>

						<listitem>
							<para>
								Reference to other bean existing in parent context (using parent property)
							    <programlisting language="xml"><![CDATA[<!-- in the parent context -->
<bean id="]]><emphasis role="bold">accountService</emphasis><![CDATA[" 
        class="com.foo.SimpleAccountService">
    <!-- insert dependencies as required as here -->	
</bean>]]></programlisting>
							</para>

							<para>
							    <programlisting language="xml"><![CDATA[<!-- in the child (descendant) context -->
<bean id="movieService" class="com.foo.SimpleMovieService">
    <]]><emphasis role="bold">ref parent="accountService"</emphasis><![CDATA[/>
</bean>]]></programlisting>
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">inner Bean</emphasis>
					</para>

					<para>
						 <![CDATA[<bean>]]> in <![CDATA[<property>]]> or <![CDATA[<constructor-arg>]]> is used to define what is called 'inner bean'.
						 When defining inner bean, as id, name, scope value are ignored by container, the best way is not specifying id or name value.
						 Inner bean is always anonymous and runs in prototype.
						
					    <programlisting language="xml"><![CDATA[<bean id="outer" class="…">
    <!-- instead of using a reference to a target bean, simply define the target inline -->
    <property name="target">
        <]]><emphasis role="bold">bean class="com.mycompany.Person"</emphasis><![CDATA[> 
            <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        <]]><emphasis role="bold">/bean</emphasis><![CDATA[>
    </property>
</bean>]]></programlisting>
					</para>
				</listitem>
			</itemizedlist>

			<itemizedlist>
				<listitem>
				
					<para>
						<emphasis role="bold">Collection</emphasis>
					</para>

					<para> 
						<![CDATA[<list> , <set> , <map> and <props>]]> is mapped in List, Set, Map and Properties type of Java Collection.
						In addition, in the case of object array type, value can be defined by using comma(,).
						(ex. String]).
					    <programlisting language="xml"><![CDATA[<bean id="moreComplexObject" class="sample.ComplexObject">
    <!-- results in a setAdminEmails(]]><emphasis role="bold">java.util.Properties</emphasis><![CDATA[) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@somecompany.org</prop>
        </props>
    </property>

    <!-- results in a setSomeList(]]><emphasis role="bold">java.util.List</emphasis><![CDATA[) call -->
    <property name="someList"> 
        <list>
            <value>a list element followed by a reference</value>
                <ref bean="myDataSource" />
        </list>
    </property>

    <!-- results in a setSomeMap(]]><emphasis role="bold">java.util.Map</emphasis><![CDATA[) call -->
    <property name="someMap">
        <map>
            <entry>
                <key>
                    <value>entry key</value>
                </key>
                    <value>entry value</value>
             </entry>
        </map>
    </property>

    <!-- results in a setSomeSet(]]><emphasis role="bold">java.util.Set</emphasis><![CDATA[) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
                <ref bean="myDataSource" />
        </set>
    </property>

    <!-- results in a setSomeArray(]]><emphasis role="bold">String[]</emphasis><![CDATA[) call -->
    <property name="someArray" value="str1,str2,str3,str4"/>  
</bean>]]></programlisting>
					</para>
				</listitem>
			</itemizedlist>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">Merging Collection</emphasis>
					</para>

					<para>
						It is possible to define <![CDATA[<list> , <map > , <set> or <props>]]> which works as parent and define 
						<![CDATA[<list> , <map> , <set> or <props>]] which inherit them.
						For example, you can get the value of child collection by merging value specified in parent collection and the one in 
						child collection.
						
						
					</para>

					<para>
						Description) In <![CDATA[<props>]]> of adminEmails Property in child bean, if you use 
						<emphasis role="bold">merge=true</emphasis> property, child bean is actually analyzed and instanced by container
						and has <emphasis role="bold">merge=true</emphasis> that parent adminEmails collection and child adminEmails collection
						is merged.This merging is applied to  <![CDATA[<list> , <map>, and <set>]]> collection type in a similar way.
						But, in the case of <![CDATA[<list>]]>, this meaning is related to list collection.
						For example, the concept of ordered collection of value is maintained and managed. Parent value precedes all child list. 
						In the case , it is affected by collection type regarding Properties collection type related to Map, Set and
						Properties object type which are used by container internally.
						
						
						
						
					    <programlisting language="xml"><![CDATA[<beans>
    <bean id="parent" abstract="true" class="sample.ComplexObject">
        <property name="adminEmails">
            <props>
                <prop key="administrator">administrator@somecompany.com</prop>
                <prop key="support">support@somecompany.com</prop>
            </props>
        </property>
    </bean>
    <bean id="child" ]]><emphasis role="bold">parent="parent"</emphasis><![CDATA[>
        <property name="adminEmails">
        <!-- the merge is specified on the *child* collection definition -->
            <props ]]><emphasis role="bold">merge="true"</emphasis><![CDATA[>
                <prop key="sales">sales@somecompany.com</prop>
                <prop key="support">support@somecompany.co.uk</prop>
            </props>
        </property>
    </bean>
<beans>]]></programlisting>
					</para>

					<para>
						The following is the definition result of adminEmails Collection.
						
						
					</para>
					
					<para>
						administrator=administrator@somecompany.com
						sales=sales@somecompany.com 
						support=support@somecompany.co.uk
					</para>
				</listitem>
			</itemizedlist>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold"> <![CDATA[<null> Element]]></emphasis>
					</para>

					<para> 
						<![CDATA[<null>]]>is used to handle null value. 
                        <programlisting language="xml"><![CDATA[<bean class="SampleBean">
    <property name="email"><]]><emphasis role="bold">null/</emphasis><![CDATA[></property>
</bean>]]></programlisting>
					</para>

					<para>
						The code above is identical to sampleBean.setEmail(null).
						In the case of definition as the following, sampleBean.setEmail("") of Java Code is same.
						
						
					    <programlisting language="xml"><![CDATA[<bean class="SampleBean">
    <property name="email"><]]><emphasis role="bold">value</emphasis><![CDATA[><]]><emphasis
	    role="bold">/value</emphasis><![CDATA[></property>
</bean>]]></programlisting>
					</para>
				</listitem>
			</itemizedlist>
			
			<section id="core_spring_ioc_dependencies_property_short">
        		<title>Simplifying XML -based configuration metadata </title>

        		<para>
        			Common for referring to value or bean. You can use several simplified types instead of complete
        			form of  <![CDATA[<value>]]> and
        			<![CDATA[<ref>]]>. <![CDATA[<property>]]>,
         			<![CDATA[<constructor-arg>]]> and  <![CDATA[<entry>]]> all support 'value' property instead of complete form of 
         			<![CDATA[<value>]]> element. For example, code 1 can be simplified into code 2 type.
        			
        			
        			
        	        <programlisting language="xml"><![CDATA[<!-- code 1 -->
<property name="myProperty"><]]><emphasis role="bold">value</emphasis><![CDATA[>]]><emphasis
        role="bold">hello</emphasis><![CDATA[<]]><emphasis role="bold">/value</emphasis><![CDATA[></property>]]></programlisting>
         		</para>

        		<para>
                    <programlisting language="xml"><![CDATA[<!-- code 2 -->
<property name="myProperty" ]]><emphasis role="bold">value="hello"/</emphasis><![CDATA[> ]]></programlisting>
				</para>
      		</section>

      		<section id="core_spring_ioc_dependencies_property_compound">
        		<title>Mixed property name(Compound Property) - Providing shortcut function</title>

       			<para>
       				Defining composite type of property is possible.
       				Note that all the rest property other than the last one must not be null.
       				
        		</para>

        		<mediaobject>
          			<imageobject>
           				<imagedata align="center"
                       		fileref="../image/core/spring/ioc-property.jpg" />
          			</imageobject>
        		</mediaobject>

        		<para>
                    <programlisting language="xml"><![CDATA[<bean id="foo" class="foo.Bar">
    <property name="fred.bob.sammy" value="123" />
</bean>]]></programlisting>
					In the example above, foo bean has fred property with bob property,
					and bob property has sammy property, and the last one, sammy property, is set with value 123.
					To this end, fred property of foo, and bob property of fred must not be null after bean is created.
					Otherwise, NullPointerException will return.
				
					
					
        		</para>
      		</section>
    	</section>
    	
    	<section id="core_spring_ioc_dependencies_depends">
      		<title>Using depends-on property </title>

      		<para>
      			'depends-on' property is used to explicitly force one or more bean to be initialized before bean.
      			The following is a part of context-core.xml file defined with depends-on property.
      			
      	        <programlisting language="xml"><![CDATA[<bean id="coreMovieService"
    class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl" 
    autowire="byType" ]]><emphasis role="bold">depends-on="coreMovieDao"</emphasis><![CDATA[>
</bean>]]></programlisting>
	  		</para>

      		<para>
      			When there is a need to represent dependency to multiple beans, you can define the bean name list as 'depends-on' property value
      			by using all valid delimiters such as comma, space and semi colon.
      			However, this 'depends-on' property is rarely used.
      			
      			
                <programlisting language="xml"><![CDATA[<bean id="beanOne" class="SampleBean" ]]><emphasis
    role="bold">depends-on="manager,accountDao"</emphasis><![CDATA[>
    <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />]]></programlisting>
	  		</para>

      		<para>
      			In the example above, for beanOne bean to run properly, manager bean must be created and run specific server
      			or perform task on specific resource before beanOne bean is created. Therefore, force manager bean to initialized.
      			
      			
	  		</para>
    	</section>

    	<section id="core_spring_ioc_dependencies_instantiation">
      		<title>Lazy Instantiation</title>

      		<para>
      			Basically, when Spring IoC container starts, instantiate all single beans.
      			
      		</para>

      		<para>
      			- If you want to instantiate specific singleton bean when first bean request came instead of when container is started,
      			define 'lazy-init' property.
      			The following is a part of context-core.xml file defined with lazy instantiation property.
      			
      	        <programlisting language="xml"><![CDATA[<bean id="coreMovieDao" 
    class="org.anyframe.plugin.core.moviefinder.service.impl.MovieDaoImpl" lazy-init="true"/>
<bean id="coreMovieService" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl"/>]]></programlisting>
      		</para>

      		<para>
      			- If you want lazy instantiation for all beans, define ‘default-lazy-init’  property.
      			
      	        <programlisting language="xml"><![CDATA[<beans ]]><emphasis role="bold">default-lazy-init="true"</emphasis><![CDATA[>
    <!-- no beans will be eagerly pre-instantiated -->
</beans>]]></programlisting>
	  		</para>
    	</section>

    	<section id="core_spring_ioc_dependencies_autowiring">
			<title>Autowiring</title>

      		<para>
      			Spring IoC Container can autowire relationship of beans.
      			This means that Spring can automatically analyze collaborator (other beans) by analyzing the content of BeanFactory.
      			Autowiring can clearly reduce the total amount of typing and erases or reduces the need 
      			to represent the parameter of property or constructor.
      			Value that can be defined autowire property of <![CDATA[<bean>]]> is as the following.
      			
      			
		    </para>

			<informaltable>
        		<tgroup cols="2">
               		<colspec colnum="1" colname="col1" colwidth="2*"/>
					<colspec colnum="2" colname="col2" colwidth="8*"/>
			
          			<thead>
	            		<row>
	              			<entry align="center">Property</entry>
	
	              			<entry align="center">Description</entry>
	            		</row>
	          		</thead>
	
	          		<tbody>
	            		<row>
	              			<entry>no</entry>
	
	              			<entry>[Basic definition] Not suing Autowiring function </entry>
	            		</row>
	
	            		<row>
	              			<entry>byName</entry>
	
	              			<entry>Searches bean with the same property id or name and apply autowiring function. 
	              			</entry>
	            		</row>
	
	            		<row>
	              			<entry>byType</entry>
	
	              			<entry>If one bean of the relevant property type exists, it is autowired.
	              			But if more than one, UnsatisfiedDependencyException will occur.
	              			If there is no matched bean, property is not defined.
	              			</entry>
	            		</row>
	
	            		<row>
	              			<entry>constructor</entry>
	
	              			<entry>This is similar to byType but applied to the parameter of constructor.
	              			If the bean that matches the parameter type of constructor in BeanFactory is more than one,
	              			UnsatisfiedDependencyException will occur.
	              			</entry>
	            		</row>
	
	            		<row>
	              			<entry>autodetect</entry>
	
	              			<entry>byType mode is performed after constructor mode is performed.
	              			</entry>
	            		</row>
	
	            		<row>
	              			<entry>default</entry>
	
	              			<entry>autowire mode defined in default-autowire property in  <![CDATA[<beans>]]> is applied to the relevant bean.
	              			</entry>
	            		</row>
	          		</tbody>
	        	</tgroup>
			</informaltable>

      		<para>The following is an example of context-core.xml file defined with autowiring property.
      		</para>

            <para>
                <programlisting language="xml"><![CDATA[<bean id="coreMovieService"
    class="org.anyframe.plugin.core.moviefinder.servicce.impl.MovieServiceImpl" 
    ]]><emphasis role="bold">autowire="byType"</emphasis><![CDATA[ depends-on="coreMovieDao">
</bean>]]></programlisting>
	  		</para>
      		
      		<section id="core_spring_ioc_dependencies_autowiring_pros">
        		<title>Merits</title>

        		<itemizedlist>
          			<listitem>
            			<para>No need to define property or constructor parameter in xml.</para>
          			</listitem>

          			<listitem>
            			<para>Reduced xml file size</para>
         		 	</listitem>

          			<listitem>
			            <para>Minimize the modification of xml file when modifying or adding other beans in reference relationship 
			            </para>
			        </listitem>

          			<listitem>
						<para>Remove confusion from double definition of same name beans in xml.
						</para>
					</listitem>
        		</itemizedlist>
      		</section>

      		<section id="core_spring_ioc_dependencies_autowiring_cons">
        		<title>Demerits</title>

        		<itemizedlist>
          			<listitem>
            			<para>Be careful not to have unexpected result due to not explicitly documenting the relationship of beans.
            			</para>
          			</listitem>

          			<listitem>
            			<para>Autowiring by type can be potentially ambiguous.
            			</para>
          			</listitem>
        		</itemizedlist>

        		<para>
        			* To remove specific bean from autowiring target, define autowire-candidate  property as false.
        			
        	        <programlisting language="xml"><![CDATA[<bean id="bean" class="sample.TestBean” ]]><emphasis
    role="bold">autowire-candidate="false"</emphasis><![CDATA[ />]]></programlisting>
        		</para>
      		</section>
    	</section>
    	
		<section id="core_spring_ioc_dependencies_check">
			<title>Dependency Check</title>

			<para>
				Check whether all properties (Primitive Type/Collection and Bean reference)defined in the relevant bean is property defined.
				
      		</para>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold"> 
						Defining dependency-check property of <![CDATA[<bean>]]>
						</emphasis>
					</para>
	
					<informaltable>
						<tgroup cols="2">
							<colspec colnum="1" colname="col1" colwidth="2*" />
							<colspec colnum="2" colname="col2" colwidth="8*" />
							<thead>
								<row>
									<entry align="center">Mode</entry>
		
									<entry align="center">Description</entry>
								</row>
							</thead>
		
							<tbody>
								<row>
									<entry>
										<emphasis role="bold">none</emphasis>
									</entry>
		
									<entry>
										[Basic definition] Not checking dependency. Not defining property when there is no bean in reference.
										
									</entry>
								</row>
		
								<row>
									<entry>
										<emphasis role="bold">simple</emphasis>
									</entry>
		
									<entry>Checks dependency for Primitive Type and collection</entry>
								</row>
		
								<row>
									<entry>
										<emphasis role="bold">object</emphasis>
									</entry>
		
									<entry>Checks dependency for bean in reference </entry>
								</row>
		
								<row>
									<entry>
										<emphasis role="bold">all</emphasis>
									</entry>
		
									<entry>Performs both simple and object modes</entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
		
					<para>
						The following is an example of property definition of dependency check.
						
		                <programlisting language="xml"><![CDATA[<bean id="coreMovieService" 
    class="org.anyframe.plugin.….MovieServiceImpl" ]]><emphasis role="bold">dependency-check="object"</emphasis><![CDATA[>
    property name="coreMovieDao" ref="coreMovieDao" />
</bean>]]></programlisting>
					</para>
		
					<para>
						In addition, it is possible to set up whether or not to use dependency check for all beans in the same way.
						
						<programlisting language="xml"><![CDATA[<]]><emphasis role="bold">beans default-dependency-check="none"</emphasis><![CDATA[>
    <!-- no beans will be eagerly pre-instantiated -->
</beans>]]></programlisting>
					</para>
				</listitem>
			</itemizedlist>
		</section>
  	</section>

	<section id="core_spring_ioc_mi">
		<title>Method Injection</title>

		<para>
			When using setter injection and constructor injection, which are methods of dependency injection,
			beans referring to singleton bean remains in singleton type.
			But, in special case, singleton bean can have dependency relationship with non-singleton bean (namely, prototype bean).
			In such case, you can solve the situation by using Lookup Method Injection.
			Under the same condition, solving by implementing BeanFactoryAware is also possible,
			but which is not recommended because bean code is modified depending on Spring Container API.
			
			
    	</para>

		<itemizedlist>
			<listitem>
				<para>Lookup Method Injection</para>
			</listitem>

			<listitem>
				<para>Method Replacement</para>
			</listitem>
		</itemizedlist>

		<section id="core_spring_ioc_mi_lookup">
			<title>Lookup Method Injection</title>

			<para>For Singleton Bean to refer to Prototype Bean, set up <![CDATA[<lookup-method>]]>.
			The following is a part of context-core.xml file which defines the reference relation using Lookup Method Injection.
			
			
			
                <programlisting language="xml"><![CDATA[<bean id="coreMovieService"
    class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl">
    <!-- method injection -->
    <]]><emphasis role="bold">lookup-method</emphasis><![CDATA[ name="getMovieDao" bean="coreMovieDao"/> 		
</bean>

<!-- change scope from singleton to prototype (non singleton) -->
<bean id="coreMovieDao" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieDao" ]]><emphasis
        role="bold">scope="prototype"</emphasis><![CDATA[/>]]></programlisting>
			</para>

			<para>
				The relevant method implements method by returning MovieDao as the following.
				
				<programlisting language="java">public class MovieServiceImpl … {
    public <emphasis role="bold">MovieDao</emphasis> getMovieDao(){
        // do nothing - this method will be overrided by Spring Container
        return null;
    }
    ...
}</programlisting>
			</para>
		</section>

		<section id="foundaiton_spring_ioc_mi_replacement">
			<title>Method Replacement</title>

			<para>
				If you want to modify the function of method without modifying existing method, use <![CDATA[<replaced-method>]]>.
				The following is an example.
				
			</para>

			<itemizedlist>
				<listitem>
					<para>Implementation class</para>

					<para>
                        Creates class implementing  MethodReplacer interface provided by Spring Framework, and composes logic in reimplement method.
                        
                        <programlisting language="java">import org.springframework.beans.factory.support.MethodReplacer;
public class SayHelloMethodReplacer <emphasis role="bold">implements MethodReplacer</emphasis>{
    public Object <emphasis role="bold">reimplement</emphasis> (Object target, Method method, Object[] args)
        throws Throwable {
        ...</programlisting>
					</para>
				</listitem>
			</itemizedlist>

			<itemizedlist>
				<listitem>
					<para>
						Configuration file
                        <programlisting language="xml"><![CDATA[<bean id="beanFirst" class="test.BeanFirst"/>          
<bean id="beanSecond" class=" test.BeanSecond">
    <]]><emphasis role="bold">replaced-method name="sayHello" replacer="methodReplacer"</emphasis><![CDATA[>
        <]]><emphasis role="bold">arg-type</emphasis><![CDATA[>]]><emphasis
        role="bold">String</emphasis><![CDATA[<]]><emphasis role="bold">/arg-type</emphasis><![CDATA[>
    </replaced-method>
</bean>
<bean ]]><emphasis role="bold">id="methodReplacer" class="test.SayHelloMethodReplacer"</emphasis><![CDATA[/>]]></programlisting>
					</para>

					<para>
					 	In the configuration file above, the above-mentioned MethodReplacer is applied at the point of 
					 	executing sayHello method of BeanSecond class.
					 	
         			</para>
				</listitem>
			</itemizedlist>
		</section>
	</section>

	<section id="core_spring_ioc_extensions">
		<title>Bean and Container extension</title>

		<para>
			Container in Spring Framework is basically designed to be extended.
			It does not mean that all application developers need to extend them.
			Here is the basic content and the one that can be extended by item.
			
			
		</para>

		<itemizedlist>
			<listitem>
				<para>Bean Scope</para>
			</listitem>

			<listitem>
				<para>Bean Life Cycle</para>
			</listitem>

			<listitem>
				<para>Bean inheritance</para>
			</listitem>

			<listitem>
				<para>Container extension</para>
			</listitem>

			<listitem>
				<para>Using ApplicationContext</para>
			</listitem>
		</itemizedlist>

		<section id="core_spring_ioc_extensions_scope">
			<title>Bean Scope</title>

			<para>
				Bean instance-creating mechanism is determined depending on five scopes supported in Spring Framework.
				As service scope is hard to determine at design/development stage, it is recommended to basically define default 
				scope as singleton, then define the scope depending on the characteristic of the relevant service.
				
	  		</para>

			<itemizedlist>
				<listitem>
					<para> 
						scope property value of <![CDATA[<bean>]]>
					</para>

					<informaltable>
						<tgroup cols="2">
							<colspec colnum="1" colname="col1" colwidth="2*" />
							<colspec colnum="2" colname="col2" colwidth="8*" />
							<thead>
								<row>
									<entry align="center">Property</entry>

									<entry align="center">Description</entry>
								</row>
							</thead>

							<tbody>
								<row>
									<entry>
										<emphasis role="bold">singleton</emphasis>
									</entry>

									<entry>
										[Basic definition] Creates one bean object per bean definition in Spring IoC Container 
									</entry>
								</row>

								<row>
									<entry>
										<emphasis role="bold">prototype</emphasis>
									</entry>
	
									<entry>Creats new bean object of same type all the time
									</entry>
								</row>
	
								<row>
									<entry>
										<emphasis role="bold">request</emphasis>
									</entry>
	
									<entry>Creates one bean object per http request when using WebApplicationContext type Container.
									</entry>
								</row>
	
								<row>
									<entry>
										<emphasis role="bold">session</emphasis>
									</entry>
	
									<entry>
										Creates one bean object per http session when using WebApplicationContext type Container.
										
									</entry>
								</row>
	
								<row>
									<entry>
										<emphasis role="bold">globalSession</emphasis>
									</entry>
	
									<entry>
										Valid only in portlet context and creates one bean object per global http session 
										when using WebApplicationContext-type Container
										
									</entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
	
					<para>
						Other than these, new scope definition is possible through custom scope.
						
					</para>
				</listitem>
			</itemizedlist>

			<section id="core_spring_ioc_extensions_scope_singleton">
				<title>Singleton</title>

				<mediaobject>
					<imageobject>
						<imagedata align="center" fileref="../image/core/spring/ioc-singleton.jpg" />
					</imageobject>
				</mediaobject>

				<para>
					Singleton scope is a basic scope and creates and provides one bean instance for multiple requests.
					Therefore, if there is data to keep for each client request, singleton scope service is not appropriate.
					The following is an example of configuration of singleton scope.
					
					
                    <programlisting language="xml"><![CDATA[<bean id="coreMovieService" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl" 
        scope="singleton”>
    <property name="coreMovieDao" ref="coreMovieDao" />
</bean>
<bean id="coreMovieDao" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieDao”>
    ...
</bean>]]></programlisting>
				</para>

				<para>
					Singleton scope can be defined as above, but as the default value of scope is singleton,
					there is no need to define separately.
					
        		</para>
			</section>

			<section id="core_spring_ioc_extensions_scope_prototype">
				<title>Prototype</title>

				<mediaobject>
					<imageobject>
						<imagedata align="center" fileref="../image/core/spring/ioc-prototype.jpg" />
					</imageobject>
				</mediaobject>

				<para>
					Prototype scope creates and provides bean instance at every request.
					Therefore, a certain client cannot access same bean instance simultaneously.
					The following is an example of configuration of Prototype scope.
					
					
				    <programlisting language="xml"><![CDATA[<bean id="coreMovieService" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServieImpl"
        scope="prototype”>
    <property name="coreMovieDao" ref="coreMovieDao" />
</bean>]]></programlisting>
				</para>

				<para>
					※ Generally, to decide whether or not singleton of instance, you can check whether or not global variable exists.
					In other words, if instance does not have global variable, you can define singleton;
					for existing global variable, define as prototype.
					However, such division is subject to change depending on whether the relevant global variable is read-only or writable.
					Therefore, for deciding to creating instance as singleton,
					it is best for developers to understand how the instance of the relevant scope is used in the memory.
					
					
				</para>

				<itemizedlist>
					<listitem>
						<para>Singleton</para>
	
						<para>
							- Shared objects with no state
						</para>
	
						<para>
							- Shared object with read-only state
						</para>
	
						<para>
							- Shared object with shared state : In this case, control simultaneousness by using synchronization.
							 
						</para>
	
						<para>
							- High throughput objects with writable state : one example is using object pooling.
							When it costs a lot or needs many instances to create instance, use object pooling and
							use instance for pooling as singleton. Likewise, when modification occurs in writable state, use
							synchronization properly.
							
							
	            		</para>
					</listitem>
				</itemizedlist>

				<itemizedlist>
					<listitem>
						<para>Prototype</para>
	
						<para>- Objects with writable state</para>
	
						<para>- Objects with private state</para>
					</listitem>
				</itemizedlist>
			</section>

			<section id="core_spring_ioc_extensions_scope_other">
				<title>Other Scopes</title>

				<para>
					The following is matters to take precautions when using request, session, globalSession Scope.
				</para>

				<itemizedlist>
					<listitem>
						<para>
							Can be used only when using web-based ApplicationContext. If used in other cases,IllegalStateException occurs.
							
							
            			</para>
					</listitem>

					<listitem>
						<para>
							Must be developed along with <![CDATA[<aop:scoped-proxy/>]]> when defining bean
							in the case of referring from bean with different scope. (Refer to the example below.)
						
						</para>

						<para>
							Although the scope of moviePreferences bean is session, the scope of coreMovieService bean is
							singleton(default is singleton, therefore problem occurs.
							In other words, moviePreferences object must be created at every session, but as moviePreferences object
							is created by coreMovieService Bean only once, so it is not working as properly as you want.
							Therefore, to create proxy to create new object at every session, use <![CDATA[<aop:scoped-proxy/>]]>.
							
							
						    <programlisting language="xml"><![CDATA[<!-- a HTTP Session-scoped bean exposed as a proxy -->
<bean id="moviePreferences"
        class="org.anyframe.plugin.core.moviefinder.service.impl.MoviePreferences" ]]>
        <emphasis role="bold">scope="session"</emphasis><![CDATA[>
    <!-- this next element effects the proxying of the surrounding bean -->
    <]]><emphasis role="bold">aop:scoped-proxy/</emphasis><![CDATA[>
</bean>
<!-- a singleton-scoped bean injected with a proxy to the above bean -->
<bean id="coreMovieService" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl">
    <!-- a reference to the proxied 'moviePreferences' bean -->
    <]]><emphasis role="bold">property name="moviePreferences" ref="moviePreferences"</emphasis><![CDATA[/>
</bean>]]></programlisting>
						</para>
					</listitem>
				</itemizedlist>
			</section>

			<section id="core_spring_ioc_extensions_scope_custom">
				<title>Custom</title>

				<para>
					Creates class for defining new scope and implements org.springframework.beans.factory.config.Scope interface.
					Also, by using CustomScopeConfigurer, you can use CustomScopeConfigurer through registering newly-defined custom scope.
					
				
        		</para>

				<para>
					You can directly difine the scope suitable for the relevant project as the following example.
					
				    <programlisting language="xml"><![CDATA[<!-- Define class for new scope definition,and implement 
org.springframework.beans.factory.config.Scope interface.-->
<bean class=]]><emphasis role="bold">"org.springframework.beans.factory.config.CustomScopeConfigurer"</emphasis><![CDATA[>
<!-- Register Custom Scope using CustomScopeConfigurer  -->
    <property name="scopes">
        <map>
            <]]><emphasis role="bold">entry key="thread"</emphasis><![CDATA[>
            <]]><emphasis role="bold">bean class="com.foo.ThreadScope"/</emphasis><![CDATA[>
            <]]><emphasis role="bold">/entry</emphasis><![CDATA[>
        </map>
    </property>
</bean>

<!-- Using Custom Scope  -->
<bean id="bar" class="x.y.Bar" ]]><emphasis role="bold">scope="thread"</emphasis><![CDATA[>
    <property name="name" value="Rick"/>
    <aop:scoped-proxy/>
</bean>]]></programlisting>
				</para>
			</section>
		</section>
    	
    	<section id="core_spring_ioc_extensions_lifecycle">
      		<title>Bean Life Cycle</title>

      		<para>
      			Life cycle of bean is composed of Initialization, Activation,
      			Destruction as shown in the following figure.
      			</para>

      		<mediaobject>
        		<imageobject>
          			<imagedata align="center"
                     	fileref="../image/core/spring/ioc-lifecycle.jpg" />
        		</imageobject>
      		</mediaobject>

			<section id="core_spring_ioc_extensions_lifecycle_initial">
        		<title>Initialization</title>

        		<para>
        			Spring container is run through various processes as shown in the following figure.
        			When Spring bean class implements each interface shown in the figure below, each method is called.
        			
        			
        		</para>

        		<mediaobject>
          			<imageobject>
            			<imagedata align="center"
                       		fileref="../image/core/spring/ioc-initialization.jpg" />
          			</imageobject>
        		</mediaobject>

        		<para>
        			When using life-cycle method supported by Spring Framework as it is, as specific interface must be implemented,
        			the relevant code will be dependent on Spring Framework.
        			In other words, to use life-cycle method suggested in the figure above, the relevant cycle interface class must be 
        			implemented in Spring bean class.
        			For example, in Spring bean implementing ApplicationContextAware interface, 
        			develop setApplicationContext(ApplicationContext context) method, 
        			and call method provided by ApplicationContext
        			using ApplicationContext inside bean.
        			
        			 
                    <programlisting language="java">public class IoCServiceImpl1 implements IoCService1, 
    <emphasis role="bold">ApplicationContextAware</emphasis> {
    public void setApplicationContext (ApplicationContext context){
        IoCService2 iocService2 = <emphasis role="bold">(IoCService2)context.getBean("IoCService2")</emphasis>;
    }
}</programlisting>
				</para>

        		<para>
        			Another example is that in the case of MessageSourceAware interface class, it can be used to get MessageSource
        			defined in Spring Container.
        			In the Spring bean implementing MessageSourceAware interface class, you can access MessageSource
        			by developing setMessages(MessageSource messages) method.
        			
        			
	                <programlisting language="java">public class IoCServiceImpl1 implements IoCService1, <emphasis role="bold">MessageSourceAware</emphasis> {
    private MessageSource messageSource;
    public void setMessageSource(MessageSource messageSource) {
        this.messageSource = messageSource;
    }
}</programlisting>
				</para>

        		<para>
        			Unlike these, without implementing specific interface, life-cycle method can be defined through bean property 
        			definition(init-method, destroy-method).
        			The following is a part of context-core.xml file defining  init-method property.
        			      
                    <programlisting language="xml"><![CDATA[<bean id="coreMovieService"
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl" 
        ]]><emphasis role="bold">init-method="movieInitialize"</emphasis><![CDATA[ destroy-method="movieDestroy" parent="parent">
</bean>]]></programlisting>
				</para>

        		<para>
        			For initialing method set up for all beans, use default-init-method property of  <![CDATA[<beans>]]>
        			
        		</para>
      		</section>

      		<section id="core_spring_ioc_extensions_lifecycle_destruction">
        		<title>Destruction</title>

        		<para>At destruction stage, BeanFactory and ApplicationContext runs in the same way.</para>

        		<mediaobject>
					<imageobject>
						<imagedata align="center"
							fileref="../image/core/spring/ioc-destruction.jpg" />
						</imageobject>
				</mediaobject>

        		<para>
        			The following is a part of  context-core.xml defining destroy-method property.
        			
                    <programlisting language="xml"><![CDATA[<bean id="coreMovieService"
        class="org.anyframe.plguin.core.moviefinder.service.impl.MovieServiceImpl" 
        init-method="movieInitialize" ]]><emphasis role="bold">destroy-method="movieDestroy"
        </emphasis><![CDATA[parent="parent">
</bean>]]></programlisting>
				</para>

        		<para>
        			For setting up destructor for all beans, use destroy-method of <![CDATA[<beans>]]>.
        			
        		</para>
      		</section>
    	</section>

    	<section id="core_spring_ioc_extensions_inheritance">
      		<title>Bean inheritance</title>

      		<para>
      			Bean definition contains huge volume of set-up information including various property information, 
      			constructor parameter,
      			property values.
      			Child bean inherits and defines definition information from parent definition.
      			Therefore, overwriting or adding value is possible.
      			As bean definition using inheritance relationship can reduce the size of xml file,
      			it is useful to define parent bean in template-type.
      			When defining xml-based property, child bean must use 'parent'property to specify parent bean.
      			
      			
		    </para>

      		<itemizedlist>
        		<listitem>
          			<para>Parent Bean definition</para>

          			<para>
          				Can use parent bean without separate definition.
          				If class propery value is not defined, define abstract property value as "true".
          				If abstract property value is "true", bean instantiation is not possible.
          				
			        </para>
        		</listitem>
      		</itemizedlist>

      		<itemizedlist>
		        <listitem>
		          <para>Child bean definition</para>
		
		          <para>Define the 'parent' property value as bean id or name.
		          </para>
		    	</listitem>
		    </itemizedlist>

      		<para>
      			The following is a part of  context-core.xml representing bean inheritance.
      			
      	        <programlisting language="xml"><![CDATA[<!-- register parent bean that has a dependency with coreMovieDao bean -->
<bean ]]><emphasis role="bold">id="parent"</emphasis><![CDATA[ abstract="true">
    <property name="coreMovieDao" ref="coreMovieDao" />	
</bean>

<bean id="coreMovieService" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl" 
        init-method="movieInitialize" destroy-method="movieDestroy" 
        parent="parent">
</bean>]]></programlisting>
	  		</para>
    	</section>

    	<section id="core_spring_ioc_extensions_container">
      		<title>Container extension</title>

      		<section id="core_spring_ioc_extensions_container_postprocess">
        		<title>Bean post-process</title>

        		<para>
        			<emphasis role="bold">
        			Bean post-process</emphasis> refers to process around the bean initialization point at initialization 
        			stage in the bean's life-cycle. Function can be extended by implementing BeanPostProcessor.
        			When using ApplicationContext-type container, if you register the class implementing BeanPostProcessor interface
        			in xml, container regards the relevant class as BeanPostProcessor and then calls post-processs method before/after each 
        			bean in initialized.
        			However, if you use  BeanFactory-type container, you have to register on the program using addBeanPostProcessor() method
        			of BeanFactory. The following is an example.
        			
        	        <programlisting language="java">public class InstantiationTracingBeanPostProcessor 
    <emphasis role="bold">implements BeanPostProcessor</emphasis> {
    // simply return the instantiated bean as-is
    public Object <emphasis role="bold">postProcessBeforeInitialization</emphasis>(Object bean, String beanName) 
        throws BeansException {
        return bean; // we could potentially return any object reference here
    }
  
    public Object <emphasis role="bold">postProcessAfterInitialization</emphasis>(Object bean, String beanName) 
        throws BeansException {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}  
</programlisting>
				</para>

				<para>
                   <programlisting language="xml"><![CDATA[<bean class=]]><emphasis
                   role="bold">"scripting.InstantiationTracingBeanPostProcessor"</emphasis><![CDATA[/>]]></programlisting>
        	    </para>
			</section>

			<section id="core_spring_ioc_extensions_container_factory">
        		<title>BeanFactory post-process</title>

        	<para>
        		By implementing BeanFactoryPostProcessor, BeanFactory function can be extended.
        		After definition of all beans is loaded, postProcessBeanFactory() method of BeanFactoryPostProcessor is called
        		by Spring Container before any bean is instantiated.
        		The following is an example.
        		

        	</para>

            <para>
                <programlisting language="java">public class BeanCounterBeanFactoryPostProcessor
    <emphasis role="bold">implements BeanFactoryPostProcessor</emphasis> {
    public void <emphasis role="bold">postProcessBeanFactory</emphasis>(ConfigurableListableBeanFactory factory) 
        throws BeansException {
        ...
    }
}</programlisting>
			    <programlisting language="xml"><![CDATA[<bean class=]]><emphasis role="bold">"test.BeanCounterBeanFactoryPostProcessor"</emphasis><![CDATA[/>]]></programlisting>
              	BeanFactoryPostProcessor cannot be used with BeanFactory-type container. 
              	Useful implementation classes of  BeanFactoryPostProcessor is PropertyPlaceholderConfigurer and CustomEditorConfigurer.
        	</para>

        	<para>
        		The following is an example of using PropertyPlaceholderConfigurer and CustomEditorConfigurer.
        		

        	</para>

        	<itemizedlist>
				<listitem>
            		<para><emphasis role="bold">Externalization of set-up information</emphasis></para>

            		<para>
            			Load properties from one or more external property file using PropertyPlaceholderConfigurer,
            			and fill placeholder variables of bean definition xml file using those properties.
            			
		            </para>

            		<para>
		            	The following is a part of configuration of context-core.xml which registers 
		            	PropertyPlaceholderConfigurer class as bean for definition information externalization.
		            	
            	        <programlisting language="xml"><![CDATA[<!-- set file locations --> 
<bean id="configurer" class="org.springframework.beans.factory.config.]]><emphasis role="bold">PropertyPlaceholderConfigurer</emphasis><![CDATA[">
    <property name="locations">
        <list>
            <value>]]><emphasis role="bold">MovieConfigurer.properties</emphasis><![CDATA[</value>
        </list>
    </property>
</bean>
 
<bean id="coreMoiveService" 
        class="org.anyframe.plugin.core.moviefinder.service.impl.MovieServiceImpl">
    <property name="coreMovieDao" ref="coreMovieDao" />
    <!-- set movieTitle value using key name in properties file -->
    <property name="movieTitle " value=]]><emphasis role="bold">"${movie.title}"</emphasis><![CDATA[></property>
</bean>]]></programlisting>
					</para>

            		<para>
            			The following is the contents of movieConfigurer.properties, defined as external file above.
            			
                        <programlisting language="java">movie.title=Shrek</programlisting>
             		</para>
          		</listitem>
        	</itemizedlist>

        	<itemizedlist>
				<listitem>
            		<para>
            			<emphasis role="bold">PropertyEditor extension</emphasis>
            		</para>

            		<para>
            			Using CustomEditorConfigurer, register custom implementation class of java.beans.PropertyEditor
            			and then translate the special value into other special type.
            			Register the extended PropertyEditor class with configuration file, then use as PropertyEditor.
            			
            	        <programlisting language="xml"><![CDATA[<bean id="customEditorConfigurer"          
        class="org.springframework.beans.factory.config.]]><emphasis role="bold">CustomEditorConfigurer</emphasis><![CDATA[">
    <property name="customEditors">
        <map>
            <entry key="com.springinaction.knight.PhoneNumber">
            <bean id="phoneEditor"          
	            class="com.springinaction.springcleaning.]]><emphasis role="bold">PhoneNumberEditor</emphasis><![CDATA[" />
            </entry>
        </map>
    </property>
</bean>]]></programlisting>
			        </para>

            		<para>
                        <programlisting language="xml"><![CDATA[<bean id="knight" class="com.springinaction.knight.KnightOnCall">
    <property name="url" value="http://www.knightoncall.com" />
    <property name=]]><emphasis role="bold">"phoneNumber"</emphasis><![CDATA[ value="940-555-1234" />
</bean>]]></programlisting>
					</para>
          		</listitem>
        	</itemizedlist>
      	</section>
    </section>

    <section id="core_spring_ioc_extensions_application">
		<title>ApplicationContext utilization</title>

		<section id="core_spring_ioc_extensions_application_message">
        	<title>I18N support utilizing MessageSource</title>

        	<para>
	        	ApplicationContext interface provides messaging(I18N) function by extending interface called MessageSource
	        	and is capable of structural message along with HierarchicalMessageSource.
	        	Bean implementing MessageSourceAware interface can use messageSource Bean of ApplicationContext.
	        	
	        	
	        </para>

        	<para>
        		The following is a part of messageSource configuration of context-common.xml.
        		
        	    <programlisting language="xml"><![CDATA[<bean id=]]><emphasis role="bold">"messageSource"
        </emphasis><![CDATA[ class="org.springframework.context.support.ResourceBundleMessageSource">
    <property name=]]><emphasis role="bold">"basenames"</emphasis><![CDATA[>
        <list><value>]]><emphasis role="bold">message/message-moviemgmt</emphasis><![CDATA[</value></list>
    </property>
</bean>]]></programlisting>
			</para>

	        <para>
	        	Resource Bundle file is composed of file by locale for I18N support
	        	and message-moviemgmt.properties file referring to above is as the following.
	        
        	   <programlisting language="java">errors.required={0} is a required field.  </programlisting>
        	</para>

 			<para>
	        	In addition, the part to get  messageSource in MovieServiceImpl.java file is implemented as the following.
	        	
	        	
        	    <programlisting language="java">new String(messageSource.getMessage("errors.required", new Object[] {"TITLE"},
    Locale.KOREA).getBytes("8859_1"), "euc-kr")</programlisting>
        	</para>

	        <para>
	        	If you execute  ContainerTest.java file testing ContainerTest.java part, 
	        	you can see the following message.
	        	
        	    <programlisting language="java">"TITLE" field is necessary. </programlisting>
        	</para>
      	</section>

      	<section id="core_spring_ioc_extensions_application_event">
			<title>Event</title>

        	<para>
	        	As ApplicationContext can cause many events to occur while application is running,
	        	register Listener as bean, then container calls onApplicationEvent() method of Listener when the relevant
	        	event occurs.
	        	
	        </para>

	        <itemizedlist>
	          <listitem>
	            <para><emphasis role="bold">Built-in Events</emphasis></para>
	
	            <informaltable>
	              <tgroup cols="2">
	              	<colspec colnum="1" colname="col1" colwidth="3*"/>
					<colspec colnum="2" colname="col2" colwidth="7*"/>
	                <thead>
	                  <row>
	                    <entry align="center">Event</entry>
	
	                    <entry align="center">Description</entry>
	                  </row>
	                </thead>
	
	                <tbody>
	                  <row>
	                    <entry align="left">
	                      <emphasis role="bold">ContextRefreshedEvent</emphasis>
	                    </entry>
	
	                    <entry align="left">
	                    Refers to the event occurred when ApplicationContext is initialized or refreshed.
	                    Here, initialization means that all beans are loaded and singleton beans are instantiated in advance
	                    and ApplicationContext is ready to use.
	                    
	                    </entry>
	                  </row>
	
	                  <row>
	                    <entry align="left">
	                      <emphasis role="bold">ContextClosedEvent</emphasis>
	                    </entry>
	
	                    <entry align="left">
	                    	Refers to the event occurred when ApplicationContext is closed using close()method of ApplicationContext
	                    	-Here, closing means that Singleton beans are destroyed. 
	                    	
	                    </entry>
	                  </row>
	
	                  <row>
	                    <entry align="left">
	                      <emphasis role="bold">RequestHandledEvent</emphasis>
	                    </entry>
	
	                    <entry align="left">
	                    	Refers to the event occurred inside WebApplicationContext when HTTP Request is processed.
	                    	- This event is applicable only to web application using Spring DispatcherServlet.
	                    	
	                    </entry>
	                  </row>
	                </tbody>
	              </tgroup>
	            </informaltable>

            	<para>
            		The following is an example of Listener implementing ApplicationListener.
            	
            	    <programlisting language="java">public class RefreshListener implements <emphasis role="bold">ApplicationListener</emphasis> {
    public void <emphasis role="bold">onApplicationEvent(ApplicationEvent evt)</emphasis> {
        if (evt instanceof ContextRefreshedEvent) { 
             ...
        }
    }
}</programlisting>
				</para>

            	<para>
            		The following is an example of configuration of above-mentioned RefreshListener class.
            		
            		<programlisting language="xml"><![CDATA[<bean id="refreshListener" class="sample.RefreshListener"/>]]></programlisting>
            	</para>
          	</listitem>
		</itemizedlist>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">Custom Event occurrence</emphasis></para>

            <para>
            	It is possible to register Listener to make user-defined event to occur and handle the relevant event when occurring.
            	For event listening, listener registration is needed.
            	The following is a part of context-core.xml file registering listener bean.
            	
            	
                <programlisting language="xml"><![CDATA[<bean id="movieEventListener" 
    class="org.anyframe.plugin.core.moviefinder.service.impl.MovieEventListener"/>]]></programlisting>
            </para>

            <para>
            	The following is a part of MovieEventListener.java showing that it handles MovieEvent, custom event.
            	
            	<programlisting language="java">public class movieEventListener <emphasis role="bold">implements ApplicationListener</emphasis> {
    public void <emphasis role="bold">onApplicationEvent</emphasis>(ApplicationEvent evt) {
        if (evt instanceof <emphasis role="bold">MovieEvent</emphasis>) {
            MovieEvent event = (MovieEvent)evt;
            System.out.println("Received in MovieEventListener : " + 
                event.getMovieMessage());
        }
    }
}</programlisting>
			</para>

            <para>
            	The following is MovieServiceImpl.java file shows that it handles MovieEvent, custom event.
            	
            	<programlisting language="java">this.ctx.publishEvent(new MovieEvent(this,"new movie is added successfully."));</programlisting>
            </para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="core_spring_ioc_extensions_application_comp">
		<title>Comparison between BeanFactory and ApplicationContext characteristics</title>

		<informaltable>
			<tgroup cols="3">
				<colspec colnum="1" colname="col1" colwidth="5*"/>
					<colspec colnum="2" colname="col2" colwidth="2*"/>
					<colspec colnum="3" colname="col3" colwidth="3*"/>
		            <thead>
		              <row>
		                <entry align="center">Feature</entry>
		
		                <entry align="center">BeanFactory</entry>
		
		                <entry align="center">ApplicationContext</entry>
		              </row>
		            </thead>
		
		            <tbody>
		              <row>
		                <entry>Bean instantiation/wiring</entry>
		
		                <entry align="center">Yes</entry>
		
		                <entry align="center">Yes</entry>
		              </row>
		
		              <row>
		                <entry>Automatic BeanPostProcessor registration</entry>
		
		                <entry align="center">No</entry>
		
		                <entry align="center">Yes</entry>
		              </row>
		
		              <row>
		                <entry>Automatic BeanFactoryPostProcessor registration</entry>
		
		                <entry align="center">No</entry>
		
		                <entry align="center">Yes</entry>
		              </row>
		
		              <row>
		                <entry>Convenient MessageSource access (for i18n)</entry>
		
		                <entry align="center">No</entry>
		
		                <entry align="center">Yes</entry>
		              </row>
		
		              <row>
		                <entry>ApplicationEvent publication</entry>
		
		                <entry align="center">No</entry>
		
		                <entry align="center">Yes</entry>
		              </row>
		            </tbody>
				</tgroup>
			</informaltable>
	
	        <para>
	        	ApplicationContext usage is recommended when building most typical application.
	        	
	        </para>
	      </section>
	    </section>
	</section>


	<section id="core_spring_ioc_xmlschema">
    	<title>XML schema-based definition</title>

    	<para>
    		New xml configuration grammar comes out based on xml schema, and Spring Framework evolves
    		for xml to be defined even easier.
    		
    	</para>

    	<itemizedlist>
			<listitem>
		        <para><emphasis role="bold">XML Schema basically provided</emphasis></para>
		
		        <para>The following is the types of xml schema provided in Spring Framework.
		      </para>
		
		        <para>[util, jee, lang, jms, tx, aop, context, tool, beans] (For how to use each,
		           	  <ulink url="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/xsd-config.html">
		        	  refer to Spring</ulink> of Spring manual site.)
		        </para>
      		</listitem>
    	</itemizedlist>

    	<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold">Possible to extend XML schema</emphasis>
				</para>

				<para>
					Can define definition tag of its own domain property to better represent application domain when developing application.
					
				</para>

				<para>
					For how to use extend schema and apply it to xml file, 
					
					<ulink url="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/extensible-xml.html">
					refer to Spring</ulink> of Spring manual site. 
				</para>
			</listitem>
	    </itemizedlist>

    	<itemizedlist>
      		<listitem>
        		<para><emphasis role="bold">Reference to XML schema</emphasis></para>

        		<para>
        			Define namespace to use by using xmlns:~ and define the location of XSD file defining the xml schema of the relevant namespace.
        			
        			
        	        <programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.springframework.org/schema/util"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xmlns:jms="http://www.springframework.org/schema/jms"
    ]]><emphasis role="bold">xmlns:aop="http://www.springframework.org/schema/aop"</emphasis>
    <![CDATA[xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
        http://www.springframework.org/schema/util 
        http://www.springframework.org/schema/util/spring-util-3.1.xsd
        http://www.springframework.org/schema/jee 
        http://www.springframework.org/schema/jee/spring-jee-3.1.xsd
        http://www.springframework.org/schema/lang 
        http://www.springframework.org/schema/lang/spring-lang-3.1.xsd
        http://www.springframework.org/schema/jms 
        http://www.springframework.org/schema/jms/spring-jms-3.1.xsd
        ]]><emphasis role="bold">http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-3.1.xsd</emphasis>
        <![CDATA[http://www.springframework.org/schema/tx 
        http://www.springframework.org/schema/tx/spring-tx-3.1.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context-3.1.xsd">
        <!-- <bean/> definitions here -->
</beans>]]></programlisting>
				</para>
      		</listitem>
    	</itemizedlist>

    	<itemizedlist>
      		<listitem>
        		<para><emphasis role="bold">Suggestion of utilizing annotation when XML set-up is burdensome. 
        		</emphasis></para>

        		<para>Other than defining bean in xml base, you can reduce the burden of xml setting up by utilizing annotation.
        		</para>
	      	</listitem>
		</itemizedlist>
	</section>	

</chapter>
