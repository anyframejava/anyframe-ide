<chapter id="commands_maven">
	<title>Maven Commands</title>
	<para>
		해당 프로젝트에서 빌드 도구로써 Maven을 채택한 경우 CLI를 이용하여 Anyframe 기반 개발 환경을 구성해 보도록 하자. 본 장에서는 먼저 Anyframe Maven Command에 대해 알아보고 이들 
		Command를 활용하는 방법에 대해 구체적으로 살펴볼 것이다.
		아직 Maven 환경이 제대로 갖추어지지 않은 경우에는 본 매뉴얼의 <link linkend="installation_maven_configuration">Installation - Maven 설치 및 환경 설정</link>을 참고하여 환경이 제대로 세팅되었는지
		확인해 보도록 한다.
	</para>
	
	<section id="commands_maven_commands">
		<title>Anyframe Maven Commands</title>
		<para>
			Anyframe에서는 자체 구현한 'anyframe-maven-plugin'이라는 Maven Plugin을 제공함으로써 Anyframe Repository 내에 등록된 다양한 <link linkend="plugins_list">Anyframe Plugin들</link>을 다운로드하여 
			설치/삭제/조회하거나 Domain/CRUD 소스 코드를 생성할 수 있도록 지원한다. 
		</para>
		
		<section id="commands_maven_commands_check">
			<title>anyframe-maven-plugin 정의 확인</title>
			<para>
				Maven 기반의 프로젝트에서 anyframe-maven-plugin을 사용하기 위해서는 해당 프로젝트 폴더 하위의 pom.xml 파일 내에 다음과 같이 maven plugin 정의가 추가되어 있어야 한다.
			</para>
			<programlisting language="xml"><![CDATA[<project>
    중략...
    <build>
        <plugins>
            중략...						
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                    <artifactId>anyframe-maven-plugin</artifactId>
                    <version>x.x.x</version>
                    <dependencies>
                        <dependency>
                            <groupId>hsqldb</groupId>
                            <artifactId>hsqldb</artifactId>
                            <version>2.0.0</version>
                        </dependency>       
                    </dependencies>
            </plugin>
        </plugins>
    </build>
</project>]]></programlisting>		
		</section>
	
		<section id="commands_maven_commands_list">
			<title>Command 목록</title>
			<para>
				anyframe-maven-plugin은 Anyframe만의 고유 기능을 수행할 수 있도록 구현된 다양한 Maven Mojo(Maven-old-java-object) 클래스들로 
				구성되어 있으며 각 Mojo는 한 개의 Goal과 매핑된다. 여기에서 Goal이란 Maven에서 사용되는 용어로써 한번의 실행으로 이루어지는 특정 기능 단위라고 볼 수 있다. 
				다음은 anyframe-maven-plugin을 구성하는 Goal의 목록으로, 사용자는 Command 창에서 <emphasis role="bold">mvn anyframe:{goal}</emphasis>과 같이 명령어를 입력함으로써 
				원하는 기능을 실행할 수 있게 된다. Option은 -D{option}=...와 같은 형태로 명령어 입력 뒤에 추가하면 된다.
			</para>
			<informaltable>
				<tgroup cols="2">
					<colspec colnum="1" colname="col1" colwidth="1*"/>
					<colspec colnum="2" colname="col2" colwidth="5*"/>
					<thead>
						<row>
							<entry align="center">Goal</entry>
							<entry align="center">Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>help</entry>
							<entry>사용 가능한 Command 목록을 보여준다.
								<para>
									command : 상세조회하고자 하는 Goal의 이름을 입력한다.[선택]
								</para>
							</entry>
						</row>
						<row>
							<entry>install</entry>
							<entry>
								anyframe-basic-archetype(또는 anyframe-service-archetype) 설치 후, 생성된 샘플 프로젝트 구조를 기반으로 지정된 Plugin을 설치한다.
								다음과 같은 Option을 가진다.
								<para>
									name : 설치 대상 Plugin 명을 지정한다. [필수]
								</para>		
								<para>
									version : 설치 대상 Plugin Version을 지정한다. [선택]
								</para>
							</entry>
						</row>
						<row>
							<entry>uninstall</entry>
							<entry>
								이미 설치된 Plugin을 삭제한다. 다음과 같은 Option을 가진다.
								<para>
									name : 삭제 대상 Plugin 명을 지정한다. [필수]
								</para>		
								<para>
									excludes : Plugin 삭제 시에 특정 파일은 삭제되지 않도록 지정할 수 있다. [선택]
								</para>
							</entry>
						</row>
						<row>
							<entry>create-model</entry>
							<entry>
								테이블 당 1개의 Domain 클래스를 생성한다. 
								테이블명 지정시에는 대소문자를 구분하므로 유의하여 테이블명을 입력해야 한다. 특히, 해당하는 DB에 맞게 대소문자를 표현해야 한다. 
								hsqldb, oracle의 경우 대문자로 테이블명을 표현해야 하고, mysql의 경우 테이블명을 소문자로 표현해야 한다.
								<para>
									table : Domain 클래스 생성을 위한 대상 테이블명을 정의한다. 여러 개의 테이블을 대상으로 할 경우에는 "," 기호를 구분자로 이용한다.
									또한 대상 테이블이 다른 테이블과 Relation 관계에 놓여 있다면 Relation 관계에 놓여 있는 테이블을 같이 정의해주도록 한다.
									[선택, 기본값은 '*'로써 모든 테이블에 대해 Domain 클래스 생성]
								</para>		
								<para>
									package : 생성될 Domain 클래스의 패키지를 정의한다. [선택, 기본값은 해당 프로젝트의 대표 패키지 + ".domain"]
								</para>																 
							</entry>
						</row>
						<row>
							<entry>create-crud</entry>
							<entry>
								하나의 Domain 클래스를 기준으로 기본 CRUD 기능을 구현한 비즈니스 레이어, 프리젠테이션 레이어에 속한 소스 코드를 생성한다.
								<para>
									entity : CRUD 소스 코드 생성을 위한 대상 Domain 클래스를 정의한다. 클래스명만 정의한 경우에는 해당 프로젝트의 대표 패키지 + ".domain" 하위에서
									해당 Domain 클래스를 찾게 된다. 따라서 다른 패키지에 해당 Domain 클래스가 존재하는 경우 해당 클래스의 패키지명까지 포함하여 정의해주도록 한다. [필수]
								</para>
								<para>
									templateType : CRUD 소스 코드 생성을 위한 대상 템플릿을 정의한다. 템플릿 경로의 폴더명을 기준으로 한다. [필수]
								</para>
								<para>
									package : 생성될 CRUD 소스 코드의 패키지를 정의한다. [선택, 기본값은 해당 프로젝트의 대표 패키지 + {입력된 Entity 클래스 이름(소문자)}]
								</para>	
								<para>
									scope : 생성될 CRUD 소스 코드를 영역을 한정하는데 사용된다. scope을 "service"로 정의한 경우 비즈니스 레이어 영역의 CRUD 소스 코드만 생성된다.
									[선택, 기본값은 "all"로써 프리젠테이션 레이어, 비즈니스 레이어의 모든 소스 코드를 생성]
								</para>								
							</entry>							
						</row>		
						<row>
							<entry>change-db</entry>
							<entry>
								현재 사용중인 DB를 변경하고자 할 때 DB 변경으로 인해 영향받는 속성 정보들을 일괄 변경해준다. (해당 프로젝트 내의 META-INF/project.mf 파일 내에 정의된 DB 정보를 기준으로 동작함.)
								<note>
									<title>참고</title>
									<para>
										현재 Anyframe에서 제공하는 Plugin들은 기본인 HsqlDB외에 Oracle, Sybase, MySQL, DB2, MSSQL를 위한 리소스를 추가로 제공하고 있다.
									</para>
								</note>
							</entry>
						</row>	
						<row>
							<entry>inplace</entry>
							<entry>
								생성된 샘플 프로젝트 하위의 src/main/webapp/WEB-INF/lib 폴더에
								pom.xml 파일을 기준으로 샘플 어플리케이션 실행에 필요한 모든 참조 라이브러리를 다운로드한다.
							</entry>
						</row>									
						<row>
							<entry>update-catalog</entry>
							<entry>
								{user.home}/.anyframe 디렉토리 내에 존재하는 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일을 
								Anyframe Repository(http://dev.anyframejava.org/maven/repo) 내의 최신 plugin catalog 파일로
								교체해준다. 이로써 Plugin 목록 조회시 최신 정보를 조회할 수 있도록 한다.
								{user.home}/.anyframe 디렉토리 내에 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일이 없을 경우에도 활용 가능하다.
							</entry>
						</row>
						<row>
							<entry>list</entry>
							<entry>
								설치 가능한 Plugin의 이름과 버전 정보를 보여준다.
							</entry>
						</row>
						<row>
							<entry>info</entry>
							<entry>
								지정한 Plugin의 상세 정보를 조회할 수 있다.
								<para>
									name : 조회하고자 하는 Plugin의 이름을 지정한다. [필수]
								</para>
							</entry>
						</row>
						<row>
							<entry>list-update</entry>
							<entry>
								현재 생성된 샘플 프로젝트에 설치된 Plugin 중 버전 업데이트 가능한 Plugin 목록을 보여준다.
							</entry>
						</row>
						<row>
							<entry>installed</entry>
							<entry>
								설치된 Plugin 현황 및 해당 Plugin의 최신 버전 정보를 보여준다.
							</entry>
						</row>																																					
					</tbody>
				</tgroup>
			</informaltable>		
		</section>		
	</section>
		
	<section id="commands_maven_generate">
		<title>프로젝트 구조 생성</title>
		<para>
			생성할 샘플 프로젝트의 기본 구조 생성을 위해 적절한 Anyframe Archetype을 설치해야 한다. 이후 이를 기반으로 Anyframe을 활용한 개발 환경 구성이 가능해진다.
			Anyframe 4.6.0 이후부터 anyframe-basic-archetype, anyframe-service-archetype을 제공하고 있으며
			'web' 타입의 프로젝트는 anyframe-basic-archetype이, 'service' 타입의 프로젝트는 anyframe-service-archetype이 설치된다. 
			본 장에서는 anyframe-basic-archetype을 기준으로 설명을 
			진행할 것이다. (Anyframe Archetype에 대해서는 <link linkend="commands_maven_generate_archetype">Archetype</link>을 참고하도록 한다.) 
		</para>
		<para>
			먼저 anyframe-basic-archetype을 설치해 보도록 하자.
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					Command 창을 띄우고 다음과 같이 명령어를 입력하여 anyframe-basic-archetype 설치를 시작한다. 
				</para>
				<programlisting language="java"><![CDATA[mvn archetype:generate 
    	-DarchetypeCatalog="http://dev.anyframejava.org/maven/repo/archetype-catalog.xml"]]></programlisting>			
				<para>
					위와 같이 명령어를 입력하면 Command 창에 archetypeCatalog 속성값으로 정의된 http://dev.anyframejava.org/maven/repo/archetype-catalog.xml 
					파일 내에 정의된 Maven Archetype 목록이 제시될 것이다. 
				</para>
				<programlisting language="java"><![CDATA[Choose archetype:
1: http://dev.anyframejava.org/maven/repo/archetype-catalog.xml -> org.anyframe.archetype:anyframe-basic-archetype (anyframe basic archetype (latest stable 5.2.0))
2: http://dev.anyframejava.org/maven/repo/archetype-catalog.xml -> org.anyframe.archetype:anyframe-service-archetype (anyframe service archetype (latest stable 2.2.0))
3: http://dev.anyframejava.org/maven/repo/archetype-catalog.xml -> anyframe.archetype:anyframe-basic-archetype (-)
Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): : 1]]></programlisting>
				<para>			
					위와 같이 archetype-catalog.xml 파일 내에 정의된 anyframe-basic-archetype 이라는 이름의 archetype이 Command
					창에 제시됨을 알 수 있다. 제시된 Maven Archetype 목록 중 최신 anyframe-basic-archetype에 해당하는 번호('1')를 선택한다. 				
				</para>
			</listitem>
			<listitem>
				<para>
					archetype-catalog.xml 파일에 등록된 anyframe-basic-archetype의 버전이 여러개일 경우 
					아래와 같이 버전을 선택할 수 있도록 버전 목록이 제시될 것이다.
					설치할 anyframe-basic-archetype의 버전에 해당하는 번호를 선택하면 된다.
					(등록된 anyframe-basic-archetype의 버전이 1개일 경우 버전 목록이 제시되지 않고 바로 다음 단계로 이동한다.)
				</para>			
			</listitem>
			<listitem>
				<para>				
					샘플 프로젝트 생성을 위해 다음과 같이 각 인자에 대한 값을 입력한다.
		<programlisting language="java"><![CDATA[Define value for property 'groupId': : myapp
Define value for property 'artifactId': : myproject
Define value for property 'version': 1.0-SNAPSHOT: 1.0.0
Define value for property 'package': myapp: anyframe
Confirm properties configuration:
groupId: myapp
artifactId: myproject
version: 1.0.0
package: anyframe
Y: y]]></programlisting>
				</para>
				<informaltable>
					<tgroup cols="3">
						<colspec colnum="1" colname="col1" colwidth="1*"/>
						<colspec colnum="2" colname="col2" colwidth="5*"/>
						<colspec colnum="3" colname="col3" colwidth="2*"/>
						<thead>
							<row>
								<entry align="center">Parameter</entry>
								<entry align="center">Description</entry>
								<entry align="center">Default Value</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>groupId</entry>
								<entry>설치 대상 프로젝트의 groupId이다.</entry>
								<entry>N/A</entry>
							</row>
							<row>
								<entry>artifactId</entry>
								<entry>설치 대상 프로젝트의 artifactId로써 해당 프로젝트를 설치할 대상 폴더명과 프로젝트명이 된다.</entry>
								<entry>N/A</entry>
							</row>
							<row>
								<entry>version</entry>
								<entry>설치 대상 프로젝트의 version이다.</entry>
								<entry>1.0-SNAPSHOT</entry>
							</row>
							<row>
								<entry>package</entry>
								<entry>설치 대상 프로젝트 내 소스 코드에 대한 대표 패키지명이 된다.</entry>
								<entry>groupId로 정의한 값</entry>
							</row>																					
						</tbody>
					</tgroup>
				</informaltable>
				<para>
					anyframe-basic-archetype-x.x.x.jar 라이브러리가 Maven Local Repository 내에 존재하지 않는 경우 앞서 settings.xml 파일에 정의한 Anyframe 
					Repository로부터 이를 다운로드하고, 입력한 속성값을 기반으로 샘플 프로젝트가 생성될 것이다.
					(settings.xml 파일 내의 <![CDATA[<localRepository></localRepository>]]>를 별도로 정의하지 않은 경우 Maven Local Repository는 기본적으로
					{user.home}/.m2/repository가 될 것이다.)						
				</para>
			</listitem>
			<listitem>
				<para>
					다음은 anyframe-basic-archetype 설치를 통해 구성된 샘플 프로젝트의 기본 모습이다. 설치된 샘플 프로젝트명은 myproject이며, 하위에 다양한
					용도의 폴더를 포함하고 있다.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="../image/commands/maven/myproject_structure.jpg"
								align="center" />
						</imageobject>
					</mediaobject>
				</para>
			</listitem>
			<listitem>
				<para>
					anyframe-basic-archetype 설치 완료 후에는 <link linkend="commands_maven_run">어플리케이션 실행</link>을 참조하여 정상 동작 여부를 확인하도록 한다.
				</para>
			</listitem>
		</orderedlist>
		<section id="commands_maven_generate_archetype">
			<title>Archetype</title>
			<para>
				개발 프로젝트의 구조 생성을 위해 반드시 미리 설치되어야 하는 Anyframe archetype의 구조에 대해 살펴보자.
				(Anyframe 4.6.0 이후부터는 웹 프로젝트 구조 생성을 위한 <link linkend="plugins_archetype_basic">anyframe-basic-archetype</link>과 서비스 프로젝트 구조 생성을 위한 
				<link linkend="plugins_archetype_service">anyframe-service-archetype</link>을 제공한다.)
			</para>
			
			<section id="plugins_archetype_basic">
				<title>anyframe-basic-archetype</title>
				<para>
					anyframe-basic-archetype은 프리젠테이션 레이어와 비즈니스 레이어로 구성된 웹 프로젝트의 기본 구조를 정의하고 있는 Maven Archetype이다. 따라서, 명령어 mvn archetype:generate를 
					이용하면, anyframe-basic-archetype 내에 정의된 웹 프로젝트 구조가 정해진 위치에 생성된다.
				</para>
				<para>
					다음은 anyframe-basic-archetype의 src/main/resources 하위에 위치한 주요 구성 요소를 표현한 그림이다.
				</para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="../image/plugins/basic_archetype_structure.jpg" align="center" />
					</imageobject>
				</mediaobject>	
				<para>
					archetype-resources는 리소스 템플릿을 관리하기 위한 용도의 폴더로써 pom.xml 파일과 함께 다음과 같은 하위 폴더를 가진다.
					pom.xml 파일 내에는 anyframe-basic-archetype 설치 후, 생성될 샘플 어플리케이션 실행 및 소스 코드 품질 검토 결과 리포팅 등에 필요한 Maven Plugin들이 정의되어 있다.
					다음은 archetype-resources 폴더를 구성하는 주요 하위 폴더/파일에 대한 설명이다. 
				</para>
				<informaltable>
					<tgroup cols="2">
						<colspec colnum="1" colname="col1" colwidth="1*"/>
						<colspec colnum="2" colname="col2" colwidth="5*"/>
						<thead>
							<row>
								<entry align="center">Folder</entry>
								<entry align="center">Description</entry>
							</row>
						</thead>
						<tbody>	
							<row>
								<entry>META-INF</entry>
								<entry>
									Plugin 설치 정보를 관리하기 위한 plugin-installed.xml 파일과 샘플 프로젝트 및 DB 정보 등을 포함한 각종 Meta 정보 관리를 위한 
									project.mf 파일을 가진다.
								</entry>
							</row>	
							<row>
								<entry>.settings</entry>
								<entry>Eclipse 프로젝트 정보를 관리한다.</entry>
							</row>
							<row>
								<entry>db/hsqldb</entry>
								<entry>샘플 어플리케이션 실행에 필요한 샘플 DB이다.</entry>
							</row>	
							<row>
								<entry>src/main/java</entry>
								<entry>
									소스 코드를 관리하기 위한 용도의 폴더를 가진다.
								</entry>
							</row>	
							<row>
								<entry>src/main/resources</entry>
								<entry>
									Spring, SpringMVC 기반의 어플리케이션 실행을 위한 속성 정의 파일과 메시지 파일, 쿼리문을 정의하고
									있는 매핑 XML 파일들을 관리하기 위한 용도의 폴더를 가진다.
								</entry>
							</row>	
							<row>
								<entry>src/main/webapp</entry>
								<entry>웹 어플리케이션을 위한 웹 리소스(*.jsp, *.css, *.js ...)들을 관리하기 위한 용도의 폴더를 가진다.</entry>
							</row>
							<row>
								<entry>src/test/java</entry>
								<entry>테스트 코드를 관리하기 위한 용도의 폴더를 가진다.</entry>
							</row>	
							<row>
								<entry>src/test/resources</entry>
								<entry>테스트 코드 실행에 필요한 리소스들을 관리하기 위한 용도의 폴더를 가진다.</entry>
							</row>																																									
						</tbody>
					</tgroup>
				</informaltable>
				<para>META-INF는 anyframe-basic-archetype의 리소스 템플릿에 대한 Meta 정보를 관리하기 위한 용도의 폴더로써 다음과 같은 하위 폴더를 가진다.</para>
				<informaltable>
					<tgroup cols="2">
						<colspec colnum="1" colname="col1" colwidth="1*"/>
						<colspec colnum="2" colname="col2" colwidth="5*"/>
						<thead>
							<row>
								<entry align="center">Folder</entry>
								<entry align="center">Description</entry>
							</row>
						</thead>
						<tbody>	
							<row>
								<entry>maven</entry>
								<entry>
									리소스 템플릿을 이용하여 샘플 프로젝트를 생성할 때 필요한 Meta 정보를 관리하는 archetype-metadata.xml 파일을 가진다.
								</entry>
							</row>	
						</tbody>
					</tgroup>
				</informaltable>			
			</section>	
			<section id="plugins_archetype_service">
				<title>anyframe-service-archetype</title>
				<para>
					anyframe-service-archetype은 비즈니스 레이어로만 구성된 서비스 프로젝트의 기본 구조를 정의하고 있는 Maven Archetype이다. 따라서, 명령어 mvn archetype:generate를 이용하면, 
					anyframe-service-archetype 내에 정의된 서비스 프로젝트 구조가 정해진 위치에 생성된다.
				</para>
				<note>
					<title>참고</title>
					<para>
						anyframe-service-archetype으로 인해 생성된 서비스 프로젝트의 경우 해당 프로젝트를 대상으로 Anyframe Plugin을 설치하더라도 선택된 Plugin 관련 샘플 코드/속성 
						파일은 추가되지 않고 참조 라이브러리만 추가된다는 것을 기억하도록 하자.
					</para>
				</note>
				<para>
					다음은 anyframe-service-archetype의 src/main/resources 하위에 위치한 주요 구성 요소를 표현한 그림이다.
				</para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="../image/plugins/service_archetype_structure.jpg" align="center" />
					</imageobject>
				</mediaobject>	
				<para>
					archetype-resources는 리소스 템플릿을 관리하기 위한 용도의 폴더로써 pom.xml 파일과 함께 다음과 같은 하위 폴더를 가진다.
					pom.xml 파일 내에는 anyframe-service-archetype 설치 후, 생성될 샘플 어플리케이션 실행 및 소스 코드 품질 검토 결과 리포팅 등에 필요한 Maven Plugin들이 정의되어 있다.
					다음은 archetype-resources 폴더를 구성하는 주요 하위 폴더/파일에 대한 설명이다. 
				</para>
				<informaltable>
					<tgroup cols="2">
						<colspec colnum="1" colname="col1" colwidth="1*"/>
						<colspec colnum="2" colname="col2" colwidth="5*"/>
						<thead>
							<row>
								<entry align="center">Folder</entry>
								<entry align="center">Description</entry>
							</row>
						</thead>
						<tbody>	
							<row>
								<entry>META-INF</entry>
								<entry>
									Plugin 설치 정보를 관리하기 위한 plugin-installed.xml 파일과 샘플 프로젝트 및 DB 정보 등을 포함한 각종 Meta 정보 관리를 위한 
									project.mf 파일을 가진다.
								</entry>
							</row>	
							<row>
								<entry>.settings</entry>
								<entry>Eclipse 프로젝트 정보를 관리한다.</entry>
							</row>
							<row>
								<entry>db/hsqldb</entry>
								<entry>샘플 어플리케이션 실행에 필요한 샘플 DB이다.</entry>
							</row>	
							<row>
								<entry>src/main/java</entry>
								<entry>
									소스 코드를 관리하기 위한 용도의 폴더를 가진다. 어플리케이션 개발에 공통적으로 필요한 기본 Exception 클래스 및 Aspect 클래스를 포함하고 있다.
								</entry>
							</row>	
							<row>
								<entry>src/main/resources</entry>
								<entry>
									Spring, SpringMVC 기반의 어플리케이션 실행을 위한 속성 정의 파일과 메시지 파일, 쿼리문을 정의하고
									있는 매핑 XML 파일들을 관리하기 위한 용도의 폴더를 가진다. 어플리케이션 개발에 공통적으로 필요한 기본 속성 정의 파일을 포함하고 있다.
								</entry>
							</row>	
							<row>
								<entry>src/test/java</entry>
								<entry>테스트 코드를 관리하기 위한 용도의 폴더를 가진다.</entry>
							</row>	
							<row>
								<entry>src/test/resources</entry>
								<entry>
									테스트 코드 실행에 필요한 리소스들을 관리하기 위한 용도의 폴더를 가진다. 
									CRUD 소스 코드 생성시 활용할 샘플 데이터 정보를 관리하기 위한 XML 파일을 포함하고 있다.</entry>
							</row>																																									
						</tbody>
					</tgroup>
				</informaltable>
				<para>META-INF는 anyframe-service-archetype의 리소스 템플릿에 대한 Meta 정보를 관리하기 위한 용도의 폴더로써 다음과 같은 하위 폴더를 가진다.</para>
				<informaltable>
					<tgroup cols="2">
						<colspec colnum="1" colname="col1" colwidth="1*"/>
						<colspec colnum="2" colname="col2" colwidth="5*"/>
						<thead>
							<row>
								<entry align="center">Folder</entry>
								<entry align="center">Description</entry>
							</row>
						</thead>
						<tbody>	
							<row>
								<entry>maven</entry>
								<entry>
									리소스 템플릿을 이용하여 샘플 프로젝트를 생성할 때 필요한 Meta 정보를 관리하는 archetype-metadata.xml 파일을 가진다.
								</entry>
							</row>	
						</tbody>
					</tgroup>
				</informaltable>		
			</section>
		</section>
	</section>
	
	<section id="commands_maven_install">
		<title>Plugin 설치</title>
		<para>
			Anyframe 4.6.0 이후부터는 다양한 오픈 소스들이 통합된 템플릿 기반의 샘플 코드, 참조 라이브러리 집합을 Plugin이라 칭하며, 다양한 유형의 Plugin을 제공한다.
		</para>
		<para>
			Anyframe의 Plugin들은 <emphasis role="bold">필수(Essential) Plugin</emphasis>과 <emphasis role="bold">선택(Optional) Plugin</emphasis>으로 나눌 수 있다.
			필수 Plugin에는 core, spring, datasource, logging 과 같이 다른 Plugin이 동작하는데 기본적으로 필요한 기능들을 가진 Plugin들이 속해 있고,
			선택 Plugin에는 hibernate, cxf-jaxrs, fileupload 등과 같이 어플리케이션 개발시 사용할 수 있는 여러 기능들을 제공하는 Plugin들로 구성되어 있다.
			(Plugin에 대한 자세한 내용은 <link linkend="plugins_list">Plugin 목록</link>과 <link linkend="plugins_structure">Plugin 구조</link>를 참조하도록 한다.)
		</para>
		<para>
			다음에서는 기본적인 Command 사용법을 언급하고 있으므로 Anyframe Commmand Option에 대해서는 <link linkend="commands_maven_commands_list">Command 목록</link>내에 제시된 해당 Command의
			설명을 참고하도록 한다.		
		</para>		
		
		<para>
			Anyframe의 Plugin은 특정 Plugin이 동작하는 데 필요한 Plugin을 Dependent Plugin으로 설정할 수 있다. 
			그래서 특정 Plugin 설치 시에 Dependent Plugin이 설치되지 않았을 경우 자동으로 우선 설치될 수 있도록 한다.
		</para>
		<para>
			여기서는 다른 Anyframe Plugin들의 동작을 위한 기반을 제공하는 필수 Plugin인 core plugin을 설치해 보도록 하자. 
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					Command 창을 띄우고 앞서 설치한 [샘플 프로젝트 설치 폴더]/db/hsqldb 폴더로 이동하여 start.cmd (or start.sh) 파일을 더블클릭함으로써 샘플용으로 제공되는 
					hsqldb를 시작시킨다. 해당 Plugin 실행을 위해 DB 데이터 추가가 필요한 경우 선택한 Plugin 설치시 DB 데이터 추가 작업도 함께 이루어지므로 DB를 시작시켜 놓아야 한다. 
					만일 선택한 Plugin 설치시 DB가 시작되지 않았다면 Plugin 설치 이후 제공되는 DB 스크립트 파일([샘플 프로젝트 설치 폴더]/db/scripts/{plugin명-insert-data-db명}.sql)을 
					직접 실행시키면 된다. 또한 샘플용으로 제공되는 hsqldb가 아닌 다른 DB 기반에서 Plugin을 설치하고자 하는 경우에는 
					<link linkend="commands_maven_db">DB 변경</link>을 참고하도록 한다.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="../image/commands/maven/start_hsqldb.jpg"
								align="center" />
						</imageobject>
					</mediaobject>
				</para>
				<warning>
					<title>주의 사항</title>
					<para>
						Windows 환경에서는 start.cmd 파일을 CLI 상에서 실행시키고, Unix 환경(ex. Mac OS
						등)에서는
						우선 hsqldb 폴더 하위의 파일들에 대해서 실행 권한을 부여(chmod 755 *)한 후, start.sh
						파일을 실행(./start.sh)시킨다.
					</para>
				</warning>				
			</listitem>
			<listitem>
				<para>
					Command 창을 띄우고 샘플 프로젝트 설치 폴더로 이동(예를 들어, myproject 라는 프로젝트를
					생성시켰다면 myproject 폴더에서 command를 실행시키도록 한다.)하여 다음과 같이 명령어를 입력한다.
					여기서는 core plugin을 설치할 것이므로 name 옵션의 값으로 'core'를 입력하여 core plugin 설치 작업을 진행한다.
				</para>
				<programlisting language="java"><![CDATA[mvn anyframe:install -Dname=core]]></programlisting>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="../image/commands/maven/install_core_plugin.jpg"
								align="center" />
						</imageobject>
					</mediaobject>
				</para>
				<para>
					위와 같이, Plugin install 명령어를 입력하면 <emphasis role="bold">설치하고자 하는 Plugin의 dependency 관계 및 현재 프로젝트에 설치여부를 파악하여 
					최종적으로 설치될 Plugin들의 목록을 출력해주고 사용자의 승인을 기다린다.</emphasis>
					core plugin의 동작을 위해서는 datasource, logging, spring Plugin이 필요하므로 위와 같이 출력될 것이다.
					계속 설치를 진행하고자 하는 경우 'y'를 입력한다.
					<note>
						<title>Essential Plugins</title>
						<para>
							core, datasource, logging, spring plugin은 필수 plugin으로, 
							datasource, logging, spring plugin은 단독으로 설치할 수 없고, 
							core를 설치하면 4가지 plugin이 모두 설치된다.
						</para>
					</note>
				</para>
			</listitem>
			<listitem>
				<para>
					Plugin 설치 완료 후에는 <link linkend="commands_maven_run">어플리케이션 실행</link>을 참조하여 정상 동작 여부를 확인하도록 한다.
				</para>
			</listitem>
			<listitem>
				<para>
					Command 창을 띄우고 샘플 프로젝트 설치 폴더로 이동하여 다음과 같은 명령어를 입력하면 샘플 프로젝트를 대상으로 설치된 Plugin 목록을 확인할 수 있을 것이다. 
				</para>
				<programlisting language="java"><![CDATA[mvn anyframe:installed]]></programlisting>
				<mediaobject>
					<imageobject>
						<imagedata fileref="../image/commands/maven/show_plugin_installed.jpg"
							align="center" />
					</imageobject>
				</mediaobject>
			</listitem>
		</orderedlist>
		<para>
			core plugin과 동일한 방법으로 다른 Plugin들을 추가로 설치할 수 있다.
		</para>
		
		<para>
			또한 이미 설치된 Plugin이라 하더라도 다음과 같이 <emphasis role="bold">명령어에 version옵션을 추가하여 다른 버전으로 교체</emphasis>할 수 있다.
			이 경우 해당 Plugin이 참조하는 다른 Plugin(Dependent Plugin)도 호환되는 버전으로 교체될 수 있다. 
			Plugin 버전 변경으로 인해 관련된 참조라이브러리 버전도 변경될 수 있음에 유의한다.
			<programlisting language="java"><![CDATA[mvn anyframe:install -Dname=... -Dversion=...]]></programlisting>
			<mediaobject>
				<imageobject>
					<imagedata fileref="../image/commands/maven/install_plugin_version.jpg"
						align="center" />
				</imageobject>
			</mediaobject>
		</para>
		
		<important>
			<title>기존 Maven 사용자 유의 사항</title>
			<para>
				Anyframe에서는 Maven 기반에서 Anyframe 관련 라이브러리 다운로드시에 
				참조 관계에 놓인 모든 Anyframe 및 3rd-party 라이브러리들이 한꺼번에 다운로드되는 현상을 막기 위해 
				각 라이브러리들 간의 참조 관계를 끊은 상태로 Anyframe Repository에 배포하고 있다. 
				때문에 기존 Maven 사용자들은 Local Repository에 이미 존재하는 3rd-party 라이브러리가 가진 참조 관계에 문제가 
				생겨 Anyframe 설치시에 오류가 발생할 수 있다. 따라서 설치에 문제가 있는 경우에는 Local Repository를 삭제한 후 재설치해 볼 것을 권장한다.
			</para>
		</important>
	</section>
	
	<section id="commands_maven_uninstall">
		<title>Plugin 삭제</title>
		<para>
			샘플 프로젝트를 대상으로 설치된 Plugin들은 삭제가 가능하다. 
			단, 삭제하고자 하는 Plugin을 다른 Plugin이 사용하고 있는 경우에는 삭제할 수 없다. 
			이 경우, Dependency 관계를 가지는 Plugin들을 먼저 삭제한 후에 본래 삭제하려고 했던 Plugin을 삭제해야한다.
		</para>	
		<para>
			특정 Plugin 삭제를 요청한 경우 삭제 대상 Plugin 이름을 포함한 모든 폴더 및 파일들이 해당 프로젝트로부터 제거될 것이다. 
			따라서 특정 Plugin을 삭제하기 전에 개발을 진행하면서 추가한 리소스가 삭제 대상에 포함되지 않는지 체크해 볼 것을 권장한다.
		</para>
		<orderedlist>
			<listitem>
				<para>
					Command 창을 열고 샘플 프로젝트 설치 폴더로 이동하여 다음과 같이 명령어를 입력한다. 
				</para>		
				<programlisting language="java"><![CDATA[mvn anyframe:uninstall -Dname=...]]></programlisting>
				<para>
					excludes 옵션을 사용하면 plugin 삭제 시에 삭제 대상에서 제외시킬 파일을 지정할 수 있다.
				</para>
				<para>
					삭제하려고 하는 Plugin을 나머지 Plugin에서 사용하고 있지 않다면 문제없이 삭제될 것이다.
				</para>	
			</listitem>
			<listitem>
				<para>
					Command 창을 열고 샘플 프로젝트 설치 폴더로 이동하여 다음과 같은 명령어를 입력하면 해당 Plugin이 정상적으로 삭제되었는지 확인할 수 있다. 
				</para>
				<programlisting language="java"><![CDATA[mvn anyframe:installed]]></programlisting>
			</listitem>
		</orderedlist>
		<para>
			삭제된 plugin 관련 파일이나 디렉토리는 '[샘플 프로젝트 root 폴더]/uninstalled' 하위에 
			plugin을 삭제한 시점별로 디렉토리에 백업되어 있으므로 복구가 가능하다.
		</para>	
	</section>
	
	<section id="commands_maven_list">
		<title>Plugin 목록 조회</title>
		<para>
			설치할 수 있는 Plugin 목록을 조회하려면 다음과 같은 명령어를 사용한다.
			<programlisting language="java"><![CDATA[mvn anyframe:list]]></programlisting>
			<mediaobject>
				<imageobject>
					<imagedata fileref="../image/commands/maven/show_plugin_list.jpg"
						align="center" />
				</imageobject>
			</mediaobject>
		</para>
		<para>
			설치 가능한 Plugin 목록은 Plugin Catalog 파일 기반으로 조회되는데 Anyframe에서는 먼저 해당 파일이 '{user.home}/.anyframe' 디렉토리에 존재하는지 체크해 보고 
			있을 경우 해당 파일에 정의된 Plugin 정보를 활용하게 된다. 만일 '{user.home}/.anyframe' 디렉토리에 해당 파일이 존재하지 않으면 Anyframe Repository인 
			http://dev.anyframejava.org/maven/repo/에 있는 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일을 
			'{user.home}/.anyframe' 디렉토리에 다운로드하고 이 파일을 활용하게 된다.
			한번 다운로드한 Local의 Plugin Catalog 파일을 Anyframe Repository 내의 최신 Plugin Catalog 파일과 동기화하기 위해서는 
			<link linkend="commands_maven_update_catalog">Plugin Catalog Update</link>를 참조하도록 한다.
		</para>
	</section>
	
	<section id="commands_maven_installed">
		<title>설치된 Plugin 목록 조회</title>
		<para>
			다음의 command를 실행하면 샘플 프로젝트를 대상으로 설치된 Plugin들의 이름과 버전 및 각 Plugin의 최신 버전 정보를 확인할 수 있다.
		</para>
		<programlisting language="java"><![CDATA[mvn anyframe:installed]]></programlisting>
		<mediaobject>
			<imageobject>
				<imagedata fileref="../image/commands/maven/show_plugin_installed.jpg"
					align="center" />
			</imageobject>
		</mediaobject>
		<para>
			설치된 Plugin 정보는 샘플 프로젝트 하위의 META-INF/plugin-installed.xml 파일에 기록된다.
		</para>
	</section>
	
	<section id="commands_maven_info">
		<title>Plugin 정보 조회</title>
		<para>
			특정 Plugin의 상세한 정보를 조회하고자 하는 경우 다음과 같은 command를 이용하면 된다.
			<programlisting language="java"><![CDATA[mvn anyframe:info -Dname=...]]></programlisting>
		</para>
		<para>
			예를 들어, core plugin의 상세 정보를 조회하면 아래와 같이 출력된다.
			<programlisting language="java"><![CDATA[ Name		: core
 GroupId		: org.anyframe.plugin
 ArtifactId		: anyframe-core-pi
 Latest Version	: x.x.x
 Samples		: Included
 Releases		: 1.0.0-SNAPSHOT,1.0.0.RC1,1.0.0,1.0.1-SNAPSHOT, 1.0.1, ...
 Dependencies	: datasource(1.0.0-SNAPSHOT<=*),logging(1.0.0-SNAPSHOT<=*),spring(1.0.0-SNAPSHOT<=*)
 Description	: Core Plugin is the basic plugin which is the basis of all
                   plugins provided by Anyframe, and consists of sample code
                   to guide how to use Spring MVC, Spring, etc. and reference
                    libraries to use these open sources.]]></programlisting>
		</para>
	</section>
	
	<section id="commands_maven_update_catalog">
		<title>Plugin Catalog Update</title>
		<para>
			앞서 언급한 바와 같이 Anyframe에서는 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일 내에 설치 가능한 Plugin 목록을 정의하고 있다. 
			Anyframe에서는 이 파일을 기반으로 설치 가능한 Plugin 목록을 조회하는데 먼저 해당 파일이 '{user.home}/.anyframe' 디렉토리에 존재하는지 체크해 보고 
			있을 경우 해당 파일에 정의된 Plugin 정보를 활용하게 된다. 만일 '{user.home}/.anyframe' 디렉토리에 해당 파일이 존재하지 않으면 Anyframe Repository인 
			http://dev.anyframejava.org/maven/repo/에 있는 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일을 
			'{user.home}/.anyframe' 디렉토리에 다운로드하고 이 파일을 활용하게 된다.
			사용자의 '{user.home}/.anyframe' 하위에 한 번 다운로드가 된 이후에는 Local의 Plugin Catalog 파일만을 이용하게 되므로 
			시간이 지나면 Anyframe Repository 내의 최신 Plugin Catalog 파일과 일치하지 않을 수 있다. 
			따라서 최신 Plugin Catalog 파일과의 동기화를 위해서는 다음과 같은 작업이 필요하다.
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					Command 창을 띄운 후, 샘플 프로젝트가 있는 위치로 이동하여 다음과 같이 Maven 명령어를 입력함으로써 최신 Plugin Catalog 파일을 Local에 다운로드할 수 있다.
				</para>
				<programlisting language="java"><![CDATA[mvn anyframe:update-catalog]]></programlisting>				
			</listitem>
			<listitem>
				<para>
					다음과 같이 Maven 명령어를 입력함으로써 최신 Plugin Catalog가 정상적으로 반영되었는지 확인해보자.
				</para>	
				<programlisting language="java"><![CDATA[mvn anyframe:list]]></programlisting>
			</listitem>
		</orderedlist>			
	</section>
	
	<section id="commands_maven_list_update">
		<title>Update가능한 Plugin 목록 조회</title>
		<para>
			샘플 프로젝트를 대상으로 설치된 Plugin 중 버전 업데이트를 할 수 있는 Plugin이 있는지 확인하려면 다음과 같은 명령어를 사용한다.
			<programlisting language="java"><![CDATA[mvn anyframe:list-update]]></programlisting>
		</para>
		<para>
			단, Local의 Plugin Catalog 파일을 최신 버전으로 업데이트 한 후에야 정확한 정보를 확인할 수 있다. 
			Local Plugin Catalog를 업데이트 하는 방법은 본 문서의 <link linkend="commands_maven_update_catalog">Plugin Catalog Update</link>를 참조하도록 한다.
		</para>
		<para>
			현재 구성된 샘플 프로젝트에 설치된 Plugin의 버전이 최신 버전이 아닌 경우 이전 버전의 Plugin에 대해 최신 버전을 적용할 수 있도록 지원한다. 
			이를 원할 경우 <link linkend="commands_maven_install">Plugin 설치</link>를 참고하도록 한다. 
		</para>
	</section>
	
	<section id="commands_maven_db">
		<title>DB 변경</title>
		<para>
			앞서 언급한 바와 같이 Plugin 설치를 통해 생성된 샘플 프로젝트는 기본적으로 hsqldb를 기반으로 동작하도록 구성되어 있다. 그런데 만약 샘플 프로젝트의 실행 DB를 변경하고자 원한다면 
			다음과 같은 작업을 수행해야 한다. 
			(현재 샘플을 제공하고 있는 Anyframe 플러그인은 hsqldb, oracle, sysbase, db2, mysql, mssql DB에 대해서만 동작하도록 지원하고 있다.)
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					설치된 샘플 프로젝트 설치 폴더 하위의 META-INF/project.mf 파일을 열고 기 정의된 DB 정보를 적절하게 수정한다.
				</para>
				<programlisting language="java">db.type=hsqldb
db.name=sampledb
db.schema=PUBLIC
db.server=localhost
db.port=-1
db.driver=org.hsqldb.jdbcDriver
db.url=jdbc:hsqldb:hsql://localhost/sampledb
db.userId=SA
db.password=
db.lib=db/hsqldb/hsqldb-2.0.0.jar
db.dialect=org.hibernate.dialect.HSQLDialect

db.groupId=hsqldb
db.artifactId=hsqldb
db.version=2.0.0</programlisting>	
				<para>
					위에 제시된 각 속성은 다음과 같은 의미를 지닌다.					
				</para>
				<para>
					<informaltable>
						<tgroup cols="2">
							<colspec colnum="1" colname="col1" colwidth="1*"/>
							<colspec colnum="2" colname="col2" colwidth="5*"/>
							<thead>
								<row>
									<entry align="center">Property</entry>
									<entry align="center">Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>db.type</entry>
									<entry>
										해당 DB에 대한 대표명을 정의한다. 특정 Plugin 설치 실행해야 할 DB 스크립트가 있다면 db.type 값을 포함하고 있는 스크립트
										({plugin name}-insert-data-{db.type}.sql, {plugin name}-delete-data-{db.type}.sql) 파일이 실행되도록 하는데 사용된다.
	               						(예를 들어, db.type이 oracle일 때 security plugin을 설치하면 security-insert-data-oracle.sql 파일이 실행됨.)  								
									</entry>
								</row>
								<row>
									<entry>db.name</entry>
									<entry>
										해당 DB의 이름을 지정한다.
									</entry>
								</row>	
								<row>
									<entry>db.schema</entry>
									<entry>
										해당 DB의 Schema를 정의한다.
									</entry>
								</row>		
								<row>
									<entry>db.server</entry>
									<entry>
										해당 DB를 가진 서버의 IP를 정의한다.
									</entry>
								</row>	
								<row>
									<entry>db.port</entry>
									<entry>
										해당 DB를 위한 서버의 port를 정의한다.
									</entry>
								</row>																				
								<row>
									<entry>db.driver</entry>
									<entry>해당 DB에 대한 Driver Class명을 정의한다.</entry>
								</row>	
								<row>
									<entry>db.url</entry>
									<entry>해당 DB에 대한 URL을 정의한다.</entry>
								</row>
								<row>
									<entry>db.userId</entry>
									<entry>해당 DB에 접근하기 위한 User Id를 정의한다.</entry>
								</row>
								<row>
									<entry>db.password</entry>
									<entry>해당 DB에 접근하기 위한 Password를 정의한다.</entry>
								</row>
								<row>
									<entry>db.lib</entry>
									<entry>
										해당 DB에 접근하여 Connection을 얻어오기 위해 참조해야 하는 DB Library 위치를 정의한다. 
										(절대 경로 또는 샘플 프로젝트 위치 기준으로 상대 경로로 정의할 수 있다. 상대 경로 정의시 ./src/main/..와 같은 형태나 src/main/..와 같은 
										형태로 정의하도록 한다. /src/main/..와 같은 형태로 정의하는 경우 절대 경로로 인식하여 해당 파일을 찾지 못할 수 있다.)
										샘플 어플리케이션 실행시 DB Library를 인식할 수 있도록 하기 위해서 [샘플 프로젝트 설치 폴더]/src/main/webapp/WEB-INF/lib 폴더
										내에 저장할 것을 권장한다.
									</entry>
								</row>	
								<row>
									<entry>db.dialect</entry>
									<entry>해당 DB의 Hibernate Dialect 클래스를 정의한다.</entry>
								</row>	
								<row>
									<entry>db.groupId</entry>
									<entry>Maven Repository 내에 존재하는 해당 DB의 Library에 대한 groupId를 정의한다. (Maven을 활용하는 경우에 한정됨.)</entry>							
								</row>		
								<row>
									<entry>db.artifactId</entry>
									<entry>Maven Repository 내에 존재하는 해당 DB의 Library에 대한 artifactId를 정의한다. (Maven을 활용하는 경우에 한정됨.)</entry>							
								</row>	
								<row>
									<entry>db.version</entry>
									<entry>Maven Repository 내에 존재하는 해당 DB의 Library에 대한 version을 정의한다. (Maven을 활용하는 경우에 한정됨.)</entry>							
								</row>	
								<row>
									<entry>db.schema.use</entry>
									<entry>해당 DB가 Sybase DB일 경우, 지정해야 하는 속성으로 User 정보 셋팅시 DB Schema 정보를 사용할지 여부를 정의한다.
										단, Sybase 버전에 따라 속성값은 변경될 수 있음에 유의하도록 한다. (default=false)
									</entry>								
								</row>																																																																						
							</tbody>
						</tgroup>
					</informaltable>
				</para>				
			</listitem>
			<listitem>
				<para>
					Command 창을 띄운 후, 샘플 프로젝트가 있는 위치로 이동하여 다음과 같이 Maven 명령어를 입력함으로써 앞서 수정한 DB 정보에 맞게 현재까지 설치된 Plugin의
					모든 DB 관련 리소스들을 수정할 수 있다.
				</para>
				<programlisting language="java"><![CDATA[mvn anyframe:change-db]]></programlisting>
			</listitem>
			<listitem>
				<para>
					DB 관련 설정 정보가 정상적으로 변경되었는지 확인한다.
				</para>
				<para>
					프로젝트 코드 내 DataSource Service 설정 정보 및 Hibernate, Query Service 관련 정보들이 변경되었는지 확인한다. 
				</para>
			</listitem>
		</orderedlist>		
		
	</section>
	
	<section id="commands_maven_source_domain">
		<title>Domain 소스 코드 생성</title>
		<para>
			Anyframe 4.6.0 이후부터 새롭게 추가된 기능으로 이미 만들어져 제공된 Plugin들을 설치하는 작업 외에 
			새로 개발할 어플리케이션을 위해 구성된 DB 테이블을 기반으로 Domain 클래스를 생성할 수 있다.
			(이어질 설명에서는 기본적인 Command 사용법만을 언급하고 있으므로 Anyframe Commmand Option에 대한 자세한 내용은 <link linkend="commands_maven_commands_list">Command 목록</link>내에 제시된 해당 Command의
			설명을 참고하도록 한다.)
		</para>
		<para>
			Anyframe에서 기본적으로 제공하는 SampleDB 내에 포함된 모든 테이블을 대상으로 Domain 클래스를 생성해 보도록 하자.
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					Command 창을 띄운 후, 샘플 프로젝트가 있는 위치로 이동하여 다음과 같이 Maven 명령어를 입력함으로써 특정 테이블과 매핑되는 Domain
					클래스를 생성시킬 수 있다.
				</para>
				<programlisting language="java"><![CDATA[mvn anyframe:create-model]]></programlisting>
				<itemizedlist>
					<listitem>
						<para>ex) mvn anyframe:create-model -Dtable="*" -Dpackage=com.sds.emp.domain</para>
						<para>
							위 예제는 모든 테이블에 대해 Domain Class를 생성하되, 프로젝트 생성 시 지정한 대표 패키지(ex. com.sds.emp) 하위의 
							domain 패키지 내에 생성하는 command 이다.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					해당 DB에 속한 전체 테이블이 아닌 특정 테이블에 대해서만 Domain 클래스를 생성하고자 할 경우에는 다음과 같이 -Dtable={table명}을 
					직접 입력해주면 된다. 
				</para>
				<programlisting language="java"><![CDATA[mvn anyframe:create-model -Dtable=BOARD_MASTER,BOARD]]></programlisting>
				<para>
					또한 해당 테이블에 대해 이미 생성된 Domain 클래스가 있을 경우에는 다음과 같이 overwrite할지 묻게 될 것이다. overwrite하지 않고 싶으면
					"N"를 입력하여 Domain 클래스 생성 작업을 종료할 수 있다.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="../image/commands/maven/create_model_overwrite.jpg"
								align="center" />
						</imageobject>					
					</mediaobject>
				</para>					
			</listitem>
			<listitem>
				<para>Domain 클래스가 정상적으로 생성되었는지 확인한다.</para>
				<para>
					Domain 클래스 생성시 지정한  패키지 내에, camelcase 적용된 테이블 이름의 도메인 클래스가 존재하면 성공적으로 생성된 것이다. 
					다음은 BOARD 테이블과 매핑되는 Board.java 코드의 일부분이다.
				</para>
				<programlisting language="java">@Entity
@Table(name = "BOARD")
<emphasis role="bold">//@Table의 schema 속성은 default 템플릿을 활용하여 
//sybase DB와 hibernate dao framework을 사용할때 정의됨
//@Table의 catalog 속성은 catalog 정보가 존재할 경우 정의됨</emphasis>
public class Board implements Serializable {
    private BoardId id = new BoardId();
    private BoardMaster boardMaster;
    private String boardName;
    중략...
    public BoardId getId() {
        return this.id;
    }
    public void setId(BoardId id) {
        this.id = id;
    }
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "BOARD_MASTER_ID", nullable = false, 
                insertable = false, updatable = false)
    public BoardMaster getBoardMaster() {
        return this.boardMaster;
    }
    public void setBoardMaster(BoardMaster boardMaster) {
        this.boardMaster = boardMaster;
    }
    @Column(name = "BOARD_NAME", nullable = false, length = 150)
    public String getBoardName() {
        return this.boardName;
    }
    public void setBoardName(String boardName) {
        this.boardName = boardName;
    }	  
}</programlisting>					
			</listitem>
			<listitem>
				<para>자동생성되는 Domain 클래스 소스 코드에 대해서 각 개발자 혹은 프로젝트 상황에 맞게 템플릿 파일을 수정하여 사용할 수 있다. </para>
				<para>
					템플릿 확장에 관한 상세한 내용은 <link linkend="commands_maven_source_crud_template_customizing">Template Customizing</link>를 참고하도록 한다. Maven의 경우, 템플릿 파일들은 '{user.home}/.anyframe/templates' 디렉토리에 존재하고 
					이중 Domain 클래스에 대한 템플릿 파일은 templates 하위의 [템플릿명]/source/model 폴더 내에 있으므로 수정 시 활용하도록 한다. (Pojo.ftl 등)
				</para>
			</listitem>
		</orderedlist>
	</section>
		
	<section id="commands_maven_source_crud">
		<title>CRUD 소스 코드 생성</title>
		<para>
			DB 테이블을 기반으로 생성한 Domain 클래스를 통해 기본 CRUD 기능을 수행하는 소스 코드들을 생성할 수 있다.
			(이어질 설명에서는 기본적인 Command 사용법만을 언급하고 있으므로 Anyframe Commmand Option에 대한 자세한 내용은 <link linkend="commands_maven_commands_list">Command 목록</link>내에 제시된 해당 Command의
			설명을 참고하도록 한다.)
		</para>
		<para>
			앞서 생성한 Domain 클래스 중 하나를 선택하여 CRUD 소스 코드를 생성해 보도록 하자.
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					Command 창을 띄운 후, 샘플 프로젝트가 있는 위치로 이동하여 다음과 같이 Maven 명령어를 입력함으로써 특정 Domain을 중심으로 기본적인 
					CRUD 기능을 수행하는 소스 코드들을 생성할 수 있다. 또한 package 옵션을 이용하면 생성될 CRUD 관련 코드들의 package를 지정할 수 있다.
				</para>
				<programlisting language="java"><![CDATA[mvn anyframe:create-crud -Dentity=... -DtemplateType=...]]></programlisting>
				<para>
					예를 들어, 'mvn anyframe:create-crud -Dentity=Board -DtemplateType=query'라고 실행하면 Board 객체를 QueryServicce를 이용하여 CRUD 할 수 있는 소스코드를 생성하게 된다. 
				</para>	
				<para>
					해당 Domain 클래스에 대해 이미 생성된 CRUD 소스 코드가 있을 경우에는 다음과 같이 overwrite할지 묻게 될 것이다. overwrite하지 않고 싶으면
					"N"를 입력하여 CRUD 소스 코드 생성 작업을 종료할 수 있다.
				</para>
				<para>	
					<mediaobject>
						<imageobject>
							<imagedata fileref="../image/commands/maven/create_crud_overwrite.jpg"
								align="center" />
						</imageobject>					
					</mediaobject>
				</para>
				<para>
					또한, 비즈니스 레이어 코드만 생성하고자 하는 경우 아래와 같이 -scope 옵션을 추가하여 명령어를 실행할 수도 있다.
				</para>
				<programlisting language="java"><![CDATA[mvn anyframe:create-crud -Dentity=Board -DtemplateType=query -Dscope=service]]></programlisting>
				<para>
					scope 옵션에 대한 상세한 내용은 <link linkend="commands_maven_commands_list">Command 목록</link>을 참조하길 바란다.
				</para>
			</listitem>			
			<listitem>
				<para>
					비즈니스 레이어 코드(서비스인터페이스, 서비스구현클래스, DAO구현클래스 등)가 정상적으로 생성되었는지 확인한다. 
				</para>
				<para>다음은 도메인 클래스 Board.java를 기반으로 생성된 자바 코드와 속성파일 등의 일부분이다.</para>	
				<itemizedlist>
					<listitem>
						<para>서비스 인터페이스 (src/main/java/{대표패키지}/{package}/service/{Entity 클래스명}Service.java)</para>
						<programlisting language="java">public interface BoardService{
    void create(Board board) throws Exception;
    void remove(BoardId id) throws Exception;				
    ...        
}</programlisting>
					</listitem>
					<listitem>
						<para>서비스 구현클래스 (src/main/java/{대표패키지}/{package}/service/impl/{Entity 클래스명}ServiceImpl.java)</para>
						<programlisting language="java">@Service("boardService")
@Transactional(rollbackFor = {Exception.class}, propagation = Propagation.REQUIRED)
public class BoardServiceImpl implements BoardService {
	    
    @Inject
    @Named("boardDao")
    private BoardDao boardDao;
	    
    public void create(Board board) throws Exception {
        this.boardDao.create(board);
    }
        
    public void remove(BoardId id) throws Exception {
        this.boardDao.remove(id);
    }
    ...        
}</programlisting>
					</listitem>						
					<listitem>
						<para>DAO 클래스 (src/main/java/{대표패키지}/{package}/service/impl/{Entity 클래스명}Dao.java)</para>
					<programlisting language="java">@Repository("boardDao")
public class BoardDao extends JdbcDaoSupport {

    @Value("#{contextProperties['pageSize'] ?: 10}")
    int pageSize;
    
    @Value("#{contextProperties['pageUnit'] ?: 10}")
    int pageUnit;
    
    @Inject
    public void setJdbcDaoDataSource(DataSource dataSource) throws Exception {
        super.setDataSource(dataSource);
    }
    
    public void create(Board board) throws Exception {
        String sql = "INSERT INTO BOARD (BOARD_ID, BOARD_DESC, BOARD_MASTER_ID, BOARD_NAME, BOARD_ORDER, BOARD_TOPICS, REG_DATE) "
                              + "VALUES (?, ?, ?, ?, ?, ?, ?)";
        this.getJdbcTemplate().update(
                                    sql,
                                    new Object[] {board.getId().getBoardId(), board.getBoardDesc(), board.getId().getBoardMasterId(), 
                                    board.getBoardName(), board.getBoardOrder(), board.getBoardTopics(), board.getRegDate()});
    }
        
    public void remove(BoardId id) throws Exception {
        String sql = "DELETE FROM BOARD WHERE BOARD_ID = ? AND BOARD_MASTER_ID = ?";
        this.getJdbcTemplate().update(sql, new Object[] {id.getBoardId(), id.getBoardMasterId()});
    }
    ...
}</programlisting>
					</listitem>
					<listitem>
						<para>MessageSoruce (src/main/resources/message/message-generation.properties)</para>
						<programlisting># -- Board-START
board.id.boardId=Board Id		
board.id.boardMasterId=Board Master Id		
board.boardDesc=Board Desc
board.boardName=Board Name
board.boardOrder=Board Order
board.boardTopics=Board Topics
board.regDate=Reg Date

# -- success messages -- 
success.board.create=Board has been added successfully.
success.board.update=Board has been updated successfully.
success.board.delete=Board has been deleted successfully.

# -- error messages --
error.boardserviceimpl.create=Board data not created
error.boardserviceimpl.create.solution=Enter correct data for mandatory field 
or enter data according to formats means date format as yyyy-mm-dd
error.boardserviceimpl.create.reason=Entered incorrect data for Board
...</programlisting>
					</listitem>
					<listitem>
						<para>통합 테스트케이스 (src/test/java/{대표패키지}/{package}/service/{Entity 클래스명}ServiceTest.java)</para>
						<programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "file:./src/main/resources/spring/context-*.xml" })
public class BoardServiceTest{

    @Inject
    @Named("boardService")
    private BoardService boardService;

    @Test
    @Rollback(value=true)    
    public void manageBoard() throws Exception {
        //1. create a new board
        Board board = getBoard();            
        
        if(boardService.get(board.getId()) != null)
            boardService.remove(board.getId());
        
        boardService.create(board);
        ...
    }
    ...
}</programlisting>
					</listitem>						
				</itemizedlist>	
				<note>
					<title>참고</title>
					<para>
						META-INF/project.mf 에서 project.daoframework 값을 변경하지 않았을 경우 기본 DAO Framework은 springjdbc로 설정되어 
						있다. (위에서 보여준 DAO 구현 클래스는 springjdbc로 설정되어 있는 경우의 모습이다.) 설정할 수 있는 DAO Framework로는 springjdbc, query, hibernate, ibatis2, mybatis 가 있다.
					</para>
					<para>
						META-INF/project.mf 에서 project.daoframework 값을 "hibernate"으로 설정하여 DAO Framework으로 Hibernate을 채택한 경우,
						생성된 CRUD 소스 코드는 Hibernate을 사용하는 형태를 갖추게 될 것이다. 단, Anyframe Hibernate Plugin이 설치되어야만 생성된 코드가 정상 동작할 수 있다.
					</para>
					<para>
						마찬가지로 Anyframe IDE를 통해서 생성할 소스코드의 Template Type을 디폴트로 지정된 값 이외의 값으로 설정하고 싶은 경우에도  
						이와 관련된 Anyframe Plugin이 설치되어 있어야 생성된 프로젝트가 정상적으로 동작할 수 있다.
					</para>
					<para>
						예를 들어, Template type을 'miplatform'으로 선택하여 소스코드를 생성하고자 하는 경우, 프로젝트 설정 파일(project.mf)의 project.template의 값을 miplatform으로 변경하는 것 뿐만 아니라
						Anyframe의 miplatform Plugin을 설치하여야 한다.
					</para>
				</note>
			</listitem>
			<listitem>
				<para>프리젠테이션 레이어 코드 (비즈니스 서비스와 통신을 하기 위한 컨트롤러 클래스, JSP 등)가 정상적으로 생성되었는지 확인한다.</para>
				<para>다음은 도메인 클래스 Board.java를 기반으로 생성된 컨트롤러, JSP 등의 일부분이다.</para>	
				<itemizedlist>
					<listitem>
						<para>컨트롤러 (src/main/java/{대표패키지}/{package}/web/{Entity 클래스명}Controller.java)</para>
						<programlisting language="java">@Controller
@RequestMapping("/board.do")
public class BoardController {

    @Inject
    @Named("boardService")
    private BoardService boardService;

    ...    

    @RequestMapping(params = "method=createView")  
    public String createView(Model model) throws Exception {
        model.addAttribute(new Board());

        return "generation/board/form";        
    }
}</programlisting>
					</listitem>
					<listitem>
						<para>JSP (src/main/webapp/WEB-INF/jsp/generation/{Entity 클래스명(소문자)}/*.jsp)</para>
						<programlisting><![CDATA[<%@ page language="java" errorPage="/sample/common/error.jsp" pageEncoding="UTF-8" contentType="text/html;charset=utf-8" %>
<%@ include file="/sample/common/top.jsp"%>
		<div class="location"><a href="<c:url value='/anyframe.jsp'/>">Home</a> &gt; <a href="<c:url value='/boardF.do?method=list'/>">Board</a></div>
    </div>
    <hr />
<script type="text/javascript" src="<c:url value='/sample/javascript/CommonScript.js'/>"></script>    
<script type="text/javascript">
	function fncCreateBoardView() {
		document.location.href="<c:url value='/board.do?method=createView'/>";
	}	
...]]></programlisting>
					</listitem>
					<listitem>
						<para>단위 테스트케이스 (src/test/java/{대표패키지}/{package}/web/{Entity 클래스명}ControllerTest.java)</para>
						<programlisting language="java">@RunWith(JMock.class)
public class BoardControllerTest {

    private BoardController controller;
    private String SUCCESS_CREATEVIEW = "generation/board/form";
    private String SUCCESS_CREATE = "redirect:/board.do?method=list";
    private String SUCCESS_GET = "generation/board/form";
    private String SUCCESS_UPDATE = "redirect:/board.do?method=list";
    private String SUCCESS_LIST = "generation/board/list";
    private String SUCCESS_REMOVE = "redirect:/board.do?method=list";
    private Mockery context = new JUnit4Mockery();
    private BoardService mockService = null;
	
    @Before   
    public void setUp() throws Exception {
        System.setProperty("log4j.configuration", "log4j-test.xml");

        this.mockService = context.mock(BoardService.class);                
        this.controller = new BoardController();
        this.controller.setBoardService(this.mockService);       
    }
    
    public void setBoardController(BoardController controller) {
        this.controller = controller;
    }
        
    @Test
    public void testCreateView() throws Exception{
        String viewName = this.controller.createView(new ExtendedModelMap());
        
        assertEquals("returned correct view name", SUCCESS_CREATEVIEW, viewName);
   }
...</programlisting>
					</listitem>
				</itemizedlist>
			</listitem>
			<note>
				<title>CRUD 소스 코드가 정상적으로 자동 생성되지 않는 경우</title>
				<para>
					CRUD 소스 코드가 정상적으로 생성되지 않는 경우, {user.home}/.anyframe/templates에 존재하는 
					소스 코드 템플릿 파일에 문제가 있을 수도 있으므로 이 디렉토리를 삭제한 후에 다시 anyframe:create-crud command를 실행시켜 보기를 권장한다.
				</para>
			</note>
			<listitem>
				<para>
					CRUD 소스 코드 생성 후에는 <link linkend="commands_maven_run">어플리케이션 실행</link>을 참조하여 정상 동작 여부를 확인하도록 한다. 
				</para>
			</listitem>				
		</orderedlist>
		<warning>
			<title>주의 사항</title>
			<para>
			anyframe-service-archetype으로 생성된 <emphasis role="bold">서비스 타입의 프로젝트</emphasis>일 경우, 
			hibernate나 miplatform plugin 설치 시에 관련 spring 설정 파일(context-*.xml)이 설치되지 않는다. 
			따라서, dao framework을 hibernate으로 설정하거나, 소스 코드 template type을 miplatform으로 선택하여
			소스코드를 생성한 경우, 관련 속성 파일이 존재하지 않아서 자동 생성된 테스트 케이스는 수행시 오류가 발생하게 된다.
			"Fail to ApplicationContext..." 에러가 발생하면 hibernate나 miplatform plugin의 spring 설정 파일을 추가해 주도록 한다.
			</para>
		</warning>
		
		<section id="commands_maven_source_crud_note">
			<title>CRUD 소스코드 생성 후 런타임 시 발생하는 에러 해결 Tip</title>
			<para>CRUD 소스코드는 정상적으로 생성되었지만 런타임시에 발생할 수 있는 문제에 대해서 해결방법을 알아본다.</para>
			<itemizedlist>
			  <listitem><para>time 타입 데이터가 있는 경우</para>
			  	<itemizedlist>
				  <listitem><para>현상) 입력/수정 화면에서 create/update 할 때 Fali to convert 오류 발생</para></listitem>
				  <listitem><para>원인)Time 타입 데이터(시:분:초)가 request parameter에 String으로 담겨지기 때문에, Domain 클래스와 Binding 될때 데이터 바인딩이 되지 않음</para></listitem>
				  <listitem><para>해결책)Domain 클래스에서 time 타입 컬럼을 string 타입으로 선언하여 사용</para></listitem>
				</itemizedlist>
			  </listitem>
			</itemizedlist>
		</section>
		
		<section id="commands_maven_source_crud_template_customizing">
			<title>Template Customizing</title>
		
			<para>
				Maven의 경우, 템플릿 파일들은 '{user.home}/.anyframe/templates' 디렉토리에 존재하고 
					 CRUD 소스 코드 생성에 관련된 템플릿 파일은 templates 하위의 [템플릿명]/source 폴더 내에 있으므로 수정 시 활용하도록 한다.
					
				templates 폴더를 살펴보면 아래와 같이 default,
				miplatform, xplatform 폴더가 존재하고 그 하위로 각각 source 폴더가 존재하고 있음을 확인할 수 있다.
			</para>
			<para>
				소스 코드 템플릿을 확장한다는 것은 Anyframe IDE를 통해 생성되는 도메인 클래스, CRUD 소스 코드에 대해서 각
				개발자 혹은 프로젝트 상황에 맞게 수정하여 사용할 수 있다는 것으로 여기서는
				FreeMarker Template을 수정함으로써
				소스 코드 템플릿을 확장할 수 있다.
				FreeMarker에 대한 자세한
				내용은
				<ulink url="http://freemarker.org/">
					FreeMarker 사이트
							</ulink>
				를 참조하도록 한다.
			</para>
			<para>
				프로젝트의 타입(Web/Service) 정보와는 무관하게 소스 코드 템플릿 확장 방법은 동일하다. 단 템플릿 파일 목록 작성 시 타입 정보를 다르게 구분하여 설정해주면 된다. 
			</para>
		
			<section id="templatesextensions_sourcecode_sec001">
				<title>템플릿 폴더 생성</title>
				<para>
					FreeMarker Template(*.ftl) 파일들을 수정하여 자동 생성되는 소스 코드에 대한 템플릿을
					확장해보도록 한다.
					default 템플릿을 확장하여 ext 템플릿을 구성해보자.[Template Home]/default 폴더 전체를 복사한 후 
					이름을 ext로 변경시켜서 [Template Home]/ext 폴더를 만들고 [Template Home]/ext/source 폴더 하위의 template.config 파일이 있는지 확인한다.
				</para>
			</section>
			<section id="templatesextensions_sourcecode_sec002">
				<title>템플릿 파일 목록 작성(template.config)</title>
				<para>
					template.config 파일을 열고 소스 코드 생성에 필요한 템플릿 파일 목록을 작성한다. template.config 파일 내 작성되는 정보는 소스 코드 생성 시 필요한 코드 템플릿 목록 정보로
					default 템플릿을 통해 제공되는 템플릿 정보는 다음 표와 같다.
					타입 별 템플릿 파일에 대한 설명으로, template.config 파일 내 템플릿 목록으로 작성되어야 CRUD
					소스 코드 생성 시
					결과 코드로 생성된다. service 타입 템플릿은 Business Layer 코드 생성 시 사용되는
					템플릿이고, web 타입 템플릿은 Presentation Layer 코드 생성 시 사용된다.
				</para>
				<para>
					template.config 파일 내 템플릿 정보 등록 시 아래와 같은 항목 내용을 작성하도록 한다.
				</para>
				<itemizedlist>
					<listitem>
						<para>type: service, web 타입</para>
					</listitem>
					<listitem>
						<para>ftl: freemarker template 파일</para>
					</listitem>
					<listitem>
						<para>src: 생성될 소스 코드 파일 명</para>
						<itemizedlist>
							<listitem><para>{basepkg-name} : 대표패키지</para></listitem>
							<listitem><para>{class-name} : 엔티티 클래스 명</para></listitem>
						</itemizedlist>		
					</listitem>
					<listitem>
						<para>mergeSrc: 생성된 소스 코드를 반영할 파일명</para>
					</listitem>
					<listitem>
						<para>mergeKey: 생성된 소스 코드를 반영할 위치정보 key </para>
					</listitem>
					<listitem>
						<para>share: sample db data 공유 여부를 true, false로 설정</para>
					</listitem>
					<listitem>
						<para>dao: springjdbc, query, hibernate, ibatis2, mybatis 중 dao framework 설정</para>
					</listitem>
					<listitem>
						<para>description: 템플릿 설명</para>
					</listitem>
				</itemizedlist>
				<informaltable>
					<caption>Service Type template configuration 일부 예시 (소스 코드)</caption>
		
					<tgroup cols="8">
						<colspec colnum="1" colname="col1" colwidth="1*"/>
						<colspec colnum="2" colname="col2" colwidth="1*"/>
						<colspec colnum="3" colname="col3" colwidth="2*"/>
						<colspec colnum="4" colname="col4" colwidth="2*"/>
						<colspec colnum="5" colname="col5" colwidth="2*"/>
						<colspec colnum="6" colname="col6" colwidth="1*"/>
						<colspec colnum="7" colname="col7" colwidth="1*"/>
						<colspec colnum="8" colname="col8" colwidth="2*"/>
						<thead>
							<row>
								<entry align="center">type</entry>
								<entry align="center">ftl</entry>
								<entry align="center">src</entry>
								<entry align="center">mergeSrc</entry>
								<entry align="center">mergeKey</entry>
								<entry align="center">share</entry>
								<entry align="center">dao</entry>
								<entry align="center">description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>service</entry>
								<entry>service/service-test.ftl</entry>
								<entry>src/test/java/{basepkg-name}/service/{class-name}ServiceTest.java</entry>
								<entry></entry>
								<entry></entry>
								<entry>true</entry>
								<entry>N/A</entry>
								<entry>service 에 대한 통합 test case</entry>
							</row>
							<row>
								<entry>service</entry>
								<entry>service/service.ftl</entry>
								<entry>src/main/java/{basepkg-name}/service/{class-name}Service.java</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>N/A</entry>
								<entry>service interface class</entry>
							</row>
							<row>
								<entry>service</entry>
								<entry>service/service-impl.ftl</entry>
								<entry>src/main/java/{basepkg-name}/service/impl/{class-name}ServiceImpl.java</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>N/A</entry>
								<entry>service implementation class</entry>
							</row>
							<row>
								<entry>service</entry>
								<entry>dao/springjdbc/dao.ftl</entry>
								<entry>src/main/java/{basepkg-name}/service/impl/{class-name}Dao.java</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>springjdbc</entry>
								<entry>spring jdbc dao implementation class</entry>
							</row>					
							<row>
								<entry>service</entry>
								<entry>dao/hibernate/dao.ftl</entry>
								<entry>src/main/java/{basepkg-name}/service/impl/{class-name}Dao.java</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>hibernate</entry>
								<entry>hibernate dao implementation class</entry>
							</row>
							<row>
								<entry>service</entry>
								<entry>dao/query/dao.ftl</entry>
								<entry>src/main/java/{basepkg-name}/service/impl/{class-name}Dao.java</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>query</entry>
								<entry>query dao implementation class</entry>
							</row>
							<row>
								<entry>service</entry>
								<entry>dao/ibatis2/dao.ftl</entry>
								<entry>src/main/java/{basepkg-name}/service/impl/{class-name}Dao.java</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>ibatis2</entry>
								<entry>ibatis2 dao implementation class</entry>
							</row>
							<row>
								<entry>service</entry>
								<entry>dao/mybatis/dao.ftl</entry>
								<entry>src/main/java/{basepkg-name}/service/impl/{class-name}Dao.java</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>mybatis</entry>
								<entry>mybatis dao implementation class</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>
				
				<informaltable>
					<caption>Service Type template configuration 일부 예시 (설정 파일)</caption>
		
					<tgroup cols="8">
						<colspec colnum="1" colname="col1" colwidth="1*"/>
						<colspec colnum="2" colname="col2" colwidth="1*"/>
						<colspec colnum="3" colname="col3" colwidth="2*"/>
						<colspec colnum="4" colname="col4" colwidth="2*"/>
						<colspec colnum="5" colname="col5" colwidth="2*"/>
						<colspec colnum="6" colname="col6" colwidth="1*"/>
						<colspec colnum="7" colname="col7" colwidth="1*"/>
						<colspec colnum="8" colname="col8" colwidth="2*"/>
						<thead>
							<row>
								<entry align="center">type</entry>
								<entry align="center">ftl</entry>
								<entry align="center">src</entry>
								<entry align="center">mergeSrc</entry>
								<entry align="center">mergeKey</entry>
								<entry align="center">share</entry>
								<entry align="center">dao</entry>
								<entry align="center">description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>service</entry>
								<entry>dao/sample-data.ftl</entry>
								<entry>merge/{class-name}-sample-data.xml</entry>
								<entry>/src/test/resources/sample-data.xml</entry>
								<entry>&lt;!--{class-name}-START--&gt;</entry>
								<entry>false</entry>
								<entry>N/A</entry>
								<entry>test sample db data</entry>
							</row>
							<row>
								<entry>service</entry>
								<entry>dao/hibernate/dynamic-hibernate.ftl</entry>
								<entry>src/main/resources/hibernate/dynamic-hibernate-{class-name}.xml
								</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>hibernate</entry>
								<entry>hibernate dynamic hql mapping xml file</entry>
							</row>
							<row>
								<entry>service</entry>
								<entry>dao/query/mapping-query.ftl</entry>
								<entry>src/main/resources/sql/query/mapping-query-{class-name-lower}.xml
								</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>query</entry>
								<entry>query service mapping xml file</entry>
							</row>					
							<row>
								<entry>service</entry>
								<entry>web/ApplicationResources.ftl</entry>
								<entry>merge/{class-name}-ApplicationResources.properties</entry>
								<entry>/src/main/resources/message/message-generation.properties</entry>
								<entry># -- {class-name}-START</entry>
								<entry>false</entry>
								<entry>N/A</entry>
								<entry>message source properties 파일</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>
		
				<informaltable>
					<caption>Web Type template configuration 일부 예시</caption>
		
					<tgroup cols="8">
						<colspec colnum="1" colname="col1" colwidth="1*"/>
						<colspec colnum="2" colname="col2" colwidth="1*"/>
						<colspec colnum="3" colname="col3" colwidth="2*"/>
						<colspec colnum="4" colname="col4" colwidth="2*"/>
						<colspec colnum="5" colname="col5" colwidth="2*"/>
						<colspec colnum="6" colname="col6" colwidth="1*"/>
						<colspec colnum="7" colname="col7" colwidth="1*"/>
						<colspec colnum="8" colname="col8" colwidth="2*"/>
						<thead>
							<row>
								<entry align="center">type</entry>
								<entry align="center">ftl</entry>
								<entry align="center">src</entry>
								<entry align="center">mergeSrc</entry>
								<entry align="center">mergeKey</entry>
								<entry align="center">share</entry>
								<entry align="center">dao</entry>
								<entry align="center">description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>web</entry>
								<entry>web/spring/controller-test.ftl</entry>
								<entry>src/test/java/{basepkg-name}/web/{class-name}ControllerTest.java</entry>
								<entry></entry>
								<entry></entry>
								<entry>false</entry>
								<entry>N/A</entry>
								<entry>spring mvc controller class test case</entry>
							</row>
							<row>
								<entry>
									web
										</entry>
								<entry>
									web/spring/controller.ftl											
										</entry>
								<entry>src/main/java/{basepkg-name}/web/{class-name}
									Controller.java
										</entry>
										<entry></entry>
										<entry></entry>
								<entry>false</entry>
								<entry>N/A</entry>
								<entry>spring mvc controller class</entry>
							</row>
							<row>
								<entry>
									web
										</entry>
								<entry>
		
									web/spring/list-view.ftl
													
										</entry>
								<entry>src/main/webapp/WEB-INF/jsp/generation/{class-name-lower}/list.jsp
								</entry>
								<entry></entry>
										<entry></entry>
								<entry>false</entry>
								<entry>N/A</entry>
								<entry>list view jsp page</entry>
							</row>
							<row>
								<entry>
									web
										</entry>
								<entry>
		
									web/spring/form-view.ftl
													
										</entry>
								<entry>src/main/webapp/WEB-INF/jsp/generation/{class-name-lower}/form.jsp
								</entry>
								<entry></entry>
										<entry></entry>
								<entry>false</entry>
								<entry>N/A</entry>
								<entry>detail view jsp page</entry>
							</row>
							<row>
								<entry>
									web
										</entry>
								<entry>
		
									web/menu.ftl
													
										</entry>
								<entry>merge/{class-name}-menu.jsp
										</entry>
										<entry>/src/main/webapp/sample/layouts/gen/left-gen.jsp</entry>
										<entry>&lt;!--{class-name}-START--&gt;</entry>
								<entry>false</entry>
								<entry>N/A</entry>
								<entry>menu jsp page</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>
		
			</section>


			<section id="templatesextensions_sourcecode_sec003">
				<title>템플릿 파일(*.ftl) 수정</title>
				<para>
					[Template Home]/ext/source 폴더 하위에서 확장하고 싶은 ftl 파일들을 선정하여
					수정하도록 한다.
						</para>
				<para>
					source 폴더 하위에 있는 ftl 파일들은 원하는 폴더로 묶어서 관리할 수 있다. 현재에는 다음 표와 같이
					4개의 폴더(model, service, dao, web)로 구분되어 있다. 자유롭게 변경할 수 있다. 단, 폴더명과
					ftl
					파일 명 변경 시 위에서 설명한 template.config 파일 내 ftl 항목 내용도 반드시 변경시켜줘야
					한다.
				</para>
				<informaltable>
					<caption>template folder</caption>
					<tgroup cols="2">
						<colspec colnum="1" colname="col1" colwidth="1*"/>
						<colspec colnum="2" colname="col2" colwidth="5*"/>
						<thead>
							<row>
								<entry align="center">folder name</entry>
								<entry align="center">description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>
									model
										</entry>
								<entry>
									도메인 클래스 생성 시 사용되는 ftl들 존재
										</entry>
							</row>
							<row>
								<entry>
									service
										</entry>
								<entry>
									service 클래스/테스트 케이스 및 Spring bean 설정 파일 ftl들 존재
										</entry>
							</row>
							<row>
								<entry>
									dao
										</entry>
								<entry>
									샘플 데이터, hibernate/query dao 클래스 및 Spring bean 설정
									파일
									ftl들 존재
										</entry>
							</row>
							<row>
								<entry>
									web
										</entry>
								<entry>
									메뉴, message resource, spring mvc 클래스/테스트 케이스 및 Spring
									bean
									설정 파일, JSP ftl들 존재
										</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>
				<para>
					예를 들어 service 생성 시 기본 CRUD 메소드 외 다른 메소드를 추가해보자. 
						</para>
				<itemizedlist>
					<listitem>
						<para>
							[Template Home]/ext/source/service/service.ftl 파일을 열어
							다음과
							같이 getProcedureList 메소드를 추가한다.
								</para>
						<para>
							getProcedureList의 리턴 타입이 List 이므로 클래스 상단에 import 구문을 추가해줘야
							함에
							유의하도록 한다.
								</para>
						<programlisting><![CDATA[package ${package}.service;

]]><emphasis role="bold">import java.util.List;</emphasis><![CDATA[

import anyframe.common.Page;
import anyframe.common.util.SearchVO;
중략...
import ${pojo.packageName}.${pojo.shortName};


public interface ${pojo.shortName}Service{

	void create(${pojo.shortName} ${pojoNameLower}) throws Exception;     
	]]><emphasis role="bold">List getProcedureList(SearchVO searchVO) throws Exception;</emphasis><![CDATA[   
}]]></programlisting>
						<para>
							이 ftl 구문 내에서 클래스, 메소드 등의 이름을 변경하거나 내용을 수정할 수 있다. service
							interface(service.ftl) 클래스에 대한 내용 수정 시 service
							implementation(service-impl.ftl) 클래스에 대한 내용도 함께 수정해줘야 함에 유의하도록
							한다.
						</para>
					</listitem>
					<listitem>
						<para>
							[Template Home]/ext/source/service/service-impl.ftl 파일을
							열어
							다음과 같이 getProcedureList 메소드를 추가한다.
								</para>
						<para>
							getProcedureList의 리턴 타입이 List 이므로 클래스 상단에 import 구문을 추가해줘야
							함에
							유의하도록 한다.
								</para>
						<programlisting><![CDATA[<#assign pojoNameLower = pojo.shortName.substring(0,1).toLowerCase()+
	pojo.shortName.substring(1)>
package ${package}.service.impl;

]]><emphasis role="bold">import java.util.List;</emphasis><![CDATA[
import anyframe.common.Page;
import anyframe.common.util.SearchVO;
import ${package}.service.${pojo.shortName}Service;
중략...
public class ${pojo.shortName}ServiceImpl implements ${pojo.shortName}Service {
  
    @Inject
    @Named("${pojoNameLower}Dao")
    ${pojo.shortName}Dao ${pojoNameLower}Dao;

    public void create(${pojo.shortName} ${pojoNameLower}) throws Exception {
        this.${pojoNameLower}Dao.create(${pojoNameLower});
    }	       
	
    ]]><emphasis role="bold">public List getProcedureList(SearchVO searchVO) throws Exception{
    중략...
    }
	</emphasis><![CDATA[   
}]]></programlisting>
					</listitem>
				</itemizedlist>
		
			</section>
		
			<section id="templatesextensions_sourcecode_sec004">
				<title>템플릿 파일(*.ftl) 변수</title>
				<para>
					템플릿 파일(*.ftl)을 수정하기 위해서는 일반 문자열 자체를 변경하여 클래스나 메소드 명을 변경시킬 수도 있으나
					템플릿 파일 내 사용되는 변수(${변수명})를 이용하여 수정 시 좀더 다양하게 템플릿을 확장시킬 수 있다.
				</para>
				<para>다음은 템플릿 파일 내에서 자주 사용되는 변수에 대한 설명을 표로 나타낸 것이다. 
				</para>
		
				<informaltable>
					<caption>FTL 파일 내 변수 목록</caption>
		
					<tgroup cols="2">
						<thead>
							<row>
								<entry align="center">name</entry>
								<entry align="center">description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>
									pojo.shortName
								</entry>
								<entry>
									CRUD 대상이 되는 도메인 클래스명(ex. Board)
								</entry>
							</row>
							<row>
								<entry>
									pojoNameLower
								</entry>
								<entry>
									CRUD 대상이 되는 도메인 클래스명의 소문자 형태(ex. board)
								</entry>
							</row>
							<row>
								<entry>
									pojo.packageName
								</entry>
								<entry>
									CRUD 대상이 되는 도메인 클래스의 패키지명
								</entry>
							</row>
							<row>
								<entry>
									package
								</entry>
								<entry>
									소스 코드 생성 시 생성되는 클래스의 상위 패키지로 어플리케이션 대표 패키지명
								</entry>
							</row>
							<row>
								<entry>
									pojo.identifierProperty.name
								</entry>
								<entry>
									도메인 클래스의 Primary Key에 해당하는 속성명
								</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>
		
				<para>다음은
					아래와 같이 사용되는, 템플릿 파일 내에서 FreeMarker 구문을 통해 사용되는 로직에 대한 설명을 표로 나타낸 것이다. <![CDATA[<#]]>구문
					내에서 사용된다.
				</para>
				<para>
					foreach, if, lt, assign 등과 같은 FreeMarker 문법에 대한 내용은
					<ulink url="http://freemarker.org/"> FreeMarker 사이트</ulink>
					를 참조하도록 한다.
				</para>
				<programlisting><![CDATA[<#foreach field in pojo.getAllPropertiesIterator()>    
    <#foreach column in field.getColumnIterator()>
        <#if field.equals(pojo.identifierProperty) && !column.nullable 
            && !c2h.isCollection(field) && !c2h.isManyToOne(field) 
            && !c2j.isComponent(field)>
            <#lt/><form:option value="${field.name}">
            <anyframe:message code="${pojoNameLower}.${field.name}"/>
            </form:option>     
        </#if>
    </#foreach>    
    <#if field.equals(pojo.identifierProperty) && !c2h.isCollection(field) 
 	    && !c2h.isManyToOne(field) && c2j.isComponent(field)>
       <#lt/>       
       <#assign pojoIdentifier = pojo.identifierProperty.getValue() >       		
       <#foreach idfield in pojoIdentifier.getPropertyIterator()>               		 	
           <#lt/><form:option value="${field.name}.${idfield.name}">
           <anyframe:message code="${pojoNameLower}.${field.name}.${idfield.name}"/>
           </form:option>            	
       </#foreach>     		
    </#if>
</#foreach>]]></programlisting>
				<informaltable>
					<caption>FTL 파일 내 로직</caption>
		
					<tgroup cols="2">
						<thead>
							<row>
								<entry align="center">logic</entry>
								<entry align="center">description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>
									pojo.getAllPropertiesIterator()
								</entry>
								<entry>
									도메인 클래스의 모든 속성 정보를 얻어냄
								</entry>
							</row>
							<row>
								<entry>
									c2j.isComponent(pojo.identifierProperty)
								</entry>
								<entry>
									도메인 클래스의 Primary Key에 해당하는 속성이 Composite Key 클래스로 구성되었는지 여부를
									리턴함
								</entry>
							</row>
							<row>
								<entry>
									c2j.isComponent(field)
								</entry>
								<entry>
									도메인 클래스의 해당 field 속성이 primitive type이 아닌 클래스로 구성되었는지 여부를
									리턴함
								</entry>
							</row>
							<row>
								<entry>
									c2h.isCollection(field)
								</entry>
								<entry>
									도메인 클래스의 해당 field 속성이 Collection 클래스로 구성되었는지 여부를 리턴함
								</entry>
							</row>
							<row>
								<entry>
									c2h.isManyToOne(field)
								</entry>
								<entry>
									도메인 클래스의 해당 field 속성이 many to one 관계에 있는지 여부를 리턴함
								</entry>
							</row>
							<row>
								<entry>
									dbdata.getSampleDataSet(pojo)
								</entry>
								<entry>
									DB 테이블 별 컬럼값에 해당하는 샘플 데이터 값을 얻어냄
								</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>
				<note>
					<title>참고</title>
					<para>
						pojo(POJOClass), c2j(Cfg2JavaTool), c2h(Cfg2HbmTool),
					data(AnyframeDataHelper), dbdata(AnyframeDBData), util(StringUtils)
					등은 템플릿 파일 내에서 각 클래스의 메소드를 호출하여 로직을 수행할 수
					있도록 해주는 변수들로 Anyframe IDE 내에서 설정해주고 있다. 
					현재 제공되는 템플릿 파일내에서 사용되고 있는 모습을 참조하여 작성하도록 한다. 
						</para>
				</note>		
			</section>
		
			<section id="templatesextensions_sourcecode_sec005">
				<title>변경된 템플릿 파일(*.ftl) 적용</title>
				<para>
					확장된 ftl 파일을 실제 CRUD 소스 코드 생성 시 사용해본다.</para>
				<para>
					CLI 혹은 Eclipse Plugin 툴을 이용하여 CRUD 소스 코드를 생성시켜서 변경된 템플릿 파일이
					정상적으로 반영되었는지 확인한다.
					소스 코드 생성 시 에러가 발생하지 않고, 실제 어플리케이션을 구동시켜서 정상적으로 동작해야
					한다.
				</para>
			</section>
		</section>
	</section>
	
	<section id="commands_maven_inplace">
		<title>참조 라이브러리 다운로드</title>
		<para>
			Maven 기반의 프로젝트는, pom.xml에 프로젝트에서 참조하는 dependency 라이브러리를 정의하고 Maven Local Repository에 실제 라이브러리의 바이너리 파일들이 존재하는 형태로 빌드를 수행한다.
		</para>
		<para>
			그런데, 다음의 command를 실행하면 pom.xml에 정의된 dependency 라이브러리를 모두 WEB-INF/lib 폴더로 다운로드해준다.
		</para>
		<programlisting language="java"><![CDATA[mvn anyframe:inplace]]></programlisting>
	</section>
	
	<section id="commands_maven_run">
		<title>어플리케이션 실행</title>
		<para>
			특정 Plugin 설치 후 또는 코드 자동 생성 결과로 구성된 샘플 어플리케이션이 정상적으로 동작하는지 확인하기 위해서는 
			Command 창에 명령어를 직접 입력하거나 Eclipse를 이용할 수 있다.	
		</para>	
		<para>
			다음에서는 Maven Command를 직접 입력하거나 Eclipse를 이용하여 샘플 어플리케이션을 시작시키는 방법에 대해서 살펴보도록 한다.
			(본 문서에서는 Jetty, Tomcat을 기준으로 설명이 진행된다.)
		</para>		
		<para>
			샘플 어플리케이션의 정상 동작 여부를 체크하기 위해서는 먼저 사용할 DB가 시작되어 있어야 한다. Anyframe Plugin 설치로 구성되는 
			샘플 프로젝트는 기본적으로 hsqldb를 사용하도록 구성되어 있다. 따라서, [샘플 프로젝트 설치 폴더]/db/hsqldb/start.cmd (or start.sh) 파일을
			더블 클릭하여 DB를 시작시키도록 한다. 
			(hsqldb가 아닌 다른 DB를 사용하고자 하면 <link linkend="commands_maven_db">DB 변경</link> 방법을 참조하도록 한다.)
			[샘플 프로젝트 설치 폴더]/db/hsqldb 폴더 내에 제공되는 sqltool.cmd (or sqltool.sh) 파일은 hsqldb용 SQL Editor를 시작시키는 
			용도로 제공된다. DB 작업 수행 후 결과를 확인하고자 할 때 유용하게 활용할 수 있을 것이다.
		</para>					
		<section id="commands_maven_run_jetty">
			<title>Jetty 기반의 어플리케이션 실행</title>
			<orderedlist numeration="arabic" inheritnum="inherit">
				<listitem>
					<para>
						Command 창을 띄운 후, 샘플 프로젝트 설치 폴더 위치로 이동하여 다음과 같이 Maven 명령어를 입력하면 Jetty 기반에서 
						샘플 어플리케이션을 시작시킬 수 있다.
					</para>
					<programlisting language="java"><![CDATA[mvn clean jetty:run]]></programlisting>
				</listitem>	
				<listitem>
					<para>
						Jetty가 정상적으로 실행되면 Started Jetty Server라는 INFO 레벨의 로그가 콘솔창에 보일 것이다.
						(TestCase에서 JMock클래스 때문에 컴파일 오류가 발생하는 경우, Ctrl+C키를 이용해서 Jetty서버를 중지하고,
						Command창에서 'mvn anyframe:install -Dname=test'를 실행하여 test Plugin을 설치한 후 다시 Jetty를 실행시킨다.) 
					</para>		
				</listitem>
				<listitem>
					<para>
						WAS가 정상적으로 시작되었으면 웹브라우저를 열고, 주소창에 http://localhost:8080/myproject (http://localhost:8080/${샘플 프로젝트 이름})와 같이 
						입력하여 샘플 어플리케이션이 정상적으로 실행되는지 확인해본다. 다음은 core plugin만 설치된 경우 샘플 어플리케이션의 초기 화면이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_initial.jpg"
									align="center" />
							</imageobject>
						</mediaobject>
					</para>
					<para>
						Plugin이 추가 설치될 때마다 테이블의 왼쪽 Installed Plugins 칸에 추가된 Plugin에 대한 샘플을 확인할 수 있도록 링크가 추가될 것이다. 
						CRUD 소스 코드를 자동으로 생성시키면 테이블의 오른쪽 Generated CRUD Codes 칸에 만들어진 기능을 확인할 수 있는 링크가 추가된다.
					</para>
					<para>
						다음은 Core 링크를 클릭하였을 때 이동한 페이지의 모습이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_core_initial.jpg"
									align="center" />
							</imageobject>					
						</mediaobject>	
					</para>		
				</listitem>				
			</orderedlist>		
		</section>
		
		<section id="commands_maven_run_tomcat_m2eclipse">
			<title>Eclipse WTP, m2eclipse를 이용하여 Tomcat 기반의 어플리케이션 실행</title>
			<para>
				Eclipse를 이용하여 샘플 어플리케이션을 실행시키려는 경우 Eclipse에서 Maven 관련 작업을 수행할 수 있도록 지원하는 
				m2eclipse plugin을 설치할 것을 권장한다. m2eclipse plugin이 미설치된 경우, Update Site
				(m2eclipse core update site : http://m2eclipse.sonatype.org/sites/m2e, m2eclipse extras update site : http://m2eclipse.sonatype.org/sites/m2e-extras)를 통해
				설치할 수 있다. m2eclipse plugin을 설치하지 않고 Eclipse WTP만을 이용하여 샘플 어플리케이션을 실행시키고자 하는
				경우에는 본 문서의 <link linkend="commands_maven_run_tomcat_wtponly">Eclipse WTP만을 이용하여 Tomcat 기반의 어플리케이션 실행</link> 방법을 참조하도록 한다.
			</para>	
			<orderedlist numeration="arabic" inheritnum="inherit">
				<listitem>
					<para>
						설치된 샘플 프로젝트를 Eclipse 내로 import한 이후 해당 프로젝트에 대해 마우스 오른쪽 버튼을 클릭하여 컨텍스트 메뉴에서
						Maven > Enable Dependency Management를 선택함으로써 샘플 프로젝트 관련 컴파일 에러를 해결하도록 한다.
						(※ 간혹 Enable Dependency Management를 적용하고 나면 프로젝트의 Build Path에서 src/main/resources의 내용이 exclude되어 문제가 발생하는 경우가 있다.
						이 때는, 해당 프로젝트에 대해 마우스 오른쪽 버튼을 클릭하여 컨텍스트 메뉴에서 Build Path > Configure Build Path... 메뉴를 클릭하여 
						Source 탭에서 src/main/resources의 'Excluded:**'를 선택하고 오른쪽에 Remove 버튼을 클릭하여 exclude 설정을 해제한다. 
						TestCase가 정상적으로 동작할 수 있도록 src/test/resources/의 'Exclude:**' 도 같은 방법으로 조치한다.)
						(TestCase에서 JMock클래스 때문에 컴파일 오류가 발생하는 경우, Command창에서 'mvn anyframe:install -Dname=test'를 실행하여 test Plugin을 설치하고, Eclispe에서 해당 프로젝트를 Refresh한다.)
					</para>
				</listitem>
				<listitem>
					<para>
						이 후, 해당 프로젝트에 대해 마우스 오른쪽 버튼을 클릭하여 컨텍스트 메뉴에서 Run As > Run on Server를 선택함으로써 
						Tomcat Server에 어플리케이션을 배포하여 샘플 어플리케이션이 정상적으로 실행되는지 확인해본다.
					</para>
				</listitem>	
				<listitem>
					<para>
						다음은 core plugin만 설치된 경우 샘플 어플리케이션의 초기 화면이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_initial.jpg"
									align="center" />
							</imageobject>
						</mediaobject>
					</para>
					<para>
						Plugin이 추가 설치될 때마다 테이블의 왼쪽 Installed Plugins 칸에 추가된 Plugin에 대한 샘플을 확인할 수 있도록 링크가 추가될 것이다. 
						CRUD 소스 코드를 자동으로 생성시키면 테이블의 오른쪽 Generated CRUD Codes 칸에 만들어진 기능을 확인할 수 있는 링크가 추가된다.
					</para>
					<para>
						다음은 Core 링크를 클릭하였을 때 이동한 페이지의 모습이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_core_initial.jpg"
									align="center" />
							</imageobject>					
						</mediaobject>	
					</para>				
				</listitem>		
			</orderedlist>				
		</section>		
		
		<section id="commands_maven_run_tomcat_wtponly">
			<title>Eclipse WTP만을 이용하여 Tomcat 기반의 어플리케이션 실행</title>
			<para>
				Eclipse WTP만을 이용하여 Maven Project가 아닌 일반 Dynamic Web Project 형태로 샘플 어플리케이션을 실행시키기 위해서는 
				해당 어플리케이션에서 참조 라이브러리를 인식할 수 있도록 필요한 라이브러리를 [샘플 프로젝트 설치 폴더]/src/main/webapp/WEB-INF/lib 폴더에
				추가해주는 작업이 필요하다. 
			</para>
			<orderedlist numeration="arabic" inheritnum="inherit">
				<listitem>
					<para>
						Command 창을 띄운 후, 샘플 프로젝트가 있는 위치로 이동하여 다음과 같이 Maven 명령어를 입력함으로써 해당 어플리케이션이
						참조하는 라이브러리들을 [샘플 프로젝트 설치 폴더]/src/main/webapp/WEB-INF/lib 폴더에 복사할 수 있다.
					</para>
					<programlisting language="java"><![CDATA[mvn anyframe:inplace]]></programlisting>				
				</listitem>
				<listitem>
					<para>
						설치된 샘플 프로젝트를 Eclipse 내로 import한 이후 해당 프로젝트에 대해 컴파일 에러가 존재하지 않는지 체크한다. 그리고
						해당 프로젝트에 대해 마우스 오른쪽 버튼을 클릭하여 컨텍스트 메뉴에서 Run As > Run on Server를 선택함으로써 
						Tomcat Server에 어플리케이션을 배포하여 샘플 어플리케이션이 정상적으로 실행되는지 확인해본다.
					</para>				
				</listitem>
				<listitem>
					<para>
						다음은 core plugin만 설치된 경우 샘플 어플리케이션의 초기 화면이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_initial.jpg"
									align="center" />
							</imageobject>
						</mediaobject>
					</para>
					<para>
						Plugin이 추가 설치될 때마다 테이블의 왼쪽 Installed Plugins 칸에 추가된 Plugin에 대한 샘플을 확인할 수 있도록 링크가 추가될 것이다. 
						CRUD 소스 코드를 자동으로 생성시키면 테이블의 오른쪽 Generated CRUD Codes 칸에 만들어진 기능을 확인할 수 있는 링크가 추가된다.
					</para>
					<para>
						다음은 Core 링크를 클릭하였을 때 이동한 페이지의 모습이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_core_initial.jpg"
									align="center" />
							</imageobject>					
						</mediaobject>	
					</para>				
				</listitem>
			</orderedlist>
			<para>
				대상이 되는 샘플 어플리케이션을 기준으로 특정 Plugin이 설치/삭제될 때마다 참조 라이브러리에 대해 변경 사항이 발생하게 된다. 따라서 <emphasis role="bold">Eclipse WTP만 이용하여 Tomcat을 
				실행하는 경우 변경된 사항을 해당 어플리케이션에 반영하기 위해서는 매번 Maven 명령어(mvn anyframe:inplace)를 실행해주어야 한다</emphasis>는 점에 
				유의하도록 한다.
			</para>
		</section>	
		<para>
			Anyframe에서 제공하는 Plugin을 설치함으로써 생성된 샘플 프로젝트는 기본적으로 Maven을 기반으로 하고 있으므로 Maven에서 지원하는
			기능들을 동일하게 실행할 수 있다. 예를 들어 'mvn test'와 같은 명령어를 실행함으로써 샘플 프로젝트 내의 테스트 코드를 실행해 볼 수 있으며 
			'mvn package'와 같은 명령어를 실행함으로써 샘플 프로젝트를 war 형태로 패키징 가능하다. 이 외에도 다양한 Reporting Plugin들에 대한 정의를 포함하고 있으므로
			'mvn site'와 같은 명령어를 실행하는 경우 현재 개발 프로젝트에 포함된 소스 코드에 대한 분석 결과를 HTML 형태로 얻어낼 수 있게 될 것이다.
		</para>					
	</section>
	
	<section id="commands_maven_activate_plugin">
		<title>Plugin 빌드 파일 자동 생성</title>
		<para>
			앞서 설명한 command들을 활용하여 구성한 프로젝트를 Anyframe Plugin으로 등록할 수도 있다. 
			이를 위해서는 먼저 Anyframe Plugin으로 빌드하기 위한 설정파일이 필요한데,  
			activate-plugin 명령어를 이용하여 디폴트 설정 값을 가진 빌드 파일을 자동으로 생성할 수 있다.
		</para>
		<programlisting language="java"><![CDATA[mvn anyframe:activate-plugin]]></programlisting>
		<para>
			위의 명령어를 실행하면 신규 Plugin 프로젝트 루트 폴더 하위에 plugin-build.xml 파일이 생성될 것이다.
		</para>
		<para>
			Plugin 빌드 파일 생성 및 수정과 관련된 자세한 내용은 <link linkend="plugins_creatingplugin_activate_plugin">Plugin 빌드 파일 자동 생성 및 수정</link>에 설명되어 있다.
		</para>
	</section>
	
	<section id="commands_maven_package_plugin">
		<title>Plugin 패키징 수행</title>
		<para>Plugin 빌드 파일을 기반으로 package-plugin 명령어를 통해 Plugin 패키징 작업을 수행할 수 있다.</para>
		<programlisting language="java"><![CDATA[mvn anyframe:package-plugin]]></programlisting>
		<para>
			Plugin 패키징과 관련된 자세한 내용은 <link linkend="plugins_creatingplugin_activate_plugin">Plugin 빌드 파일 자동 생성 및 수정</link>을 참고하기 바란다.
		</para>
	</section>
	
	<section id="commands_maven_install_pluginfile">
		<title>Plugin 로컬 환경 배포 및 확인</title>
		<para>패키징이 완료된 Plugin 파일을 개발자 로컬 환경에 배포한 후 사용해 보려면 아래의 명령어를 실행하면 된다.</para>
		<programlisting language="java"><![CDATA[mvn anyframe:install-pluginfile]]></programlisting>
		<para>정상적으로 plugin이 로컬 환경에 배포되었다면, mvn anyframe:list 명령어를 실행시켜 새로이 등록된 plugin을 확인할 수 있을 것이다.</para>
		<para>
			Plugin 로컬 환경 배포와 관련된 자세한 내용은 <link linkend="plugins_creatingplugin_install_plugin">Plugin 로컬 환경 배포 및 확인</link>에서 확인할 수 있다.
		</para>
	</section>
	
	<section id="commands_maven_deploy_pluginfile">
		<title>Plugin 배포 및 확인</title>
		<para>
			신규 Plugin을 다른 사람들과 공유하기 위해서 deploy-pluginfile 명령어를 실행시켜서 원격 Repository에 배포할 수 있다. 
			Anyframe의 원격 Repository(http://dev.anyframejava.org/maven/repo)에 배포하는 경우가 아니라면 원하는 원격 Repository에 대한 repositoryId와 url 정보를 명령어 실행 시 옵션으로 지정해주어야 한다.
		</para>
		<programlisting language="java"><![CDATA[mvn anyframe:deploy-pluginfile]]></programlisting>
		<para>
			Plugin 배포와 관련된 자세한 내용은 <link linkend="plugins_creatingplugin_deploy_plugin">Plugin 배포 및 확인</link>을 참고한다.
		</para>
	</section>
	
</chapter>