<chapter id="commands_ant">
	<title>Ant Commands</title>
	<para>
		해당 프로젝트에서 빌드 도구로써 Ant를 채택한 경우 CLI환경에서 Anyframe 기반 개발 환경을 구성해 보도록 하자. 본 장에서는 먼저 Anyframe Ant Command에 대해 알아보고 이들 
		Command를 활용하는 방법에 대해 구체적으로 살펴볼 것이다.
		아직 Ant 환경이 제대로 갖추어지지 않은 경우에는 본 매뉴얼의 <link linkend="installation_ant_configuration">Installation - Anyframe 설치 및 환경 설정</link>을 참고하여 환경이 제대로 세팅되었는지
		확인해 보도록 한다.
	</para>
	
	<section id="commands_ant_commands">
		<title>Anyframe Ant Commands</title>
		<para>
			Ant를 기반으로 Command Line Interface에서 Anyframe에서 제공하는 Command들을 사용하여 
			Anyframe Plugin 설치, 프로젝트 생성, Domain 클래스 및 CRUD 소스 코드 생성, 빌드 및 실행 등의 작업을 수행할 수 있다.
			CLI(Command Line Interface) 기반의 command를 실행하여 작업하는 경우, 아래 매뉴얼에서 정의한 command arguments
			이외의 값 설정 혹은 반드시 필요한 arguments 생략 시 올바르게 동작하지 않을 수 있으므로 유의하도록 한다.
		</para>
		
		<section id="commands_ant_commands_list">
			<title>Command 목록</title>
			<para>
				다음은 Anyframe에서 제공하는 Command 목록으로 사용자는 Command 창에서 아래의 명령어를 입력함으로써 
				원하는 기능을 실행할 수 있게 된다. Option은 '-{option} {option값}'과 같은 형태로 명령어 뒤에 추가로 입력하면 된다.
			</para>
			<informaltable>
				<tgroup cols="2">
					<colspec colnum="1" colname="col1" colwidth="2*"/>
					<colspec colnum="2" colname="col2" colwidth="8*"/>
					<thead>
						<row>
							<entry align="center">Command</entry>
							<entry align="center">Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>anyframe create-project</entry>
							<entry>
								생성할 샘플 프로젝트의 기본 구조 생성을 위해 사용하는 명령어이다. 이후 이를 기반으로 Anyframe을 활용한 개발 환경 구성이 가능해진다.
								프로젝트 생성 command는 다음과 같은 Option을 가진다.
								<itemizedlist>
									<listitem>
										<para>
											pjtname : 프로젝트 이름을 지정할 수 있는 옵션으로 이름을 지정하지 않는 경우 'myproject'라는 디폴트 이름으로 프로젝트가 생성된다. [선택]
										</para>
									</listitem>
									<listitem>
										<para>
											pjttype : 프로젝트의 type을 지정한다. 'service'로 지정하는 경우 Java 프로젝트로 생성되고, 'web'으로 지정하는 경우 dynamic 웹 프로젝트로 생성된다. 기본값은 'web'이다. [선택]
										</para>
									</listitem>
									<listitem>
										<para>
											package : 프로젝트의 대표 패키지명을 입력한다. 이후 소스 코드 생성 시 기준이 되는 소스 패키지명이 된다.  [선택]
										</para>
									</listitem>
									<listitem>
										<para>
											apphome : 프로젝트가 생성될 위치를 설정한다. 옵션값을 설정하지 않으면 기본적으로 [Anyframe Home] 디렉토리 하위의 applications 폴더 아래에 생성된다. [선택]
										</para>
									</listitem>
									<listitem>
										<para>
											offline : 네트워크 사용이 용이하지 않은 경우에 offline 옵션을 true로 설정하면 이후 모든 Command 실행시 offline으로 동작한다. 
											단, 이 경우 Local Repository([Anyframe Home]/repo)에 필요한 라이브러리가 없을 경우에 정상적으로 동작하지 않을 수 있다. [선택, 기본값은 'false']
										</para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry>anyframe install PLUGIN_NAME</entry>
							<entry>
								생성된 샘플 프로젝트 구조를 기반으로 지정된 Plugin을 설치한다.
								PLUGIN_NAME 위치에 설치 대상 Plugin명을 지정한다.
							</entry>
						</row>
						<row>
							<entry>anyframe uninstall PLUGIN_NAME</entry>
							<entry>
								이미 설치된 Plugin을 삭제한다. PLUGIN_NAME에 삭제할 Plugin명을 지정한다. anyframe uninstall command는 다음과 같은 Option을 가진다.
								<itemizedlist>
									<listitem>
										<para>
											excludes : Plugin 제거시 제외하고 싶은 파일 명을 입력한다. 예를 들어, context-hibernate-services.xml 을 Hibernate Plugin 삭제 시 삭제되지 않게 하기 위해서는 -excludes context-hibernate-services.xml 로 옵션을 설정해준다. [선택]
										</para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry>anyframe create-model</entry>
							<entry>
								테이블 당 1개의 Domain 클래스를 생성한다. 테이블명 지정 시에는 대소문자를 구분하므로 유의하여 테이블명을 입력해야 한다. 특히, 해당하는 DB에 맞게 대소문자를 표현해야 한다. 
								hsqldb, oracle의 경우 대문자로 테이블명을 표현해야 하고, mysql의 경우 테이블명을 소문자로 표현해야 한다.
								<itemizedlist>
									<listitem>
										<para>
											table : Domain 클래스 생성을 위한 대상 테이블명을 정의한다. 여러 개의 테이블을 대상으로 할 경우에는 "," 기호를 구분자로 이용한다.
											또한 대상 테이블이 다른 테이블과 Relation 관계에 놓여 있다면 Relation 관계에 놓여 있는 테이블을 반드시 같이 정의해주도록 한다.
											[선택, 기본값은 '*'로써 모든 테이블에 대해 Domain 클래스 생성]
										</para>
									</listitem>
									<listitem>
										<para>
											package : 생성될 Domain 클래스의 패키지를 정의한다. [선택, 기본값은 해당 프로젝트의 대표 패키지 + ".domain"]
										</para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry>anyframe create-crud ENTITY</entry>
							<entry>
								하나의 Domain 클래스를 기준으로 기본 CRUD 기능을 구현한 비즈니스 레이어, 프리젠테이션 레이어에 속한 소스 코드를 생성한다. ENTITY 위치에 CRUD 소스 코드 생성을 위한 대상 Domain 클래스를 정의한다. 
								클래스명만 정의한 경우에는 해당 프로젝트의 대표 패키지 + ".domain" 하위에서 해당 Domain 클래스를 찾게 된다. 따라서 다른 패키지에 해당 Domain 클래스가 존재하는 경우 해당 클래스의 패키지명까지 포함하여 정의해주도록 한다.
								<itemizedlist>
									<listitem>
										<para>
											package : 생성될 CRUD 소스 코드의 패키지를 정의한다. [선택, 기본값은 해당 프로젝트의 대표 패키지 + {입력된 Entity 클래스 이름(소문자)}]
										</para>
									</listitem>
									<listitem>
										<para>
											scope : 생성될 CRUD 소스 코드를 영역을 한정하는데 사용된다. scope을 "service"로 정의한 경우 비즈니스 레이어 영역의 CRUD 소스 코드만 생성된다.
											[선택, 기본값은 "all"로써 프리젠테이션 레이어, 비즈니스 레이어의 모든 소스 코드를 생성]
										</para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry>anyframe change-db</entry>
							<entry>
								현재 사용 중인 DB를 변경하고자 할 때 DB 변경으로 인해 영향받는 속성 정보들을 일괄 변경해준다. (해당 프로젝트 내의 META-INF/project.mf 파일 내에 정의된 DB 정보를 기준으로 동작함.)
								<note>
									<title>참고</title>
									<para>
										현재 Anyframe에서 제공하는 Plugin들은 기본인 HsqlDB외에 Oracle, Sybase, MySQL, DB2를 위한 리소스를 추가로 제공하고 있다.
									</para>
								</note>
							</entry>
						</row>
						<row>
							<entry>anyframe update-catalog</entry>
							<entry>
								{user.home}/.anyframe 디렉토리 내에 존재하는 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일을 
								Anyframe Repository(http://dev.anyframejava.org/maven/repo) 내의 최신 plugin catalog 파일로
								교체해준다. 이로써 Plugin 목록 조회시 최신 정보를 조회할 수 있도록 한다.
								{user.home}/.anyframe 디렉토리 내에 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일이 없을 경우에도 활용 가능하다.
							</entry>
						</row>
						<row>
							<entry>anyframe list</entry>
							<entry>
								설치 가능한 Plugin의 이름과 버전 정보를 보여준다.
							</entry>
						</row>
						<row>
							<entry>anyframe info PLUGIN_NAME</entry>
							<entry>
								지정한 Plugin의 상세 정보를 조회할 수 있다. PLUGIN_NAME 위치에 조회하고자 하는 Plugin의 이름을 지정한다.
							</entry>
						</row>
						<row>
							<entry>anyframe list-update</entry>
							<entry>
								현재 생성된 샘플 프로젝트에 설치된 Plugin 중 버전 업데이트 가능한 Plugin 목록을 보여준다.
							</entry>
						</row>
						<row>
							<entry>anyframe installed</entry>
							<entry>
								설치된 Plugin 현황 및 해당 Plugin의 최신 버전 정보를 보여준다.
							</entry>
						</row>
						<row>
							<entry>anyframe build</entry>
							<entry>
								현재 샘플 어플리케이션을 Ant를 이용하여 빌드한다. 사용가능한 option은 다음과 같다.
								<itemizedlist>
									<listitem>
										<para>
											deploy : 프로젝트 배포 형태를 정의할 수 있다. "class" 혹은 "jar"를 입력한다.
											WEB-INF/classes 폴더 하위에 클래스 형태로 배포할 때 class로 설정하고, WEB-INF/lib 폴더 하위에 jar 파일 형태로 배포할 때 jar로 설정한다. [선택, 기본값은 'class']
										</para>
									</listitem>
									<listitem>
										<para>
											war : -war를 옵션을 사용하면 프로젝트가 생성된 폴더 하위의 dist 폴더에 프로젝트명.war 파일을 생성 한다.
										</para>
									</listitem>
									<listitem>
										<para>
											clean : -clean을 옵션을 추가하면 프로젝트가 생성된 폴더 하위의 dist 폴더 전체를 삭제 한 후 빌드를 수행한다.
										</para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry>anyframe run</entry>
							<entry>
								현재 샘플 어플리케이션을 빌드하고 디플로이 하여, Jetty 기반에서 웹 어플리케이션을 실행시켜 볼 수 있다.
								앞에서 설명된 어플리케이션 빌드 과정을 동일하게 수행한 후 웹 어플리케이션을 구동시켜주는 역할을 담당한다.
								사용가능한 option은 다음과 같다.
								<itemizedlist>
									<listitem>
										<para>
											deploy : 프로젝트 배포 형태를 정의할 수 있다. "class" 혹은 "jar"를 입력한다.
											WEB-INF/classes 폴더 하위에 클래스 형태로 배포할 때 class로 설정하고, WEB-INF/lib 폴더 하위에 jar 파일 형태로 배포할 때 jar로 설정한다. [선택, 기본값은 'class']
										</para>
									</listitem>
									<listitem>
										<para>
											war : -war를 옵션을 사용하면 프로젝트가 생성된 폴더 하위의 dist 폴더에 프로젝트명.war 파일을 생성 한다.
										</para>
									</listitem>
									<listitem>
										<para>
											clean : -clean을 옵션을 추가하면 프로젝트가 생성된 폴더 하위의 dist 폴더 전체를 삭제 한 후 빌드를 수행한다.
										</para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
		</section>
	</section>
	
	<section id="commands_ant_generate">
		<title>프로젝트 구조 생성</title>
		<para>
			생성할 샘플 프로젝트의 기본 구조 생성을 위해 적절한 Anyframe Archetype을 설치해야 한다. 이후 이를 기반으로 Anyframe을 활용한 개발 환경 구성이 가능해진다.
			Anyframe 4.6.0 이후부터 anyframe-basic-archetype, anyframe-service-archetype을 제공하고 있으며, 'web' 타입의 프로젝트는 anyframe-basic-archetype이, 'service' 타입의 프로젝트는 anyframe-service-archetype이 설치된다.
			본 장에서는 anyframe-basic-archetype을 기준으로 설명을 진행할 것이다. (Anyframe Archetype에 대해서는 <link linkend="commands_maven_generate_archetype">Archetype</link>을 참고하도록 한다.) 
		</para>
		
		<para>
			먼저 anyframe-basic-archetype을 설치해 보도록 하자.
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					env를 통해 환경 변수 정보가 설정된 command 창에서 프로젝트 생성을 위해 다음 command를 입력한다.
				</para>
				<para>
					<programlisting language="java"><![CDATA[anyframe create-project]]></programlisting>
					이 명령어를 통해 anyframe-basic-archetype이 설치되어 프로젝트가 생성된다.
					프로젝트가 생성되는 위치는 -appHome옵션에 의해 변경될 수 있다. 여기서는 디폴트값인 [Anyframe Home] 하위의 applications 폴더에 프로젝트를 생성한다.
				</para>
				<para>
					<itemizedlist>
						<listitem>
							<para>ex) anyframe create-project -pjtname myproject -pjttype web -package com.sds.emp</para>
							<para>
								위 예제는 com.sds.emp 대표패키지로 하는 myproject 프로젝트명의 Web 프로젝트를 생성하는 command이다. 
								옵션을 통해 설정한 정보는 해당 프로젝트 디렉토리 하위의 META-INF/project.mf 파일에 반영되고, anyframe-basic-archetype이 설치된다.
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<note>
					<title>
						offline 옵션
					</title>
					<para>
						프로젝트 현장의 네트워크 사용이 용이하지 않은 경우에 offline 옵션을 true로 입력하면 
						해당 프로젝트 디렉토리 하위의 META-INF/project.mf 파일에 offline 값이 true로 설정되고, 이후 모든 Command 실행시 offline으로 동작한다.
					</para>
					<para>
						이 경우 Local Repository([Anyframe Home]/repo)에 해당 프로젝트에서 필요한 라이브러리가 없을 경우에 정상적으로 동작하지 않을 수 있다.
					</para>
				</note>
			</listitem>
			<listitem>
				<para>
					다음은 anyframe-basic-archetype 설치를 통해 구성된 샘플 프로젝트의 기본 모습이다. 설치된 샘플 프로젝트명은 myproject이며, 하위에 다양한
					용도의 디렉토리를 포함하고 있다.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="../image/commands/ant/myproject_structure.jpg"
								align="center" />
						</imageobject>
					</mediaobject>
				</para>
				<para>
					생성된 프로젝트는 구조만 있는 상태로, web 타입 프로젝트의 경우 dynamic 웹 프로젝트 구조로, service 타입 프로젝트의 경우 자바 프로젝트 구조로 생성된다.
				</para>
				<para>
					Eclipse 프로젝트 관련 파일들(.project, .classpath)과 빌드 파일(build.xml), 프로젝트 설정 파일(META-INF/project.mf) 등은 프로젝트 타입과 상관없이 공통으로 생성된다.
					생성된 프로젝트 설정 파일(META-INF/project.mf)을 수정하면, 이후 Domain 클래스 생성 및 CRUD 소스코드 생성 등의 기능에서 수정된 설정 값을 통해 생성되도록 할 수 있다.
				</para>
			</listitem>
			<listitem>
				<para>
					프로젝트 생성 후에는 <link linkend="commands_ant_run">어플리케이션 실행</link>을 참조하여 정상 동작 여부를 확인하도록 한다.
				</para>
			</listitem>
		</orderedlist>
	</section>
	
	<section id="commands_ant_install">
		<title>Plugin 설치</title>
		<para>
			Anyframe 4.6.0 이후부터는 다양한 오픈 소스들이 통합된 템플릿 기반의 샘플 코드, 참조 라이브러리 집합을 Plugin이라 칭하며, 다양한 유형의 Plugin을 제공한다.
		</para>
		<para>
			Anyframe의 Plugin들은 <emphasis role="bold">필수(Essential) Plugin</emphasis>과 <emphasis role="bold">선택(Optional) Plugin</emphasis>으로 나눌 수 있다.
			필수 Plugin에는 core, spring, datasource, logging 과 같이 다른 Plugin이 동작하는데 기본적으로 필요한 기능들을 가진 Plugin들이 속해 있고,
			선택 Plugin에는 hibernate, cxf-jaxrs, fileupload 등과 같이 어플리케이션 개발시 사용할 수 있는 여러 기능들을 제공하는 Plugin들로 구성되어 있다.
			(Plugin에 대한 자세한 내용은 <link linkend="plugins_list">Plugin 목록</link>과 <link linkend="plugins_structure">Plugin 구조</link>를 참조하도록 한다.)
		</para>
		<para>
			다음에서는 기본적인 Command 사용법을 언급하고 있으므로 Anyframe Commmand Option에 대해서는 <link linkend="commands_ant_commands_list">Command 목록</link>내에 제시된 해당 Command의
			설명을 참고하도록 한다.		
		</para>
		
		<para>
			Anyframe의 Plugin은 특정 Plugin이 동작하는 데 필요한 Plugin을 Dependent Plugin으로 설정할 수 있다. 
			그래서 특정 Plugin 설치 시에 Dependent Plugin이 설치되지 않았을 경우 자동으로 우선 설치될 수 있도록 한다.
		</para>
		<para> 
			여기서는 다른 Anyframe Plugin들의 동작을 위한 기반을 제공하는 필수 Plugin인 core plugin을 설치해 보도록 하자.
			Plugin을 설치하면 해당 플러그인과 관련된 라이브러리가 src/main/webapp/WEB-INF/lib 에 반영된다. 
		</para>
		
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					Command 창을 띄우고 앞서 설치한 [샘플 프로젝트 설치 폴더]/db/hsqldb 폴더로 이동하여 start.cmd (or start.sh) 파일을 더블클릭함으로써 샘플용으로 제공되는 
					hsqldb를 시작시킨다. 해당 Plugin 실행을 위해 DB 데이터 추가가 필요한 경우 선택한 Plugin 설치시 DB 데이터 추가 작업도 함께 이루어지므로 DB를 시작시켜 놓아야 한다. 
					만일 선택한 Plugin 설치시 DB가 시작되지 않았다면 Plugin 설치 이후 제공되는 DB 스크립트 파일([샘플 프로젝트 설치 폴더]/db/scripts/{Plugin명-insert-data-db명}.sql)을 
					직접 실행시키면 된다. 또한 샘플용으로 제공되는 hsqldb가 아닌 다른 DB 기반에서 Plugin을 설치하고자 하는 경우에는 
					<link linkend="commands_ant_db">DB 변경</link>을 참고하도록 한다.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="../image/commands/ant/start_hsqldb.jpg"
								align="center" />
						</imageobject>
					</mediaobject>
				</para>
				<warning>
					<title>주의 사항</title>
					<para>
						Windows 환경에서는 start.cmd 파일을 CLI 상에서 실행시키고, Unix 환경(ex. Mac OS
						등)에서는
						우선 hsqldb 폴더 하위의 파일들에 대해서 실행 권한을 부여(chmod 755 *)한 후, start.sh
						파일을 실행(./start.sh)시킨다.
					</para>
				</warning>
			</listitem>
			<listitem>
				<para>
					Command 창을 띄우고 샘플 프로젝트 설치 폴더로 이동(예를 들어, myproject 라는 프로젝트를
					생성시켰다면 myproject 폴더에서 command를 실행시키도록 한다.)하여 다음과 같이 명령어를 입력한다.
					여기서는 core plugin을 설치할 것이므로 PLUGIN_NAME으로 'core'를 입력하여 core plugin 설치 작업을 진행한다.
				</para>
				<programlisting language="java"><![CDATA[anyframe install core]]></programlisting>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="../image/commands/ant/install_core_plugin.jpg"
								align="center" />
						</imageobject>
					</mediaobject>
				</para>
				<para>
					위와 같이, Plugin install 명령어를 입력하면 <emphasis role="bold">설치하고자 하는 Plugin의 dependency 관계 및 현재 프로젝트에 설치여부를 파악하여 
					최종적으로 설치될 Plugin들의 목록을 출력해주고 사용자의 승인을 기다린다.</emphasis>
					core plugin의 동작을 위해서는 datasource, logging, spring Plugin이 필요하므로 위와 같이 출력될 것이다.
					계속 설치를 진행하고자 하는 경우 'y'를 입력한다.
					<note id="commands_ant_install_essential">
						<title>Essential Plugins</title>
						<para>
							core, datasource, logging, spring plugin은 필수 plugin으로, 
							datasource, logging, spring plugin은 단독으로 설치할 수 없고, 
							core를 설치하면 4가지 plugin이 모두 설치된다.
						</para>
					</note>
				</para>
			</listitem>
			<listitem>
				<para>
					Plugin 설치 완료 후에는 <link linkend="commands_ant_run">어플리케이션 실행</link>을 참조하여 정상 동작 여부를 확인하도록 한다.
				</para>
			</listitem>
			<listitem>
				<para>
					Command 창을 띄우고 샘플 프로젝트 설치 폴더로 이동하여 다음과 같은 명령어를 입력하면 샘플 프로젝트를 대상으로 추가된 Plugin 목록을 확인할 수 있다. 
				</para>
				<programlisting language="java"><![CDATA[anyframe installed]]></programlisting>
				<mediaobject>
					<imageobject>
						<imagedata fileref="../image/commands/ant/show_plugin_installed.jpg"
							align="center" />
					</imageobject>
				</mediaobject>
				<para>
					Plugin이 정상적으로 설치되었다면, 지정한 패키지 경로에 설치한 Plugin 샘플 소스 코드가 생성되어 있고, 
					src/main/webapp/WEB-INF/lib에 Plugin 관련 라이브러리가 설치되어 있을 것이다.
				</para>
			</listitem>
		</orderedlist>
		<para>
			core plugin과 동일한 방법으로 다른 Plugin들을 추가로 설치할 수 있다.
		</para>
		<para>
			또한 이미 설치된 Plugin이라 하더라도 다음과 같이 <emphasis role="bold">install 명령어에 version옵션을 추가하여 다른 버전으로 교체</emphasis>할 수 있다.
			이 경우 해당 Plugin이 참조하는 다른 Plugin(Dependent Plugin)도 호환되는 버전으로 교체될 수 있다. 
			Plugin 버전 변경으로 인해 관련된 참조라이브러리 버전도 변경될 수 있음에 유의한다.
			<programlisting language="java"><![CDATA[anyframe install core -version ...]]></programlisting>
			<mediaobject>
				<imageobject>
					<imagedata fileref="../image/commands/ant/install_plugin_version.jpg"
						align="center" />
				</imageobject>
			</mediaobject>
		</para>
	</section>
	
	<section id="commands_ant_uninstall">
		<title>Plugin 삭제</title>
		<para>
			샘플 프로젝트를 대상으로 설치된 Plugin들은 삭제가 가능하다. 
			단, 삭제하고자 하는 Plugin을 다른 Plugin이 사용하고 있는 경우에는 삭제할 수 없다. 
			이 경우, Dependency 관계를 가지는 Plugin들을 먼저 삭제한 후에 본래 삭제하려고 했던 Plugin을 삭제해야한다.
		</para>
		<para>
			특정 Plugin 삭제를 요청한 경우 삭제 대상 Plugin 이름을 포함한 모든 폴더 및 파일들이 해당 프로젝트로부터 제거될 것이다. 
			따라서 특정 Plugin을 삭제하기 전에 개발을 진행하면서 추가한 리소스가 삭제 대상에 포함되지 않는지 체크해 볼 것을 권장한다.
		</para>
		<orderedlist>
			<listitem>
				<para>
					Command 창을 열고 샘플 프로젝트 설치 폴더로 이동하여 다음과 같이 Plugin 제거 명령어를 입력한다. 
				</para>
				<programlisting language="java"><![CDATA[anyframe uninstall PLUGIN_NAME]]></programlisting>
				<itemizedlist>
					<listitem>
						<para>ex) anyframe uninstall hibernate</para>
						<para>
							위 예제는 hibernate 플러그인에 대한 샘플과 라이브러리를 제거하는 command이다. 삭제하려고 하는 Plugin을 나머지 Plugin에서 사용하고 있지 않다면 문제없이 삭제될 것이다.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					excludes 옵션을 사용하면 plugin 삭제 시에 삭제 대상에서 제외시킬 파일을 지정할 수 있다.
				</para>
				<para>
					삭제하려고 하는 Plugin을 나머지 Plugin에서 사용하고 있지 않다면 문제없이 삭제될 것이다.
				</para>
			</listitem>
			<listitem>
				<para>
					Command 창을 열고 샘플 프로젝트 설치 폴더로 이동하여 다음과 같은 명령어를 입력하면 해당 Plugin이 정상적으로 삭제되었는지 확인할 수 있다. 
				</para>
				<programlisting language="java"><![CDATA[anyframe installed]]></programlisting>
			</listitem>
		</orderedlist>
		<para>
			삭제된 plugin 관련 파일이나 디렉토리는 '[샘플 프로젝트 root 폴더]/uninstalled' 하위에 
			plugin을 삭제한 시점별로 디렉토리에 백업되어 있으므로 복구가 가능하다.
		</para>
	</section>
	
	<section id="commands_ant_list">
		<title>Plugin 목록 조회</title>
		<para>
			설치할 수 있는 Plugin 목록을 조회하려면 다음과 같은 명령어를 사용한다.
			<programlisting language="java"><![CDATA[anyframe list]]></programlisting>
			<mediaobject>
				<imageobject>
					<imagedata fileref="../image/commands/ant/show_plugin_list.jpg"
						align="center" />
				</imageobject>
			</mediaobject>
		</para>
		<para>
			설치 가능한 Plugin 목록은 Plugin Catalog 파일 기반으로 조회되는데 Anyframe에서는 먼저 해당 파일이 '{user.home}/.anyframe' 디렉토리에 존재하는지 체크해 보고 
			있을 경우 해당 파일에 정의된 Plugin 정보를 활용하게 된다. 만일 '{user.home}/.anyframe' 디렉토리에 해당 파일이 존재하지 않으면 Anyframe Repository인 
			http://dev.anyframejava.org/maven/repo/에 있는 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일을 
			'{user.home}/.anyframe' 디렉토리에 다운로드하고 이 파일을 활용하게 된다.
			한번 다운로드한 Local의 Plugin Catalog 파일을 Anyframe Repository 내의 최신 Plugin Catalog 파일과 동기화하기 위해서는 
			<link linkend="commands_ant_update_catalog">Plugin Catalog Update</link>를 참조하도록 한다.
		</para>
	</section>
	
	<section id="commands_ant_installed">
		<title>설치된 Plugin 목록 조회</title>
		<para>
			다음의 command를 실행하면 샘플 프로젝트를 대상으로 설치된 Plugin들의 이름과 버전 및 각 Plugin의 최신 버전 정보를 확인할 수 있다.
		</para>
		<programlisting language="java"><![CDATA[anyframe installed]]></programlisting>
		<mediaobject>
			<imageobject>
				<imagedata fileref="../image/commands/ant/show_plugin_installed.jpg"
					align="center" />
			</imageobject>
		</mediaobject>
		<para>
			설치된 Plugin 정보는 샘플 프로젝트 하위의 META-INF/plugin-installed.xml 파일에 기록된다.
		</para>
	</section>
	
	<section id="commands_ant_info">
		<title>Plugin 정보 조회</title>
		<para>
			특정 Plugin의 상세한 정보를 조회하고자 하는 경우 다음과 같은 command를 이용하면 된다.
			<programlisting language="java"><![CDATA[anyframe info PLUGIN_NAME]]></programlisting>
		</para>
		<para>
			예를 들어, core plugin의 상세 정보를 조회하면 아래와 같이 출력된다.
			<programlisting language="java"><![CDATA[[info]  Name		: core
[info]  GroupId	: org.anyframe.plugin
[info]  ArtifactId	: anyframe-core-pi
[info]  Latest Version	: 1.0.1
[info]  Samples	: Included
[info]  Releases	: 1.0.0-SNAPSHOT,1.0.0.RC1,1.0.0,1.0.1-SNAPSHOT,1.0.1
[info]  Dependencies	: datasource(1.0.0-SNAPSHOT<=*),logging(1.0.0-SNAPSHOT<=*),spring(1.0.0-SNAPSHOT<=*)
[info]  Description	: Core Plugin is the basic plugin which is the basis of all
[info]		plugins provided by Anyframe, and consists of sample code
[info]		to guide how to use Spring MVC, Spring, etc. and reference
[info]		libraries to use these open sources.]]></programlisting>
		</para>
	</section>
	
	<section id="commands_ant_update_catalog">
		<title>Plugin Catalog Update</title>
		<para>
			앞서 언급한 바와 같이 Anyframe에서는 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일 내에 설치 가능한 Plugin 목록을 정의하고 있다. 
			Anyframe에서는 이 파일을 기반으로 설치 가능한 Plugin 목록을 조회하는데 먼저 해당 파일이 '{user.home}/.anyframe' 디렉토리에 존재하는지 체크해 보고 
			있을 경우 해당 파일에 정의된 Plugin 정보를 활용하게 된다. 만일 '{user.home}/.anyframe' 디렉토리에 해당 파일이 존재하지 않으면 Anyframe Repository인 
			http://dev.anyframejava.org/maven/repo/에 있는 plugin-catalog-essential.xml과 plugin-catalog-optional.xml 파일을 
			'{user.home}/.anyframe' 디렉토리에 다운로드하고 이 파일을 활용하게 된다.
			사용자의 '{user.home}/.anyframe' 하위에 한 번 다운로드가 된 이후에는 Local의 Plugin Catalog 파일만을 이용하게 되므로 
			시간이 지나면 Anyframe Repository 내의 최신 Plugin Catalog 파일과 일치하지 않을 수 있다. 
			따라서 최신 Plugin Catalog 파일과의 동기화를 위해서는 다음과 같은 작업이 필요하다.				
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					Command 창을 띄운 후, 샘플 프로젝트가 있는 위치로 이동하여 다음과 같이 명령어를 입력함으로써 최신 Plugin Catalog 파일을 Local에 다운로드할 수 있다.
				</para>
				<programlisting language="java"><![CDATA[anyframe update-catalog]]></programlisting>				
			</listitem>
			<listitem>
				<para>
					다음과 같이 명령어를 입력함으로써 최신 Plugin Catalog가 정상적으로 반영되었는지 확인해보자.
				</para>	
				<programlisting language="java"><![CDATA[anyframe list]]></programlisting>
			</listitem>
		</orderedlist>
	</section>
	
	<section id="commands_ant_list_update">
		<title>Update가능한 Plugin 목록 조회</title>
		<para>
			샘플 프로젝트를 대상으로 설치된 Plugin 중 버전 업데이트를 할 수 있는 Plugin이 있는지 확인하려면 다음과 같은 명령어를 사용한다.
			<programlisting language="java"><![CDATA[anyframe list-update]]></programlisting>
		</para>
		<para>
			단, Local의 Plugin Catalog 파일을 최신 버전으로 업데이트 한 후에야 정확한 정보를 확인할 수 있다. 
			Local Plugin Catalog를 업데이트 하는 방법은 본 문서의 <link linkend="commands_ant_update_catalog">Plugin Catalog Update</link>를 참조하도록 한다.
		</para>
		<para>
			현재 구성된 샘플 프로젝트에 설치된 Plugin의 버전이 최신 버전이 아닌 경우 이전 버전의 Plugin에 대해 최신 버전을 적용할 수 있도록 지원한다. 
			이를 원할 경우 <link linkend="commands_ant_install">Plugin 설치</link>를 참고하도록 한다. 
		</para>
	</section>
	
	<section id="commands_ant_db">
		<title>DB 변경</title>
		<para>
			앞서 언급한 바와 같이 Plugin 설치를 통해 생성된 샘플 프로젝트는 기본적으로 hsqldb를 기반으로 동작하도록 구성되어 있다. 그런데 만약 샘플 프로젝트의 실행 DB를 변경하고자 원한다면 
			다음과 같은 작업을 수행해야 한다.
			(현재 샘플을 제공하고 있는 Anyframe 플러그인은 hsqldb, oracle, sysbase, db2, mysql DB에 대해서만 동작하도록 지원하고 있다.)		
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					설치된 샘플 프로젝트 설치 폴더 하위의 META-INF/project.mf 파일을 열고 기 정의된 DB 정보를 적절하게 수정한다.
				</para>
				<programlisting language="java">db.type=hsqldb
db.name=sampledb
db.schema=PUBLIC
db.server=localhost
db.port=-1
db.driver=org.hsqldb.jdbcDriver
db.url=jdbc:hsqldb:hsql://localhost/sampledb
db.userId=SA
db.password=
db.lib=db/hsqldb/hsqldb-2.0.0.jar
db.dialect=org.hibernate.dialect.HSQLDialect

db.groupId=hsqldb
db.artifactId=hsqldb
db.version=2.0.0</programlisting>	
				<para>
					위에 제시된 각 속성은 다음과 같은 의미를 지닌다.
					<informaltable>
						<tgroup cols="2">
							<colspec colnum="1" colname="col1" colwidth="1*"/>
							<colspec colnum="2" colname="col2" colwidth="5*"/>
							<thead>
								<row>
									<entry align="center">Property</entry>
									<entry align="center">Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>db.type</entry>
									<entry>
										해당 DB에 대한 대표명을 정의한다. 특정 Plugin 설치 실행해야 할 DB 스크립트가 있다면 db.type 값을 포함하고 있는 스크립트
										({plugin name}-insert-data-{db.type}.sql, {plugin name}-delete-data-{db.type}.sql) 파일이 실행되도록 하는데 사용된다.
	               						(예를 들어, db.type이 oracle일 때 Security Plugin을 설치하면 security-insert-data-oracle.sql 파일이 실행됨.)  								
									</entry>
								</row>
								<row>
									<entry>db.name</entry>
									<entry>
										해당 DB에 대한 이름을 정의한다.
									</entry>
								</row>	
								<row>
									<entry>db.schema</entry>
									<entry>
										해당 DB의 Schema를 정의한다.
									</entry>
								</row>		
								<row>
									<entry>db.server</entry>
									<entry>
										해당 DB를 가진 서버의 IP를 정의한다.
									</entry>
								</row>	
								<row>
									<entry>db.port</entry>
									<entry>
										해당 DB를 위한 서버의 port를 정의한다.
									</entry>
								</row>																				
								<row>
									<entry>db.driver</entry>
									<entry>해당 DB에 대한 Driver Class명을 정의한다.</entry>
								</row>	
								<row>
									<entry>db.url</entry>
									<entry>해당 DB에 대한 URL을 정의한다.</entry>
								</row>
								<row>
									<entry>db.userId</entry>
									<entry>해당 DB에 접근하기 위한 User Id를 정의한다.</entry>
								</row>
								<row>
									<entry>db.password</entry>
									<entry>해당 DB에 접근하기 위한 Password를 정의한다.</entry>
								</row>
								<row>
									<entry>db.lib</entry>
									<entry>
										해당 DB에 접근하여 Connection을 얻어오기 위해 참조해야 하는 DB Library 위치를 정의한다. 
										(절대 경로 또는 샘플 프로젝트 위치 기준으로 상대 경로로 정의할 수 있다. 상대 경로 정의시 ./src/main/..와 같은 형태나 src/main/..와 같은 
										형태로 정의하도록 한다. /src/main/..와 같은 형태로 정의하는 경우 절대 경로로 인식하여 해당 파일을 찾지 못할 수 있다.)
										샘플 어플리케이션 실행시 DB Library를 인식할 수 있도록 하기 위해서 [샘플 프로젝트 설치 폴더]/src/main/webapp/WEB-INF/lib 폴더
										내에 저장할 것을 권장한다.
									</entry>
								</row>	
								<row>
									<entry>db.dialect</entry>
									<entry>해당 DB의 Hibernate Dialect 클래스를 정의한다.</entry>
								</row>
								<row>
									<entry>db.schema.use</entry>
									<entry>해당 DB가 Sybase DB일 경우, 지정해야 하는 속성으로 User 정보 셋팅시 DB Schema 정보를 사용할지 여부를 정의한다.
										단, Sybase 버전에 따라 속성값은 변경될 수 있음에 유의하도록 한다. (default=false)
									</entry>								
								</row>																																																												
							</tbody>
						</tgroup>
					</informaltable>
				</para>				
			</listitem>
			<listitem>
				<para>
					Command 창을 띄운 후, 샘플 프로젝트가 있는 위치로 이동하여 다음과 같이 명령어를 입력함으로써 앞서 수정한 DB 정보에 맞게 현재까지 설치된 Plugin의
					모든 DB 관련 리소스들을 수정할 수 있다.
				</para>
				<programlisting language="java"><![CDATA[anyframe change-db]]></programlisting>
			</listitem>
			<listitem>
				<para>
					DB 관련 설정 정보가 정상적으로 변경되었는지 확인한다.
				</para>
				<para>
					프로젝트 코드 내 DataSource Service 설정 정보 및 Hibernate, Query Service 관련 정보들이 변경되었는지 확인한다. 
				</para>
			</listitem>
		</orderedlist>
	</section>
		
	<section id="commands_ant_source_domain">
		<title>Domain 소스 코드 생성</title>
		<para>
			Anyframe 4.6.0 이후부터 새롭게 추가된 기능으로 이미 만들어져 제공된 Plugin들을 설치하는 작업 외에 
			새로 개발할 어플리케이션을 위해 구성된 DB 테이블을 기반으로 Domain 클래스를 생성할 수 있다.
			(이어질 설명에서는 기본적인 Commmand 사용법만을 언급하고 있으므로 Anyframe Commmand Option에 대한 자세한 내용은 <link linkend="commands_ant_commands_list">Command 목록</link>내에 제시된 해당 Command의
			설명을 참고하도록 한다.)
		</para>
		<para>
			Anyframe에서 기본적으로 제공하는 SampleDB 내에 포함된 모든 테이블을 대상으로 Domain 클래스를 생성해 보도록 하자.
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					Command 창을 띄운 후, 샘플 프로젝트가 있는 위치로 이동하여 다음과 같이 명령어를 입력함으로써 특정 테이블과 매핑되는 Domain
					클래스를 생성시킬 수 있다.
				</para>
				<programlisting language="java"><![CDATA[anyframe create-model]]></programlisting>
				<itemizedlist>
					<listitem>
						<para>ex) anyframe create-model -table "*" -package com.sds.emp.domain</para>
						<para>
							위 예제는 모든 테이블에 대해 Domain Class를 생성하되, 프로젝트 생성 시 지정한 대표 패키지(ex. com.sds.emp) 하위의 
							domain 패키지 내에 생성하는 command 이다.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					해당 DB에 속한 전체 테이블이 아닌 특정 테이블에 대해서만 Domain 클래스를 생성하고자 할 경우에는 다음과 같이 -table {table명}을 
					직접 입력해주면 된다. 
				</para>
				<programlisting language="java"><![CDATA[anyframe create-model -table BOARD_MASTER,BOARD]]></programlisting>
				<para>
					또한 해당 테이블에 대해 이미 생성된 Domain 클래스가 있을 경우에는 다음과 같이 overwrite할지 묻게 될 것이다. overwrite하지 않고 싶으면
					"N"를 입력하여 Domain 클래스 생성 작업을 종료할 수 있다.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="../image/commands/ant/create_model_overwrite.jpg"
								align="center" />
						</imageobject>
					</mediaobject>
				</para>
			</listitem>
			<listitem>
				<para>Domain 클래스가 정상적으로 생성되었는지 확인한다.</para>
				<para>
					Domain 클래스 생성 시 지정한 패키지 내에, camelcase 적용된 테이블 이름의 도메인 클래스가 존재하면 정상적인 것이다. 
					다음은 BOARD 테이블과 매핑되는 Board.java 코드의 일부분이다.
				</para>
				<programlisting language="java">@Entity
@Table(name = "BOARD")
<emphasis role="bold">//@Table의 schema 속성은 default 템플릿을 활용하여 
//sybase DB와 hibernate dao framework을 사용할때 정의됨
//@Table의 catalog 속성은 catalog 정보가 존재할 경우 정의됨</emphasis>
public class Board implements Serializable {
    private BoardId id = new BoardId();
    private BoardMaster boardMaster;
    private String boardName;
    중략...
    public BoardId getId() {
        return this.id;
    }
    public void setId(BoardId id) {
        this.id = id;
    }
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "BOARD_MASTER_ID", nullable = false, 
                insertable = false, updatable = false)
    public BoardMaster getBoardMaster() {
        return this.boardMaster;
    }
    public void setBoardMaster(BoardMaster boardMaster) {
        this.boardMaster = boardMaster;
    }
    @Column(name = "BOARD_NAME", nullable = false, length = 150)
    public String getBoardName() {
        return this.boardName;
    }
    public void setBoardName(String boardName) {
        this.boardName = boardName;
    }	  
}</programlisting>
			</listitem>
			<listitem>
				<para>자동생성되는 Domain 클래스 소스 코드에 대해서 각 개발자 혹은 프로젝트 상황에 맞게 템플릿 파일을 수정하여 사용할 수 있다. </para>
				<para>
					템플릿 확장에 관한 상세한 내용은 <link linkend="commands_maven_source_crud_template_customizing">Template Customizing</link>를 참고하도록 한다. 
					Ant의 경우, 템플릿 파일들은 '[Anyframe 설치 폴더]/templates' 디렉토리에 존재하고 
					이중 Domain 클래스에 대한 템플릿 파일은 templates 하위의 [템플릿명]/source/model 폴더 내에 있으므로 수정 시 활용하도록 한다. (Pojo.ftl 등)
				</para>
			</listitem>		
		</orderedlist>
	</section>
	
	<section id="commands_ant_source_crud">
		<title>CRUD 소스 코드 생성</title>
		<para>
			DB 테이블을 기반으로 생성한 Domain 클래스를 통해 기본 CRUD 기능을 수행하는 소스 코드들을 생성할 수 있다.
			(이어질 설명에서는 기본적인 Command 사용법만을 언급하고 있으므로 Anyframe Commmand Option에 대한 자세한 내용은 <link linkend="commands_ant_commands_list">Command 목록</link>내에 제시된 해당 Command의
			설명을 참고하도록 한다.)
		</para>
		<para>
			앞서 생성한 Domain 클래스 중 하나를 선택하여 CRUD 소스 코드를 생성해 보도록 하자.
		</para>
		<orderedlist numeration="arabic" inheritnum="inherit">
			<listitem>
				<para>
					Command 창을 띄운 후, 샘플 프로젝트가 있는 위치로 이동하여 다음과 같이 명령어를 입력함으로써 특정 Domain을 중심으로 기본적인 
					CRUD 기능을 수행하는 소스 코드들을 생성할 수 있다.
				</para>
				<programlisting language="java"><![CDATA[anyframe create-crud ENTITY]]></programlisting>
				<para>
					예를 들어, 'anyframe create-crud Board'라고 실행하면 Board 객체를 CRUD 할 수 있는 소스코드를 생성하게 된다. 
				</para>	
				<para>
					해당 Domain 클래스에 대해 이미 생성된 CRUD 소스 코드가 있을 경우에는 다음과 같이 overwrite할지 묻게 될 것이다. overwrite하지 않고 싶으면
					"N"를 입력하여 CRUD 소스 코드 생성 작업을 종료할 수 있다.
				</para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="../image/commands/ant/create_crud_overwrite.jpg"
							align="center" />
					</imageobject>
				</mediaobject>
				<para>
					또한, 비즈니스 레이어 코드만 생성하고자 하는 경우 아래와 같이 -scope 옵션을 추가하여 명령어를 실행할 수도 있다.
				</para>
				<programlisting language="java"><![CDATA[anyframe create-crud Board -scope service]]></programlisting>
				<para>
					scope 옵션에 대한 상세한 내용은 <link linkend="commands_ant_commands_list">Command 목록</link>을 참조하길 바란다.
				</para>
			</listitem>
			<listitem>
				<para>
					비즈니스 레이어 코드(서비스인터페이스, 서비스구현클래스, DAO구현클래스와 매핑쿼리문 등)가 정상적으로 생성되었는지 확인한다. 
				</para>
				<para>다음은 도메인 클래스 Board.java를 기반으로 생성된 자바 코드와 속성파일 등의 일부분이다.</para>	
				<itemizedlist>
					<listitem>
						<para>서비스 인터페이스 (src/main/java/{대표패키지}/{package}/service/{Entity 클래스명}Service.java)</para>
						<programlisting language="java">public interface BoardService{
    void create(Board board) throws Exception;
    void remove(BoardId id) throws Exception;
    ...
}</programlisting>
					</listitem>
					<listitem>
						<para>서비스 구현클래스 (src/main/java/{대표패키지}/{package}/service/impl/{Entity 클래스명}ServiceImpl.java)</para>
						<programlisting language="java">@Service("boardService")
@Transactional(rollbackFor = {Exception.class}, propagation = Propagation.REQUIRED)
public class BoardServiceImpl implements BoardService {
	    
    @Inject
    @Named("boardDao")
    private BoardDao boardDao;
	    
    public void create(Board board) throws Exception {
        this.boardDao.create(board);
    }
        
    public void remove(BoardId id) throws Exception {
        this.boardDao.remove(id);
    }
    ...        
}</programlisting>
					</listitem>
					<listitem>
						<para>DAO 클래스 (src/main/java/{대표패키지}/{package}/service/impl/{Entity 클래스명}Dao.java)</para>
					<programlisting language="java">@Repository("boardDao")
public class BoardDaoQueryImpl extends SimpleJdbcDaoSupport {

    @Value("#{contextProperties['pageSize'] ?: 10}")
    int pageSize;
    
    @Value("#{contextProperties['pageUnit'] ?: 10}")
    int pageUnit;
    
    @Inject
    public void setJdbcDaoDataSource(DataSource dataSource) throws Exception {
        super.setDataSource(dataSource);
    }
    
    public void create(Board board) throws Exception {
        String sql = "INSERT INTO BOARD (BOARD_ID, BOARD_DESC, BOARD_MASTER_ID, BOARD_NAME, BOARD_ORDER, BOARD_TOPICS, REG_DATE) "
                              + "VALUES (?, ?, ?, ?, ?, ?, ?)";
        this.getSimpleJdbcTemplate().update(
                                    sql,
                                    new Object[] {board.getId().getBoardId(), board.getBoardDesc(), board.getId().getBoardMasterId(), 
                                    board.getBoardName(), board.getBoardOrder(), board.getBoardTopics(), board.getRegDate()});
    }
        
    public void remove(BoardId id) throws Exception {
        String sql = "DELETE FROM BOARD WHERE BOARD_ID = ? AND BOARD_MASTER_ID = ?";
        this.getSimpleJdbcTemplate().update(sql, new Object[] {id.getBoardId(), id.getBoardMasterId()});
    }
    ...
}</programlisting>
					</listitem>
					<listitem>
						<para>MessageSoruce (src/main/resources/message/message-generation.properties)</para>
						<programlisting># -- Board-START
board.id.boardId=Board Id
board.id.boardMasterId=Board Master Id
board.boardDesc=Board Desc
board.boardName=Board Name
board.boardOrder=Board Order
board.boardTopics=Board Topics
board.regDate=Reg Date

# -- success messages -- 
success.board.create=Board has been added successfully.
success.board.update=Board has been updated successfully.
success.board.delete=Board has been deleted successfully.

# -- error messages --
error.boardserviceimpl.create=Board data not created
error.boardserviceimpl.create.solution=Enter correct data for mandatory field 
or enter data according to formats means date format as yyyy-mm-dd
error.boardserviceimpl.create.reason=Entered incorrect data for Board
...</programlisting>
					</listitem>
					<listitem>
						<para>통합 테스트케이스 (src/test/java/{대표패키지}/{package}/service/{Entity 클래스명}ServiceTest.java)</para>
						<programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "file:./src/main/resources/spring/context-*.xml" })
public class BoardServiceTest{

    @Inject
    @Named("boardService")
    private BoardService boardService;

    @Test
    @Rollback(value=true)    
    public void manageBoard() throws Exception {
        //1. create a new board
        Board board = getBoard();
        
        if(boardService.get(board.getId()) != null)
            boardService.remove(board.getId());
        
        boardService.create(board);
        ...
    }
    ...
}</programlisting>
					</listitem>
				</itemizedlist>
				<note>
					<title>참고 1</title>
					<para>
						META-INF/project.mf 에서 project.daoframework 값을 변경하지 않았을 경우 기본 DAO Framework은 springjdbc로 설정되어 
						있다. (위에서 보여준 DAO 구현 클래스는 springjdbc로 설정되어 있는 경우의 모습이다.) 설정할 수 있는 DAO Framework로는 springjdbc, query, hibernate, ibatis2 가 있다.
					</para>
					<para>
						META-INF/project.mf 에서 project.daoframework 값을 "hibernate"으로 설정하여 DAO Framework으로 Hibernate을 채택한 경우,
						생성된 CRUD 소스 코드는 Hibernate을 사용하는 형태를 갖추게 될 것이다. 단, Anyframe Hibernate Plugin이 설치되어야만 생성된 코드가 정상 동작할 수 있다.
					</para>
					<para>
						마찬가지로 Anyframe IDE를 통해서 생성할 소스코드의 Template Type을 디폴트로 지정된 값 이외의 값으로 설정하고 싶은 경우에도  
						이와 관련된 Anyframe Plugin이 설치되어 있어야 생성된 프로젝트가 정상적으로 동작할 수 있다.
					</para>
					<para>
						예를 들어, Template type을 'miplatform'으로 선택하여 소스코드를 생성하고자 하는 경우, 프로젝트 설정 파일(project.mf)의 project.template의 값을 miplatform으로 변경하는 것 뿐만 아니라
						Anyframe의 miplatform Plugin을 설치하여야 한다.
					</para>
				</note>
			</listitem>
			<listitem>
				<para>프리젠테이션 레이어 코드 (비즈니스 서비스와 통신을 하기 위한 컨트롤러 클래스, JSP 등)가 정상적으로 생성되었는지 확인한다.</para>
				<para>다음은 도메인 클래스 Board.java를 기반으로 생성된 컨트롤러, JSP 등의 일부분이다.</para>	
				<itemizedlist>
					<listitem>
						<para>컨트롤러 (src/main/java/{대표패키지}/{package}/web/{Entity 클래스명}Controller.java)</para>
						<programlisting language="java">@Controller
@RequestMapping("/board.do")
public class BoardController {

    @Inject
    @Named("boardService")
    private BoardService boardService;

    ...    

    @RequestMapping(params = "method=createView")  
    public String createView(Model model) throws Exception {
        model.addAttribute(new Board());

        return "generation/board/form";        
    }
}</programlisting>
					</listitem>
					<listitem>
						<para>JSP (src/main/webapp/WEB-INF/jsp/generation/{Entity 클래스명}/*.jsp)</para>
						<programlisting><![CDATA[<%@ page language="java" errorPage="/sample/common/error.jsp"
                 pageEncoding="UTF-8" contentType="text/html;charset=utf-8" %>                 
<%@ include file="/sample/common/taglibs.jsp"%>
<html>
<head>
    <%@ include file="/sample/common/meta.jsp" %>
    <title><fmt:message key="boardList.title"/></title>
    <meta name="heading" content="<spring:message code='boardList.heading'/>"/>    
    <link rel="stylesheet" href="<c:url value='/sample/css/admin.css'/>" 
        type="text/css">
	
    <script type="text/javascript" 
        src="<c:url value='/sample/javascript/CommonScript.js'/>"></script>    
    <script language="JavaScript">
        function fncCreateBoardView() {
            document.location.href="<c:url value='/board.do?method=createView'/>";
        }
...]]></programlisting>
					</listitem>
					<listitem>
						<para>단위 테스트케이스 (src/test/java/{대표패키지}/{package}/web/{Entity 클래스명}ControllerTest.java)</para>
						<programlisting language="java">@RunWith(JMock.class)
public class BoardControllerTest {

    private BoardController controller;
    private String SUCCESS_CREATEVIEW = "generation/board/form";
    private String SUCCESS_CREATE = "redirect:/board.do?method=list";
    private String SUCCESS_GET = "generation/board/form";
    private String SUCCESS_UPDATE = "redirect:/board.do?method=list";
    private String SUCCESS_LIST = "generation/board/list";
    private String SUCCESS_REMOVE = "redirect:/board.do?method=list";
    private Mockery context = new JUnit4Mockery();
    private BoardService mockService = null;
	
    @Before   
    public void setUp() throws Exception {
        System.setProperty("log4j.configuration", "log4j-test.xml");

        this.mockService = context.mock(BoardService.class);
        this.controller = new BoardController();
        this.controller.setBoardService(this.mockService);
    }
    
    public void setBoardController(BoardController controller) {
        this.controller = controller;
    }
        
    @Test
    public void testCreateView() throws Exception{
        String viewName = this.controller.createView(new ExtendedModelMap());
        
        assertEquals("returned correct view name", SUCCESS_CREATEVIEW, viewName);
   }
...</programlisting>
					</listitem>
				</itemizedlist>
			</listitem>
			<note>
				<title>CRUD 소스 코드가 정상적으로 자동 생성되지 않는 경우</title>
				<para>
					CRUD 소스 코드가 정상적으로 생성되지 않는 경우, {user.home}/.anyframe/templates에 존재하는 
					소스 코드 템플릿 파일에 문제가 있을 수도 있으므로, 이 디렉토리를 삭제한 후에 다시 anyframe:create-crud command를 실행시켜 보기를 권장한다.
				</para>
			</note>
			<listitem>
				<para>
					CRUD 소스 코드 생성 후에는 <link linkend="commands_ant_run">어플리케이션 실행</link>을 참조하여 정상 동작 여부를 확인하도록 한다. 
				</para>
			</listitem>
		</orderedlist>
		<note>
			<title>참고 2</title>
			<para>
				CRUD 소스 코드 생성은 도메인 클래스를 기반으로 이루어지는데, 이를 위해 도메인 클래스를 포함한 전체
				프로젝트의 소스 코드를 컴파일을 한 후 컴파일된 도메인 클래스를 이용하여 코드를 생성한다. 그러므로 프로젝트 내 소스
				코드의 양이 많아 CRUD 소스 코드 생성 시 컴파일에 걸리는 시간이 많이 소요되는 경우, [Anyframe
				Home]/ide/cli/scripts 폴더 내에 있는 code-generation.xml 파일에서
				"create-crud" target 내에 정의된 다음 clean target을 호출해주는 부분을 제거해주도록 한다.
				clean target에서는 기존에 컴파일된 모든 소스 코드를 삭제한 후 이후 compile target에서 새로 전체
				소스 코드를 컴파일하게 되므로 소스 코드의 양이 많을 경우 시간이 많이 소요될 수 있다. 속도 향상을 위해서 clean target을 제거하는 경우 incremental
				build를 수행하는 compile target에 의해 변경된 소스 코드만 컴파일되므로 시간이 적게 소요된다.
			</para>
			<programlisting language="java"><![CDATA[<ant antfile="build.xml" dir="${project.home}" target="clean"/>]]></programlisting>
		</note>
		<warning>
			<title>주의 사항</title>
			<para>
			anyframe-service-archetype으로 생성된 <emphasis role="bold">서비스 타입의 프로젝트</emphasis>일 경우, 
			hibernate나 miplatform plugin 설치 시에 관련 spring 설정 파일(context-*.xml)이 설치되지 않는다. 
			따라서, dao framework을 hibernate으로 설정하거나, template type을 miplatform으로 선택하여
			소스코드를 생성한 경우, 관련 속성 파일이 존재하지 않아서 자동 생성된 테스트 케이스는 수행시 오류가 발생하게 된다.
			"Fail to ApplicationContext..." 에러가 발생하면 hibernate 또는 miplatform spring 설정 파일을 추가해 주도록 한다.
			</para>
		</warning>
		<section id="commands_ant_source_crud_note">
			<title>CRUD 소스코드 생성 후 런타임 시 발생하는 에러 해결 Tip</title>
			<para>
				CRUD 소스코드는 정상적으로 생성되었지만 런타임시에 발생할 수 있는 문제에 대한 해결방법은 Maven 기반의 개발 시 문제 해결방법과 동일하다.
				[<link linkend="commands_maven_source_crud_note">CRUD 소스코드 생성 후 런타임 시 발생하는 에러 해결 Tip</link>]을 참조한다.
			</para>
		</section>
		<section id="commands_ant_source_crud_template_customizing">
			<title>Template Customizing</title>
			<para>
			    Ant의 경우, 템플릿 파일들은 '[Anyframe 설치 폴더]/templates' 디렉토리에 존재하고 
				CRUD 소스 코드 생성에 관련된 템플릿 파일은 templates 하위의 [템플릿명]/source 폴더 내에 있으므로 수정 시 활용하도록 한다.
					 
				Anyframe IDE를 통해 만들어진 Domain클래스나 CRUD 소스 코드들은 FreeMarker Template을 기반으로 자동 생성되는데,
				이 Template은 개발자 혹은 프로젝트 상황에 맞게 수정하여 사용할 수 있다. 
				Template 확장 방법은 Maven 기반의 개발 시와 동일하므로
				[<link linkend="commands_maven_source_crud_template_customizing">Template Customizing</link>]을 참조한다.
			</para>
		</section>
	</section>
	
	<section id="commands_ant_build">
		<title>어플리케이션 및 프로젝트 빌드</title>
		
		<section id="commands_ant_build_application">
			<title>어플리케이션 빌드</title>
			<para>
				CLI환경에서 Anyframe이 제공하는 command를 이용해서 어플리케이션을 빌드한다.
			</para>
			<orderedlist inheritnum="inherit">
				<listitem>
					<para>
						Command 창을 띄운 후, 샘플 프로젝트 설치 폴더 위치로 이동하여 다음과 같이 명령어를 입력한다.
					</para>
					<programlisting><![CDATA[anyframe build]]></programlisting>
				</listitem>
				<listitem>
					<para>
						프로젝트가 생성된 폴더 하위의 dist폴더에 프로젝트 명으로 된 배포폴더가 생성되고, 옵션에 따라 배포형태 및 war 파일 생성유무 등이 결정된다.
						<itemizedlist>
							<listitem>
								<para>ex) anyframe build -deploy jar -war</para>
								<para>위 예제는 jar 파일 형태로 프로젝트를 패키징하여 배포 파일을 생성하고, war 파일을 생성하는 command이다.</para>
							</listitem>
							<listitem>
								<para>ex) anyframe build -deploy class</para>
								<para>
									위 예제는 어플리케이션 전체 빌드 후, WEB-INF/classes 폴더 하위에 프로젝트 소스 코드 컴파일 결과를 class 파일 형태로 배포하는 경우에 사용한다.
									빌드된 결과를 WEB-INF/classes 에서 확인하며,WEB-INF/classes 아래에 컴파일된 자바코드, 설정파일, 매핑쿼리문 등이 생성된다.
								</para>
							</listitem>
							<listitem>
								<para>ex) anyframe build -deploy jar</para>
								<para>
									위 예제는 어플리케이션 전체 빌드 후, WEB-INF/lib 폴더 하위에 프로젝트 소스 코드 컴파일 결과를 jar 파일 형태로 배포하는 경우에 사용한다.
									빌드된 결과를 WEB-INF/lib 에서 확인하며, 하나의 프로젝트 이름(예를 들면 myproject)으로 jar 파일이 생성된다.
								</para>
							</listitem>
							<listitem>
								<para>ex) anyframe build -war</para>
								<para>
									위 예제는 어플리케이션 전체 빌드 후, war 파일을 생성하는 경우에 사용한다.
									빌드된 결과를 프로젝트가 생성된 폴더/dist/ 폴더 하위에서 확인한다. 프로젝트가 생성된 폴더/dist 폴더에는 프로젝트 명으로 된 war 파일이 생성된다. 예) myproject.war
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
			</orderedlist>
			<note>
				<title>참고</title>
				<para>
					현재 Anyframe IDE에서는 어플리케이션 빌드 관련된 빌드 스크립트를 [Anyframe Home]/ide/cli/scripts/application-build.xml 파일에서 관리하고 있다.
					이 빌드 파일 내에서 target명이 "build"인 경우가 어플리케이션 빌드에 해당된다.
				</para>
				<programlisting language="xml"><![CDATA[<target name = "build" depends = "clean, dist, war"/>
	중략...]]></programlisting>
				<para>
					만약 어플리케이션 빌드 프로세스 내용 중 일부를 변경시키고자 한다면 application-build.xml 파일
					내용을 변경하도록 한다.
				</para>
			</note>
		</section>
		
		<section id="commands_ant_build_project">
			<title>프로젝트 빌드</title>
			<para>
				CLI환경에서 Anyframe에서 제공하는 build 명령어를 이용하여 빌드를 수행할 수도 있지만, build.xml를 이용하여 직접 ant 명령어를 실행함으로써 프로젝트에 대한 빌드를 수행할 수도 있다.
			</para>
			<orderedlist inheritnum="inherit">
				<listitem>
					<para>
						설치한 프로젝트에 ant 실행을 위한 build.xml 파일이 존재하는지 확인하고, Command 창을 띄운 후, 샘플 프로젝트 설치 폴더 위치로 이동하여 다음과 같이 명령어를 입력한다.
					</para>
					<programlisting><![CDATA[ant]]></programlisting>
					<itemizedlist>
						<listitem>
							<para>ex) ant all</para>
							<para>
								위 예제는 프로젝트에 대해서 all이라는 target을 실행시키는 ant command로 아래와 같은 target 중 하나를 선택하여 프로젝트 빌드 프로세스를 수행시킬 수 있다. 
								target을 입력하지 않고 ant만 실행시킨 경우 default target인 "default"가 수행된다.
							</para>
						</listitem>
					</itemizedlist>
					<informaltable>
						<tgroup cols="2">
							<colspec colnum="1" colname="col1" colwidth="2*"/>
							<colspec colnum="2" colname="col2" colwidth="6*"/>
							<thead>
								<row>
									<entry>target</entry>
									<entry>description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>default</entry>
									<entry>프로젝트에 대해서 초기화, 컴파일, 패키징  등의 기본 빌드 프로세스를 수행한다.</entry>
								</row>
								<row>
									<entry>deploy</entry>
									<entry>default target을 수행한 후 web type 프로젝트의 경우 war 파일 압축이 풀려진 형태의 폴더를 dist 폴더 하위에 배포한다.</entry>
								</row>									
								<row>
									<entry>all</entry>
									<entry>
										위에 설명한 "default" target에서 수행하는 빌드 프로세스 작업 외에 테스트 케이스
										수행, 소스 코드 커버리지, CheckStyle/JDepend/FindBugs/Code Duplication
										등의 코드 품질 검사 리포팅까지의 작업을 추가로 더 수행한다.
									</entry>
								</row>
								<row>
									<entry>그외</entry>
									<entry>
										"clean", "init", "resources", "compile",
										"test-resources",
										"test-compile", "package", "emma-jars",
										"test", "report",
										"deploy" 등 빌드 프로세스 작업 내역 하나 별로 하나의 ant
										target이 구성되어 있으므로 위에서
										설명한 "default"와 "all" target 이외의 작업 별 빌드를
										수행해야 할 필요가 있으면 사용하도록
										한다.
									</entry>
								</row>
							</tbody>
						</tgroup>
					</informaltable>
				</listitem>
			</orderedlist>
			<note>
				<title>참고</title>
				<para>
					현재 Anyframe IDE에서는 프로젝트 빌드 스크립트를 [Anyframe Home]/ide/cli/scripts/project-build.xml 파일에서 관리하고 있다. (project-build.properties 함께 제공)
					이 빌드 파일 내 target명들 앞에 prefix로 "shared:"가 붙어있어서 실제 생성한 프로젝트 내 빌드 파일(build.xml)에서는 이 공통
					프로젝트 빌드 파일(project-build.xml)의 target명을 호출하여 실제 프로젝트 빌드를 수행하게 되며, 
					각 프로젝트 별로 특화된 빌드 프로세스를 추가해넣을 수도 있다.
				</para>
				<para>
					만약 공통 프로젝트 빌드 파일을 변경하여 나머지 모든 프로젝트 내 빌드 프로세스 내용을 변경시키고자 한다면 project-build.xml 파일
					내용을 변경하도록 한다.
				</para>
			</note>
		</section>
		
	</section>
	
	<section id="commands_ant_run">
		<title>어플리케이션 실행</title>
		<para>
			특정 Plugin 설치 후 또는 코드 자동 생성 결과로 구성된 샘플 어플리케이션이 정상적으로 동작하는지 확인하기 위해서는 
			Command 창에 명령어를 직접 입력하거나 Eclipse를 이용할 수 있다.
		</para>	
		<para>
			다음에서는 Command를 직접 입력하거나 Eclipse를 이용하여 샘플 어플리케이션을 시작시키는 방법에 대해서 살펴보도록 한다.
			(본 문서에서는 Jetty, Tomcat을 기준으로 설명이 진행된다.)
		</para>		
		<para>
			샘플 어플리케이션의 정상 동작 여부를 체크하기 위해서는 먼저 사용할 DB가 시작되어 있어야 한다. Anyframe Plugin 설치로 구성되는 
			샘플 프로젝트는 기본적으로 hsqldb를 사용하도록 구성되어 있다. 따라서, [샘플 프로젝트 설치 폴더]/db/hsqldb/start.cmd (or start.sh) 파일을
			더블 클릭하여 DB를 시작시키도록 한다. 
			(hsqldb가 아닌 다른 DB를 사용하고자 하면 <link linkend="commands_ant_db">DB 변경</link> 방법을 참조하도록 한다.)
			[샘플 프로젝트 설치 폴더]/db/hsqldb 폴더 내에 제공되는 sqltool.cmd (or sqltool.sh) 파일은 hsqldb용 SQL Editor를 시작시키는 
			용도로 제공된다. DB 작업 수행 후 결과를 확인하고자 할 때 유용하게 활용할 수 있을 것이다.
		</para>
		
		<section id="commands_ant_run_jetty">
			<title>Jetty 기반의 어플리케이션 실행</title>
			<para>
				CLI환경에서 Anyframe에서 제공하는 Command를 이용하여 어플리케이션을 빌드하고 웹 어플리케이션을 실행시켜본다.
				이 command는 프로젝트가 web 타입인 경우에만 이용가능하다.
			</para>
			<orderedlist inheritnum="inherit">
				<listitem>
					<para>
						Command 창을 띄운 후, 샘플 프로젝트 설치 폴더 위치로 이동하여 다음과 같이 명령어를 입력하면 Jetty 기반에서 샘플 어플리케이션을 시작시킬 수 있다.
					</para>
					<programlisting><![CDATA[anyframe run]]></programlisting>
					<para>	
						앞에서 설명된 어플리케이션 빌드 과정을 동일하게 수행한 후 웹 어플리케이션을 구동시켜주는 역할을 담당한다.
					</para>
				</listitem>
				<listitem>
					<para>
						Jetty가 정상적으로 시작되면 Started Jetty Server라는 INFO 레벨의 로그가 콘솔창에 보일 것이다.
						(TestCase에서 JMock클래스 때문에 컴파일 오류가 발생하는 경우, Ctrl+C키를 이용해서 Jetty서버를 중지하고,
						Command창에서 'mvn anyframe:install -Dname=test'를 실행하여 test Plugin을 설치한 후 다시 Jetty를 실행시킨다.)
					</para>
				</listitem>
				<listitem>
					<para>
						WAS가 정상적으로 시작되었으면 웹브라우저를 열고 주소창에 http://localhost:8080/myproject (http://localhost:8080/${샘플 프로젝트 이름})와 같이 입력하여 
						샘플 어플리케이션이 정상적으로 실행되는지 확인해본다. 
						요청 URL에서 Port 정보가 <emphasis role="bold">8080</emphasis>인 것에 유의하도록 한다.
						다음은 core plugin만 설치된 경우 샘플 어플리케이션의 초기 화면이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_initial.jpg"
									align="center" />
							</imageobject>					
						</mediaobject>
					</para>
					<para>
						Plugin이 추가 설치될 때마다 테이블의 왼쪽 Installed Plugins 칸에 추가된 Plugin에 대한 샘플을 확인할 수 있도록 링크가 추가될 것이다. 
						CRUD 소스 코드를 자동으로 생성시키면 테이블의 오른쪽 Generated CRUD Codes 칸에 만들어진 기능을 확인할 수 있는 링크가 추가된다.
					</para>
					<para>
						다음은 Core 링크를 클릭하였을 때 이동한 페이지의 모습이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_core_initial.jpg"
									align="center" />
							</imageobject>
						</mediaobject>
					</para>
				</listitem>
				<listitem>
					<para>
						Jetty 폴더를 확인한다.
					</para>
					<para>
						프로젝트 dist 폴더 하위에 jetty-temp라는 폴더가 생성되어 Jetty가 구동되게 된다. 배포
						이후에 클래스나 JAR 파일, JSP 파일 등을 반영하고 Jetty로 재확인하고 싶다면 이 폴더의 해당 위치에 배포하도록 한다. 
					</para>
				</listitem>
			</orderedlist>
		</section>
				
		<section id="commands_ant_run_tomcat_wtponly">
			<title>Eclipse WTP를 이용하여 Tomcat 기반의 어플리케이션 실행</title>
			<para>
				Eclipse WTP를 이용하여 일반 Dynamic Web Project 형태로 샘플 어플리케이션을 실행시킬 수 있다.
			</para>
			<orderedlist numeration="arabic" inheritnum="inherit">
				
				<listitem>
					<para>
						설치된 샘플 프로젝트를 Eclipse로 import한 이후 해당 프로젝트에 대해 컴파일 오류가 존재하지 않는지 체크한다.
						(TestCase에서 JMock클래스 때문에 컴파일 오류가 발생하는 경우, Command창에서 'anyframe install test'를 실행하여 test Plugin을 설치하고, Eclispe에서 해당 프로젝트를 Refresh한다.)
						그리고 해당 프로젝트에 대해 마우스 오른쪽 버튼을 클릭하여 컨텍스트 메뉴에서 Run As > Run on Server를 선택함으로써 
						Tomcat Server에 어플리케이션을 배포하여 샘플 어플리케이션이 정상적으로 실행되는지 확인해본다.
					</para>				
				</listitem>
				<listitem>
					<para>
						다음은 core plugin만 설치된 경우 샘플 어플리케이션의 초기 화면이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_initial.jpg"
									align="center" />
							</imageobject>					
						</mediaobject>
					</para>
					<para>
						Plugin이 추가 설치될 때마다 테이블의 왼쪽 Installed Plugins 칸에 추가된 Plugin에 대한 샘플을 확인할 수 있도록 링크가 추가될 것이다. 
						CRUD 소스 코드를 자동으로 생성시키면 테이블의 오른쪽 Generated CRUD Codes 칸에 만들어진 기능을 확인할 수 있는 링크가 추가된다.
					</para>
					<para>
						다음은 Core 링크를 클릭하였을 때 이동한 페이지의 모습이다.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="../image/commands/maven/sample_core_initial.jpg"
									align="center" />
							</imageobject>		
						</mediaobject>
					</para>
				</listitem>
			</orderedlist>
		</section>
	</section>
	
</chapter>